
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CareerStats
 * 
 */
export type CareerStats = $Result.DefaultSelection<Prisma.$CareerStatsPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model GuestPlayer
 * 
 */
export type GuestPlayer = $Result.DefaultSelection<Prisma.$GuestPlayerPayload>
/**
 * Model TeamInvitation
 * 
 */
export type TeamInvitation = $Result.DefaultSelection<Prisma.$TeamInvitationPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model TeamMatch
 * 
 */
export type TeamMatch = $Result.DefaultSelection<Prisma.$TeamMatchPayload>
/**
 * Model TeamMatchPlayer
 * 
 */
export type TeamMatchPlayer = $Result.DefaultSelection<Prisma.$TeamMatchPlayerPayload>
/**
 * Model TeamStatistics
 * 
 */
export type TeamStatistics = $Result.DefaultSelection<Prisma.$TeamStatisticsPayload>
/**
 * Model LocalMatch
 * 
 */
export type LocalMatch = $Result.DefaultSelection<Prisma.$LocalMatchPayload>
/**
 * Model MatchSpectator
 * 
 */
export type MatchSpectator = $Result.DefaultSelection<Prisma.$MatchSpectatorPayload>
/**
 * Model OverHistory
 * 
 */
export type OverHistory = $Result.DefaultSelection<Prisma.$OverHistoryPayload>
/**
 * Model MatchSummary
 * 
 */
export type MatchSummary = $Result.DefaultSelection<Prisma.$MatchSummaryPayload>
/**
 * Model PlayerMatchHistory
 * 
 */
export type PlayerMatchHistory = $Result.DefaultSelection<Prisma.$PlayerMatchHistoryPayload>
/**
 * Model Fixture
 * 
 */
export type Fixture = $Result.DefaultSelection<Prisma.$FixturePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  BATSMAN: 'BATSMAN',
  BOWLER: 'BOWLER',
  ALL_ROUNDER: 'ALL_ROUNDER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const BattingHand: {
  RIGHT: 'RIGHT',
  LEFT: 'LEFT'
};

export type BattingHand = (typeof BattingHand)[keyof typeof BattingHand]


export const BowlingStyle: {
  FAST: 'FAST',
  MEDIUM_FAST: 'MEDIUM_FAST',
  SPIN: 'SPIN'
};

export type BowlingStyle = (typeof BowlingStyle)[keyof typeof BowlingStyle]


export const MatchStatus: {
  UPCOMING: 'UPCOMING',
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]


export const MatchResult: {
  HOME_WIN: 'HOME_WIN',
  AWAY_WIN: 'AWAY_WIN',
  DRAW: 'DRAW'
};

export type MatchResult = (typeof MatchResult)[keyof typeof MatchResult]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const LocalMatchStatus: {
  CREATED: 'CREATED',
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type LocalMatchStatus = (typeof LocalMatchStatus)[keyof typeof LocalMatchStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type BattingHand = $Enums.BattingHand

export const BattingHand: typeof $Enums.BattingHand

export type BowlingStyle = $Enums.BowlingStyle

export const BowlingStyle: typeof $Enums.BowlingStyle

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

export type MatchResult = $Enums.MatchResult

export const MatchResult: typeof $Enums.MatchResult

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type LocalMatchStatus = $Enums.LocalMatchStatus

export const LocalMatchStatus: typeof $Enums.LocalMatchStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.careerStats`: Exposes CRUD operations for the **CareerStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareerStats
    * const careerStats = await prisma.careerStats.findMany()
    * ```
    */
  get careerStats(): Prisma.CareerStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guestPlayer`: Exposes CRUD operations for the **GuestPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuestPlayers
    * const guestPlayers = await prisma.guestPlayer.findMany()
    * ```
    */
  get guestPlayer(): Prisma.GuestPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamInvitation`: Exposes CRUD operations for the **TeamInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamInvitations
    * const teamInvitations = await prisma.teamInvitation.findMany()
    * ```
    */
  get teamInvitation(): Prisma.TeamInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMatch`: Exposes CRUD operations for the **TeamMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMatches
    * const teamMatches = await prisma.teamMatch.findMany()
    * ```
    */
  get teamMatch(): Prisma.TeamMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMatchPlayer`: Exposes CRUD operations for the **TeamMatchPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMatchPlayers
    * const teamMatchPlayers = await prisma.teamMatchPlayer.findMany()
    * ```
    */
  get teamMatchPlayer(): Prisma.TeamMatchPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamStatistics`: Exposes CRUD operations for the **TeamStatistics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamStatistics
    * const teamStatistics = await prisma.teamStatistics.findMany()
    * ```
    */
  get teamStatistics(): Prisma.TeamStatisticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localMatch`: Exposes CRUD operations for the **LocalMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalMatches
    * const localMatches = await prisma.localMatch.findMany()
    * ```
    */
  get localMatch(): Prisma.LocalMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchSpectator`: Exposes CRUD operations for the **MatchSpectator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchSpectators
    * const matchSpectators = await prisma.matchSpectator.findMany()
    * ```
    */
  get matchSpectator(): Prisma.MatchSpectatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.overHistory`: Exposes CRUD operations for the **OverHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OverHistories
    * const overHistories = await prisma.overHistory.findMany()
    * ```
    */
  get overHistory(): Prisma.OverHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchSummary`: Exposes CRUD operations for the **MatchSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchSummaries
    * const matchSummaries = await prisma.matchSummary.findMany()
    * ```
    */
  get matchSummary(): Prisma.MatchSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.playerMatchHistory`: Exposes CRUD operations for the **PlayerMatchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerMatchHistories
    * const playerMatchHistories = await prisma.playerMatchHistory.findMany()
    * ```
    */
  get playerMatchHistory(): Prisma.PlayerMatchHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fixture`: Exposes CRUD operations for the **Fixture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fixtures
    * const fixtures = await prisma.fixture.findMany()
    * ```
    */
  get fixture(): Prisma.FixtureDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    CareerStats: 'CareerStats',
    Team: 'Team',
    TeamMember: 'TeamMember',
    GuestPlayer: 'GuestPlayer',
    TeamInvitation: 'TeamInvitation',
    Match: 'Match',
    TeamMatch: 'TeamMatch',
    TeamMatchPlayer: 'TeamMatchPlayer',
    TeamStatistics: 'TeamStatistics',
    LocalMatch: 'LocalMatch',
    MatchSpectator: 'MatchSpectator',
    OverHistory: 'OverHistory',
    MatchSummary: 'MatchSummary',
    PlayerMatchHistory: 'PlayerMatchHistory',
    Fixture: 'Fixture'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "careerStats" | "team" | "teamMember" | "guestPlayer" | "teamInvitation" | "match" | "teamMatch" | "teamMatchPlayer" | "teamStatistics" | "localMatch" | "matchSpectator" | "overHistory" | "matchSummary" | "playerMatchHistory" | "fixture"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CareerStats: {
        payload: Prisma.$CareerStatsPayload<ExtArgs>
        fields: Prisma.CareerStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CareerStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CareerStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload>
          }
          findFirst: {
            args: Prisma.CareerStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CareerStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload>
          }
          findMany: {
            args: Prisma.CareerStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload>[]
          }
          create: {
            args: Prisma.CareerStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload>
          }
          createMany: {
            args: Prisma.CareerStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CareerStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload>
          }
          update: {
            args: Prisma.CareerStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload>
          }
          deleteMany: {
            args: Prisma.CareerStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CareerStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CareerStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CareerStatsPayload>
          }
          aggregate: {
            args: Prisma.CareerStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareerStats>
          }
          groupBy: {
            args: Prisma.CareerStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerStatsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CareerStatsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CareerStatsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CareerStatsCountArgs<ExtArgs>
            result: $Utils.Optional<CareerStatsCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamMemberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamMemberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      GuestPlayer: {
        payload: Prisma.$GuestPlayerPayload<ExtArgs>
        fields: Prisma.GuestPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuestPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuestPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload>
          }
          findFirst: {
            args: Prisma.GuestPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuestPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload>
          }
          findMany: {
            args: Prisma.GuestPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload>[]
          }
          create: {
            args: Prisma.GuestPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload>
          }
          createMany: {
            args: Prisma.GuestPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuestPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload>
          }
          update: {
            args: Prisma.GuestPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload>
          }
          deleteMany: {
            args: Prisma.GuestPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuestPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuestPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestPlayerPayload>
          }
          aggregate: {
            args: Prisma.GuestPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuestPlayer>
          }
          groupBy: {
            args: Prisma.GuestPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuestPlayerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GuestPlayerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GuestPlayerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GuestPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<GuestPlayerCountAggregateOutputType> | number
          }
        }
      }
      TeamInvitation: {
        payload: Prisma.$TeamInvitationPayload<ExtArgs>
        fields: Prisma.TeamInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload>
          }
          findFirst: {
            args: Prisma.TeamInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload>
          }
          findMany: {
            args: Prisma.TeamInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload>[]
          }
          create: {
            args: Prisma.TeamInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload>
          }
          createMany: {
            args: Prisma.TeamInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload>
          }
          update: {
            args: Prisma.TeamInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload>
          }
          deleteMany: {
            args: Prisma.TeamInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamInvitationPayload>
          }
          aggregate: {
            args: Prisma.TeamInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamInvitation>
          }
          groupBy: {
            args: Prisma.TeamInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamInvitationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamInvitationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamInvitationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<TeamInvitationCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MatchFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MatchAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      TeamMatch: {
        payload: Prisma.$TeamMatchPayload<ExtArgs>
        fields: Prisma.TeamMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload>
          }
          findFirst: {
            args: Prisma.TeamMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload>
          }
          findMany: {
            args: Prisma.TeamMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload>[]
          }
          create: {
            args: Prisma.TeamMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload>
          }
          createMany: {
            args: Prisma.TeamMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload>
          }
          update: {
            args: Prisma.TeamMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload>
          }
          deleteMany: {
            args: Prisma.TeamMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPayload>
          }
          aggregate: {
            args: Prisma.TeamMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMatch>
          }
          groupBy: {
            args: Prisma.TeamMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMatchGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamMatchFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamMatchAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamMatchCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMatchCountAggregateOutputType> | number
          }
        }
      }
      TeamMatchPlayer: {
        payload: Prisma.$TeamMatchPlayerPayload<ExtArgs>
        fields: Prisma.TeamMatchPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMatchPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMatchPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload>
          }
          findFirst: {
            args: Prisma.TeamMatchPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMatchPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload>
          }
          findMany: {
            args: Prisma.TeamMatchPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload>[]
          }
          create: {
            args: Prisma.TeamMatchPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload>
          }
          createMany: {
            args: Prisma.TeamMatchPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMatchPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload>
          }
          update: {
            args: Prisma.TeamMatchPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload>
          }
          deleteMany: {
            args: Prisma.TeamMatchPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMatchPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMatchPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMatchPlayerPayload>
          }
          aggregate: {
            args: Prisma.TeamMatchPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMatchPlayer>
          }
          groupBy: {
            args: Prisma.TeamMatchPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMatchPlayerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamMatchPlayerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamMatchPlayerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamMatchPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMatchPlayerCountAggregateOutputType> | number
          }
        }
      }
      TeamStatistics: {
        payload: Prisma.$TeamStatisticsPayload<ExtArgs>
        fields: Prisma.TeamStatisticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamStatisticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamStatisticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload>
          }
          findFirst: {
            args: Prisma.TeamStatisticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamStatisticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload>
          }
          findMany: {
            args: Prisma.TeamStatisticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload>[]
          }
          create: {
            args: Prisma.TeamStatisticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload>
          }
          createMany: {
            args: Prisma.TeamStatisticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamStatisticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload>
          }
          update: {
            args: Prisma.TeamStatisticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload>
          }
          deleteMany: {
            args: Prisma.TeamStatisticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamStatisticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamStatisticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamStatisticsPayload>
          }
          aggregate: {
            args: Prisma.TeamStatisticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamStatistics>
          }
          groupBy: {
            args: Prisma.TeamStatisticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamStatisticsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamStatisticsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamStatisticsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TeamStatisticsCountArgs<ExtArgs>
            result: $Utils.Optional<TeamStatisticsCountAggregateOutputType> | number
          }
        }
      }
      LocalMatch: {
        payload: Prisma.$LocalMatchPayload<ExtArgs>
        fields: Prisma.LocalMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload>
          }
          findFirst: {
            args: Prisma.LocalMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload>
          }
          findMany: {
            args: Prisma.LocalMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload>[]
          }
          create: {
            args: Prisma.LocalMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload>
          }
          createMany: {
            args: Prisma.LocalMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocalMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload>
          }
          update: {
            args: Prisma.LocalMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload>
          }
          deleteMany: {
            args: Prisma.LocalMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocalMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalMatchPayload>
          }
          aggregate: {
            args: Prisma.LocalMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalMatch>
          }
          groupBy: {
            args: Prisma.LocalMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalMatchGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LocalMatchFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LocalMatchAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LocalMatchCountArgs<ExtArgs>
            result: $Utils.Optional<LocalMatchCountAggregateOutputType> | number
          }
        }
      }
      MatchSpectator: {
        payload: Prisma.$MatchSpectatorPayload<ExtArgs>
        fields: Prisma.MatchSpectatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchSpectatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchSpectatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload>
          }
          findFirst: {
            args: Prisma.MatchSpectatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchSpectatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload>
          }
          findMany: {
            args: Prisma.MatchSpectatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload>[]
          }
          create: {
            args: Prisma.MatchSpectatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload>
          }
          createMany: {
            args: Prisma.MatchSpectatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MatchSpectatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload>
          }
          update: {
            args: Prisma.MatchSpectatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload>
          }
          deleteMany: {
            args: Prisma.MatchSpectatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchSpectatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchSpectatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSpectatorPayload>
          }
          aggregate: {
            args: Prisma.MatchSpectatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchSpectator>
          }
          groupBy: {
            args: Prisma.MatchSpectatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchSpectatorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MatchSpectatorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MatchSpectatorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MatchSpectatorCountArgs<ExtArgs>
            result: $Utils.Optional<MatchSpectatorCountAggregateOutputType> | number
          }
        }
      }
      OverHistory: {
        payload: Prisma.$OverHistoryPayload<ExtArgs>
        fields: Prisma.OverHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OverHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OverHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload>
          }
          findFirst: {
            args: Prisma.OverHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OverHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload>
          }
          findMany: {
            args: Prisma.OverHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload>[]
          }
          create: {
            args: Prisma.OverHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload>
          }
          createMany: {
            args: Prisma.OverHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OverHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload>
          }
          update: {
            args: Prisma.OverHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload>
          }
          deleteMany: {
            args: Prisma.OverHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OverHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OverHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OverHistoryPayload>
          }
          aggregate: {
            args: Prisma.OverHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOverHistory>
          }
          groupBy: {
            args: Prisma.OverHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<OverHistoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OverHistoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OverHistoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OverHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<OverHistoryCountAggregateOutputType> | number
          }
        }
      }
      MatchSummary: {
        payload: Prisma.$MatchSummaryPayload<ExtArgs>
        fields: Prisma.MatchSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload>
          }
          findFirst: {
            args: Prisma.MatchSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload>
          }
          findMany: {
            args: Prisma.MatchSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload>[]
          }
          create: {
            args: Prisma.MatchSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload>
          }
          createMany: {
            args: Prisma.MatchSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MatchSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload>
          }
          update: {
            args: Prisma.MatchSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload>
          }
          deleteMany: {
            args: Prisma.MatchSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchSummaryPayload>
          }
          aggregate: {
            args: Prisma.MatchSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchSummary>
          }
          groupBy: {
            args: Prisma.MatchSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchSummaryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MatchSummaryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MatchSummaryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MatchSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<MatchSummaryCountAggregateOutputType> | number
          }
        }
      }
      PlayerMatchHistory: {
        payload: Prisma.$PlayerMatchHistoryPayload<ExtArgs>
        fields: Prisma.PlayerMatchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerMatchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerMatchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload>
          }
          findFirst: {
            args: Prisma.PlayerMatchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerMatchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload>
          }
          findMany: {
            args: Prisma.PlayerMatchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload>[]
          }
          create: {
            args: Prisma.PlayerMatchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload>
          }
          createMany: {
            args: Prisma.PlayerMatchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlayerMatchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload>
          }
          update: {
            args: Prisma.PlayerMatchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PlayerMatchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerMatchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerMatchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMatchHistoryPayload>
          }
          aggregate: {
            args: Prisma.PlayerMatchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerMatchHistory>
          }
          groupBy: {
            args: Prisma.PlayerMatchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerMatchHistoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PlayerMatchHistoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PlayerMatchHistoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PlayerMatchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerMatchHistoryCountAggregateOutputType> | number
          }
        }
      }
      Fixture: {
        payload: Prisma.$FixturePayload<ExtArgs>
        fields: Prisma.FixtureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FixtureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FixtureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload>
          }
          findFirst: {
            args: Prisma.FixtureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FixtureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload>
          }
          findMany: {
            args: Prisma.FixtureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload>[]
          }
          create: {
            args: Prisma.FixtureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload>
          }
          createMany: {
            args: Prisma.FixtureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FixtureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload>
          }
          update: {
            args: Prisma.FixtureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload>
          }
          deleteMany: {
            args: Prisma.FixtureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FixtureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FixtureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FixturePayload>
          }
          aggregate: {
            args: Prisma.FixtureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFixture>
          }
          groupBy: {
            args: Prisma.FixtureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FixtureGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FixtureFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FixtureAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FixtureCountArgs<ExtArgs>
            result: $Utils.Optional<FixtureCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    careerStats?: CareerStatsOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    guestPlayer?: GuestPlayerOmit
    teamInvitation?: TeamInvitationOmit
    match?: MatchOmit
    teamMatch?: TeamMatchOmit
    teamMatchPlayer?: TeamMatchPlayerOmit
    teamStatistics?: TeamStatisticsOmit
    localMatch?: LocalMatchOmit
    matchSpectator?: MatchSpectatorOmit
    overHistory?: OverHistoryOmit
    matchSummary?: MatchSummaryOmit
    playerMatchHistory?: PlayerMatchHistoryOmit
    fixture?: FixtureOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdTeams: number
    captainOfTeams: number
    viceCaptainOfTeams: number
    teamMemberships: number
    sentInvitations: number
    receivedInvitations: number
    guestPlayersAdded: number
    guestPlayersLinked: number
    matches: number
    teamMatchStats: number
    topRunScorerFor: number
    topWicketTakerFor: number
    bestStrikeRateFor: number
    bestEconomyFor: number
    mostManOfTheMatchFor: number
    createdLocalMatches: number
    spectatorOf: number
    addedSpectators: number
    matchSummariesAsManOfTheMatch: number
    playerMatchHistory: number
    fixtures: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdTeams?: boolean | UserCountOutputTypeCountCreatedTeamsArgs
    captainOfTeams?: boolean | UserCountOutputTypeCountCaptainOfTeamsArgs
    viceCaptainOfTeams?: boolean | UserCountOutputTypeCountViceCaptainOfTeamsArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    sentInvitations?: boolean | UserCountOutputTypeCountSentInvitationsArgs
    receivedInvitations?: boolean | UserCountOutputTypeCountReceivedInvitationsArgs
    guestPlayersAdded?: boolean | UserCountOutputTypeCountGuestPlayersAddedArgs
    guestPlayersLinked?: boolean | UserCountOutputTypeCountGuestPlayersLinkedArgs
    matches?: boolean | UserCountOutputTypeCountMatchesArgs
    teamMatchStats?: boolean | UserCountOutputTypeCountTeamMatchStatsArgs
    topRunScorerFor?: boolean | UserCountOutputTypeCountTopRunScorerForArgs
    topWicketTakerFor?: boolean | UserCountOutputTypeCountTopWicketTakerForArgs
    bestStrikeRateFor?: boolean | UserCountOutputTypeCountBestStrikeRateForArgs
    bestEconomyFor?: boolean | UserCountOutputTypeCountBestEconomyForArgs
    mostManOfTheMatchFor?: boolean | UserCountOutputTypeCountMostManOfTheMatchForArgs
    createdLocalMatches?: boolean | UserCountOutputTypeCountCreatedLocalMatchesArgs
    spectatorOf?: boolean | UserCountOutputTypeCountSpectatorOfArgs
    addedSpectators?: boolean | UserCountOutputTypeCountAddedSpectatorsArgs
    matchSummariesAsManOfTheMatch?: boolean | UserCountOutputTypeCountMatchSummariesAsManOfTheMatchArgs
    playerMatchHistory?: boolean | UserCountOutputTypeCountPlayerMatchHistoryArgs
    fixtures?: boolean | UserCountOutputTypeCountFixturesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCaptainOfTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViceCaptainOfTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGuestPlayersAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestPlayerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGuestPlayersLinkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestPlayerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMatchStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMatchPlayerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopRunScorerForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamStatisticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopWicketTakerForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamStatisticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBestStrikeRateForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamStatisticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBestEconomyForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamStatisticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMostManOfTheMatchForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamStatisticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedLocalMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalMatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpectatorOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSpectatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddedSpectatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSpectatorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchSummariesAsManOfTheMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSummaryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlayerMatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMatchHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFixturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixtureWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    guestPlayers: number
    invitations: number
    homeMatches: number
    awayMatches: number
    teamMatchStats: number
    localMatchesAsMyTeam: number
    localMatchesAsOpponent: number
    matchSummariesAsHome: number
    matchSummariesAsAway: number
    playerMatchHistory: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    guestPlayers?: boolean | TeamCountOutputTypeCountGuestPlayersArgs
    invitations?: boolean | TeamCountOutputTypeCountInvitationsArgs
    homeMatches?: boolean | TeamCountOutputTypeCountHomeMatchesArgs
    awayMatches?: boolean | TeamCountOutputTypeCountAwayMatchesArgs
    teamMatchStats?: boolean | TeamCountOutputTypeCountTeamMatchStatsArgs
    localMatchesAsMyTeam?: boolean | TeamCountOutputTypeCountLocalMatchesAsMyTeamArgs
    localMatchesAsOpponent?: boolean | TeamCountOutputTypeCountLocalMatchesAsOpponentArgs
    matchSummariesAsHome?: boolean | TeamCountOutputTypeCountMatchSummariesAsHomeArgs
    matchSummariesAsAway?: boolean | TeamCountOutputTypeCountMatchSummariesAsAwayArgs
    playerMatchHistory?: boolean | TeamCountOutputTypeCountPlayerMatchHistoryArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountGuestPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestPlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInvitationWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountHomeMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMatchWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAwayMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMatchWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamMatchStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMatchPlayerWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLocalMatchesAsMyTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalMatchWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLocalMatchesAsOpponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalMatchWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMatchSummariesAsHomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSummaryWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMatchSummariesAsAwayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSummaryWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPlayerMatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMatchHistoryWhereInput
  }


  /**
   * Count Type TeamMatchCountOutputType
   */

  export type TeamMatchCountOutputType = {
    playerStats: number
  }

  export type TeamMatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerStats?: boolean | TeamMatchCountOutputTypeCountPlayerStatsArgs
  }

  // Custom InputTypes
  /**
   * TeamMatchCountOutputType without action
   */
  export type TeamMatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchCountOutputType
     */
    select?: TeamMatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamMatchCountOutputType without action
   */
  export type TeamMatchCountOutputTypeCountPlayerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMatchPlayerWhereInput
  }


  /**
   * Count Type LocalMatchCountOutputType
   */

  export type LocalMatchCountOutputType = {
    spectators: number
    overHistory: number
  }

  export type LocalMatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    spectators?: boolean | LocalMatchCountOutputTypeCountSpectatorsArgs
    overHistory?: boolean | LocalMatchCountOutputTypeCountOverHistoryArgs
  }

  // Custom InputTypes
  /**
   * LocalMatchCountOutputType without action
   */
  export type LocalMatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatchCountOutputType
     */
    select?: LocalMatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalMatchCountOutputType without action
   */
  export type LocalMatchCountOutputTypeCountSpectatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSpectatorWhereInput
  }

  /**
   * LocalMatchCountOutputType without action
   */
  export type LocalMatchCountOutputTypeCountOverHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OverHistoryWhereInput
  }


  /**
   * Count Type MatchSummaryCountOutputType
   */

  export type MatchSummaryCountOutputType = {
    playerHistory: number
  }

  export type MatchSummaryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerHistory?: boolean | MatchSummaryCountOutputTypeCountPlayerHistoryArgs
  }

  // Custom InputTypes
  /**
   * MatchSummaryCountOutputType without action
   */
  export type MatchSummaryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummaryCountOutputType
     */
    select?: MatchSummaryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchSummaryCountOutputType without action
   */
  export type MatchSummaryCountOutputTypeCountPlayerHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMatchHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    profileName: string | null
    description: string | null
    profilePictureUrl: string | null
    role: $Enums.Role | null
    battingHand: $Enums.BattingHand | null
    bowlingStyle: $Enums.BowlingStyle | null
    profileComplete: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    username: string | null
    profileName: string | null
    description: string | null
    profilePictureUrl: string | null
    role: $Enums.Role | null
    battingHand: $Enums.BattingHand | null
    bowlingStyle: $Enums.BowlingStyle | null
    profileComplete: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    profileName: number
    description: number
    profilePictureUrl: number
    role: number
    battingHand: number
    bowlingStyle: number
    profileComplete: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    profileName?: true
    description?: true
    profilePictureUrl?: true
    role?: true
    battingHand?: true
    bowlingStyle?: true
    profileComplete?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    profileName?: true
    description?: true
    profilePictureUrl?: true
    role?: true
    battingHand?: true
    bowlingStyle?: true
    profileComplete?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    profileName?: true
    description?: true
    profilePictureUrl?: true
    role?: true
    battingHand?: true
    bowlingStyle?: true
    profileComplete?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    username: string | null
    profileName: string | null
    description: string | null
    profilePictureUrl: string | null
    role: $Enums.Role | null
    battingHand: $Enums.BattingHand | null
    bowlingStyle: $Enums.BowlingStyle | null
    profileComplete: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    profileName?: boolean
    description?: boolean
    profilePictureUrl?: boolean
    role?: boolean
    battingHand?: boolean
    bowlingStyle?: boolean
    profileComplete?: boolean
    createdAt?: boolean
    careerStats?: boolean | User$careerStatsArgs<ExtArgs>
    createdTeams?: boolean | User$createdTeamsArgs<ExtArgs>
    captainOfTeams?: boolean | User$captainOfTeamsArgs<ExtArgs>
    viceCaptainOfTeams?: boolean | User$viceCaptainOfTeamsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    guestPlayersAdded?: boolean | User$guestPlayersAddedArgs<ExtArgs>
    guestPlayersLinked?: boolean | User$guestPlayersLinkedArgs<ExtArgs>
    matches?: boolean | User$matchesArgs<ExtArgs>
    teamMatchStats?: boolean | User$teamMatchStatsArgs<ExtArgs>
    topRunScorerFor?: boolean | User$topRunScorerForArgs<ExtArgs>
    topWicketTakerFor?: boolean | User$topWicketTakerForArgs<ExtArgs>
    bestStrikeRateFor?: boolean | User$bestStrikeRateForArgs<ExtArgs>
    bestEconomyFor?: boolean | User$bestEconomyForArgs<ExtArgs>
    mostManOfTheMatchFor?: boolean | User$mostManOfTheMatchForArgs<ExtArgs>
    createdLocalMatches?: boolean | User$createdLocalMatchesArgs<ExtArgs>
    spectatorOf?: boolean | User$spectatorOfArgs<ExtArgs>
    addedSpectators?: boolean | User$addedSpectatorsArgs<ExtArgs>
    matchSummariesAsManOfTheMatch?: boolean | User$matchSummariesAsManOfTheMatchArgs<ExtArgs>
    playerMatchHistory?: boolean | User$playerMatchHistoryArgs<ExtArgs>
    fixtures?: boolean | User$fixturesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    profileName?: boolean
    description?: boolean
    profilePictureUrl?: boolean
    role?: boolean
    battingHand?: boolean
    bowlingStyle?: boolean
    profileComplete?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "username" | "profileName" | "description" | "profilePictureUrl" | "role" | "battingHand" | "bowlingStyle" | "profileComplete" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerStats?: boolean | User$careerStatsArgs<ExtArgs>
    createdTeams?: boolean | User$createdTeamsArgs<ExtArgs>
    captainOfTeams?: boolean | User$captainOfTeamsArgs<ExtArgs>
    viceCaptainOfTeams?: boolean | User$viceCaptainOfTeamsArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    sentInvitations?: boolean | User$sentInvitationsArgs<ExtArgs>
    receivedInvitations?: boolean | User$receivedInvitationsArgs<ExtArgs>
    guestPlayersAdded?: boolean | User$guestPlayersAddedArgs<ExtArgs>
    guestPlayersLinked?: boolean | User$guestPlayersLinkedArgs<ExtArgs>
    matches?: boolean | User$matchesArgs<ExtArgs>
    teamMatchStats?: boolean | User$teamMatchStatsArgs<ExtArgs>
    topRunScorerFor?: boolean | User$topRunScorerForArgs<ExtArgs>
    topWicketTakerFor?: boolean | User$topWicketTakerForArgs<ExtArgs>
    bestStrikeRateFor?: boolean | User$bestStrikeRateForArgs<ExtArgs>
    bestEconomyFor?: boolean | User$bestEconomyForArgs<ExtArgs>
    mostManOfTheMatchFor?: boolean | User$mostManOfTheMatchForArgs<ExtArgs>
    createdLocalMatches?: boolean | User$createdLocalMatchesArgs<ExtArgs>
    spectatorOf?: boolean | User$spectatorOfArgs<ExtArgs>
    addedSpectators?: boolean | User$addedSpectatorsArgs<ExtArgs>
    matchSummariesAsManOfTheMatch?: boolean | User$matchSummariesAsManOfTheMatchArgs<ExtArgs>
    playerMatchHistory?: boolean | User$playerMatchHistoryArgs<ExtArgs>
    fixtures?: boolean | User$fixturesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      careerStats: Prisma.$CareerStatsPayload<ExtArgs> | null
      createdTeams: Prisma.$TeamPayload<ExtArgs>[]
      captainOfTeams: Prisma.$TeamPayload<ExtArgs>[]
      viceCaptainOfTeams: Prisma.$TeamPayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      sentInvitations: Prisma.$TeamInvitationPayload<ExtArgs>[]
      receivedInvitations: Prisma.$TeamInvitationPayload<ExtArgs>[]
      guestPlayersAdded: Prisma.$GuestPlayerPayload<ExtArgs>[]
      guestPlayersLinked: Prisma.$GuestPlayerPayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
      teamMatchStats: Prisma.$TeamMatchPlayerPayload<ExtArgs>[]
      topRunScorerFor: Prisma.$TeamStatisticsPayload<ExtArgs>[]
      topWicketTakerFor: Prisma.$TeamStatisticsPayload<ExtArgs>[]
      bestStrikeRateFor: Prisma.$TeamStatisticsPayload<ExtArgs>[]
      bestEconomyFor: Prisma.$TeamStatisticsPayload<ExtArgs>[]
      mostManOfTheMatchFor: Prisma.$TeamStatisticsPayload<ExtArgs>[]
      createdLocalMatches: Prisma.$LocalMatchPayload<ExtArgs>[]
      spectatorOf: Prisma.$MatchSpectatorPayload<ExtArgs>[]
      addedSpectators: Prisma.$MatchSpectatorPayload<ExtArgs>[]
      matchSummariesAsManOfTheMatch: Prisma.$MatchSummaryPayload<ExtArgs>[]
      playerMatchHistory: Prisma.$PlayerMatchHistoryPayload<ExtArgs>[]
      fixtures: Prisma.$FixturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      username: string | null
      profileName: string | null
      description: string | null
      profilePictureUrl: string | null
      role: $Enums.Role | null
      battingHand: $Enums.BattingHand | null
      bowlingStyle: $Enums.BowlingStyle | null
      profileComplete: boolean
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    careerStats<T extends User$careerStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$careerStatsArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdTeams<T extends User$createdTeamsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    captainOfTeams<T extends User$captainOfTeamsArgs<ExtArgs> = {}>(args?: Subset<T, User$captainOfTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viceCaptainOfTeams<T extends User$viceCaptainOfTeamsArgs<ExtArgs> = {}>(args?: Subset<T, User$viceCaptainOfTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentInvitations<T extends User$sentInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedInvitations<T extends User$receivedInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guestPlayersAdded<T extends User$guestPlayersAddedArgs<ExtArgs> = {}>(args?: Subset<T, User$guestPlayersAddedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guestPlayersLinked<T extends User$guestPlayersLinkedArgs<ExtArgs> = {}>(args?: Subset<T, User$guestPlayersLinkedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matches<T extends User$matchesArgs<ExtArgs> = {}>(args?: Subset<T, User$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamMatchStats<T extends User$teamMatchStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMatchStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topRunScorerFor<T extends User$topRunScorerForArgs<ExtArgs> = {}>(args?: Subset<T, User$topRunScorerForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topWicketTakerFor<T extends User$topWicketTakerForArgs<ExtArgs> = {}>(args?: Subset<T, User$topWicketTakerForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bestStrikeRateFor<T extends User$bestStrikeRateForArgs<ExtArgs> = {}>(args?: Subset<T, User$bestStrikeRateForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bestEconomyFor<T extends User$bestEconomyForArgs<ExtArgs> = {}>(args?: Subset<T, User$bestEconomyForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mostManOfTheMatchFor<T extends User$mostManOfTheMatchForArgs<ExtArgs> = {}>(args?: Subset<T, User$mostManOfTheMatchForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdLocalMatches<T extends User$createdLocalMatchesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdLocalMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spectatorOf<T extends User$spectatorOfArgs<ExtArgs> = {}>(args?: Subset<T, User$spectatorOfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addedSpectators<T extends User$addedSpectatorsArgs<ExtArgs> = {}>(args?: Subset<T, User$addedSpectatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchSummariesAsManOfTheMatch<T extends User$matchSummariesAsManOfTheMatchArgs<ExtArgs> = {}>(args?: Subset<T, User$matchSummariesAsManOfTheMatchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerMatchHistory<T extends User$playerMatchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$playerMatchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fixtures<T extends User$fixturesArgs<ExtArgs> = {}>(args?: Subset<T, User$fixturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly profileName: FieldRef<"User", 'String'>
    readonly description: FieldRef<"User", 'String'>
    readonly profilePictureUrl: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly battingHand: FieldRef<"User", 'BattingHand'>
    readonly bowlingStyle: FieldRef<"User", 'BowlingStyle'>
    readonly profileComplete: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.careerStats
   */
  export type User$careerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    where?: CareerStatsWhereInput
  }

  /**
   * User.createdTeams
   */
  export type User$createdTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.captainOfTeams
   */
  export type User$captainOfTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.viceCaptainOfTeams
   */
  export type User$viceCaptainOfTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.sentInvitations
   */
  export type User$sentInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    where?: TeamInvitationWhereInput
    orderBy?: TeamInvitationOrderByWithRelationInput | TeamInvitationOrderByWithRelationInput[]
    cursor?: TeamInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamInvitationScalarFieldEnum | TeamInvitationScalarFieldEnum[]
  }

  /**
   * User.receivedInvitations
   */
  export type User$receivedInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    where?: TeamInvitationWhereInput
    orderBy?: TeamInvitationOrderByWithRelationInput | TeamInvitationOrderByWithRelationInput[]
    cursor?: TeamInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamInvitationScalarFieldEnum | TeamInvitationScalarFieldEnum[]
  }

  /**
   * User.guestPlayersAdded
   */
  export type User$guestPlayersAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    where?: GuestPlayerWhereInput
    orderBy?: GuestPlayerOrderByWithRelationInput | GuestPlayerOrderByWithRelationInput[]
    cursor?: GuestPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuestPlayerScalarFieldEnum | GuestPlayerScalarFieldEnum[]
  }

  /**
   * User.guestPlayersLinked
   */
  export type User$guestPlayersLinkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    where?: GuestPlayerWhereInput
    orderBy?: GuestPlayerOrderByWithRelationInput | GuestPlayerOrderByWithRelationInput[]
    cursor?: GuestPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuestPlayerScalarFieldEnum | GuestPlayerScalarFieldEnum[]
  }

  /**
   * User.matches
   */
  export type User$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.teamMatchStats
   */
  export type User$teamMatchStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    where?: TeamMatchPlayerWhereInput
    orderBy?: TeamMatchPlayerOrderByWithRelationInput | TeamMatchPlayerOrderByWithRelationInput[]
    cursor?: TeamMatchPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMatchPlayerScalarFieldEnum | TeamMatchPlayerScalarFieldEnum[]
  }

  /**
   * User.topRunScorerFor
   */
  export type User$topRunScorerForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    where?: TeamStatisticsWhereInput
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    cursor?: TeamStatisticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * User.topWicketTakerFor
   */
  export type User$topWicketTakerForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    where?: TeamStatisticsWhereInput
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    cursor?: TeamStatisticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * User.bestStrikeRateFor
   */
  export type User$bestStrikeRateForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    where?: TeamStatisticsWhereInput
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    cursor?: TeamStatisticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * User.bestEconomyFor
   */
  export type User$bestEconomyForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    where?: TeamStatisticsWhereInput
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    cursor?: TeamStatisticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * User.mostManOfTheMatchFor
   */
  export type User$mostManOfTheMatchForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    where?: TeamStatisticsWhereInput
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    cursor?: TeamStatisticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * User.createdLocalMatches
   */
  export type User$createdLocalMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    where?: LocalMatchWhereInput
    orderBy?: LocalMatchOrderByWithRelationInput | LocalMatchOrderByWithRelationInput[]
    cursor?: LocalMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalMatchScalarFieldEnum | LocalMatchScalarFieldEnum[]
  }

  /**
   * User.spectatorOf
   */
  export type User$spectatorOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    where?: MatchSpectatorWhereInput
    orderBy?: MatchSpectatorOrderByWithRelationInput | MatchSpectatorOrderByWithRelationInput[]
    cursor?: MatchSpectatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchSpectatorScalarFieldEnum | MatchSpectatorScalarFieldEnum[]
  }

  /**
   * User.addedSpectators
   */
  export type User$addedSpectatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    where?: MatchSpectatorWhereInput
    orderBy?: MatchSpectatorOrderByWithRelationInput | MatchSpectatorOrderByWithRelationInput[]
    cursor?: MatchSpectatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchSpectatorScalarFieldEnum | MatchSpectatorScalarFieldEnum[]
  }

  /**
   * User.matchSummariesAsManOfTheMatch
   */
  export type User$matchSummariesAsManOfTheMatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    where?: MatchSummaryWhereInput
    orderBy?: MatchSummaryOrderByWithRelationInput | MatchSummaryOrderByWithRelationInput[]
    cursor?: MatchSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchSummaryScalarFieldEnum | MatchSummaryScalarFieldEnum[]
  }

  /**
   * User.playerMatchHistory
   */
  export type User$playerMatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    where?: PlayerMatchHistoryWhereInput
    orderBy?: PlayerMatchHistoryOrderByWithRelationInput | PlayerMatchHistoryOrderByWithRelationInput[]
    cursor?: PlayerMatchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerMatchHistoryScalarFieldEnum | PlayerMatchHistoryScalarFieldEnum[]
  }

  /**
   * User.fixtures
   */
  export type User$fixturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    where?: FixtureWhereInput
    orderBy?: FixtureOrderByWithRelationInput | FixtureOrderByWithRelationInput[]
    cursor?: FixtureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FixtureScalarFieldEnum | FixtureScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model CareerStats
   */

  export type AggregateCareerStats = {
    _count: CareerStatsCountAggregateOutputType | null
    _avg: CareerStatsAvgAggregateOutputType | null
    _sum: CareerStatsSumAggregateOutputType | null
    _min: CareerStatsMinAggregateOutputType | null
    _max: CareerStatsMaxAggregateOutputType | null
  }

  export type CareerStatsAvgAggregateOutputType = {
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    strikeRate: number | null
    highestScore: number | null
    timesOut: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    economy: number | null
    bestBowlingWickets: number | null
    bestBowlingRuns: number | null
    catchesTaken: number | null
    runOuts: number | null
    manOfTheMatchAwards: number | null
  }

  export type CareerStatsSumAggregateOutputType = {
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    strikeRate: number | null
    highestScore: number | null
    timesOut: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    economy: number | null
    bestBowlingWickets: number | null
    bestBowlingRuns: number | null
    catchesTaken: number | null
    runOuts: number | null
    manOfTheMatchAwards: number | null
  }

  export type CareerStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    strikeRate: number | null
    highestScore: number | null
    timesOut: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    economy: number | null
    bestBowlingWickets: number | null
    bestBowlingRuns: number | null
    catchesTaken: number | null
    runOuts: number | null
    manOfTheMatchAwards: number | null
    updatedAt: Date | null
  }

  export type CareerStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    strikeRate: number | null
    highestScore: number | null
    timesOut: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    economy: number | null
    bestBowlingWickets: number | null
    bestBowlingRuns: number | null
    catchesTaken: number | null
    runOuts: number | null
    manOfTheMatchAwards: number | null
    updatedAt: Date | null
  }

  export type CareerStatsCountAggregateOutputType = {
    id: number
    userId: number
    matchesPlayed: number
    totalRuns: number
    ballsFaced: number
    strikeRate: number
    highestScore: number
    timesOut: number
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    economy: number
    bestBowlingWickets: number
    bestBowlingRuns: number
    catchesTaken: number
    runOuts: number
    manOfTheMatchAwards: number
    updatedAt: number
    _all: number
  }


  export type CareerStatsAvgAggregateInputType = {
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    strikeRate?: true
    highestScore?: true
    timesOut?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    economy?: true
    bestBowlingWickets?: true
    bestBowlingRuns?: true
    catchesTaken?: true
    runOuts?: true
    manOfTheMatchAwards?: true
  }

  export type CareerStatsSumAggregateInputType = {
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    strikeRate?: true
    highestScore?: true
    timesOut?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    economy?: true
    bestBowlingWickets?: true
    bestBowlingRuns?: true
    catchesTaken?: true
    runOuts?: true
    manOfTheMatchAwards?: true
  }

  export type CareerStatsMinAggregateInputType = {
    id?: true
    userId?: true
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    strikeRate?: true
    highestScore?: true
    timesOut?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    economy?: true
    bestBowlingWickets?: true
    bestBowlingRuns?: true
    catchesTaken?: true
    runOuts?: true
    manOfTheMatchAwards?: true
    updatedAt?: true
  }

  export type CareerStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    strikeRate?: true
    highestScore?: true
    timesOut?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    economy?: true
    bestBowlingWickets?: true
    bestBowlingRuns?: true
    catchesTaken?: true
    runOuts?: true
    manOfTheMatchAwards?: true
    updatedAt?: true
  }

  export type CareerStatsCountAggregateInputType = {
    id?: true
    userId?: true
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    strikeRate?: true
    highestScore?: true
    timesOut?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    economy?: true
    bestBowlingWickets?: true
    bestBowlingRuns?: true
    catchesTaken?: true
    runOuts?: true
    manOfTheMatchAwards?: true
    updatedAt?: true
    _all?: true
  }

  export type CareerStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerStats to aggregate.
     */
    where?: CareerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerStats to fetch.
     */
    orderBy?: CareerStatsOrderByWithRelationInput | CareerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CareerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CareerStats
    **/
    _count?: true | CareerStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerStatsMaxAggregateInputType
  }

  export type GetCareerStatsAggregateType<T extends CareerStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateCareerStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareerStats[P]>
      : GetScalarType<T[P], AggregateCareerStats[P]>
  }




  export type CareerStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CareerStatsWhereInput
    orderBy?: CareerStatsOrderByWithAggregationInput | CareerStatsOrderByWithAggregationInput[]
    by: CareerStatsScalarFieldEnum[] | CareerStatsScalarFieldEnum
    having?: CareerStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerStatsCountAggregateInputType | true
    _avg?: CareerStatsAvgAggregateInputType
    _sum?: CareerStatsSumAggregateInputType
    _min?: CareerStatsMinAggregateInputType
    _max?: CareerStatsMaxAggregateInputType
  }

  export type CareerStatsGroupByOutputType = {
    id: string
    userId: string
    matchesPlayed: number
    totalRuns: number
    ballsFaced: number
    strikeRate: number
    highestScore: number
    timesOut: number
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    economy: number
    bestBowlingWickets: number
    bestBowlingRuns: number
    catchesTaken: number
    runOuts: number
    manOfTheMatchAwards: number
    updatedAt: Date
    _count: CareerStatsCountAggregateOutputType | null
    _avg: CareerStatsAvgAggregateOutputType | null
    _sum: CareerStatsSumAggregateOutputType | null
    _min: CareerStatsMinAggregateOutputType | null
    _max: CareerStatsMaxAggregateOutputType | null
  }

  type GetCareerStatsGroupByPayload<T extends CareerStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerStatsGroupByOutputType[P]>
            : GetScalarType<T[P], CareerStatsGroupByOutputType[P]>
        }
      >
    >


  export type CareerStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matchesPlayed?: boolean
    totalRuns?: boolean
    ballsFaced?: boolean
    strikeRate?: boolean
    highestScore?: boolean
    timesOut?: boolean
    oversBowled?: boolean
    runsConceded?: boolean
    wicketsTaken?: boolean
    economy?: boolean
    bestBowlingWickets?: boolean
    bestBowlingRuns?: boolean
    catchesTaken?: boolean
    runOuts?: boolean
    manOfTheMatchAwards?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerStats"]>



  export type CareerStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    matchesPlayed?: boolean
    totalRuns?: boolean
    ballsFaced?: boolean
    strikeRate?: boolean
    highestScore?: boolean
    timesOut?: boolean
    oversBowled?: boolean
    runsConceded?: boolean
    wicketsTaken?: boolean
    economy?: boolean
    bestBowlingWickets?: boolean
    bestBowlingRuns?: boolean
    catchesTaken?: boolean
    runOuts?: boolean
    manOfTheMatchAwards?: boolean
    updatedAt?: boolean
  }

  export type CareerStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "matchesPlayed" | "totalRuns" | "ballsFaced" | "strikeRate" | "highestScore" | "timesOut" | "oversBowled" | "runsConceded" | "wicketsTaken" | "economy" | "bestBowlingWickets" | "bestBowlingRuns" | "catchesTaken" | "runOuts" | "manOfTheMatchAwards" | "updatedAt", ExtArgs["result"]["careerStats"]>
  export type CareerStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CareerStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CareerStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      matchesPlayed: number
      totalRuns: number
      ballsFaced: number
      strikeRate: number
      highestScore: number
      timesOut: number
      oversBowled: number
      runsConceded: number
      wicketsTaken: number
      economy: number
      bestBowlingWickets: number
      bestBowlingRuns: number
      catchesTaken: number
      runOuts: number
      manOfTheMatchAwards: number
      updatedAt: Date
    }, ExtArgs["result"]["careerStats"]>
    composites: {}
  }

  type CareerStatsGetPayload<S extends boolean | null | undefined | CareerStatsDefaultArgs> = $Result.GetResult<Prisma.$CareerStatsPayload, S>

  type CareerStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CareerStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CareerStatsCountAggregateInputType | true
    }

  export interface CareerStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CareerStats'], meta: { name: 'CareerStats' } }
    /**
     * Find zero or one CareerStats that matches the filter.
     * @param {CareerStatsFindUniqueArgs} args - Arguments to find a CareerStats
     * @example
     * // Get one CareerStats
     * const careerStats = await prisma.careerStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CareerStatsFindUniqueArgs>(args: SelectSubset<T, CareerStatsFindUniqueArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CareerStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CareerStatsFindUniqueOrThrowArgs} args - Arguments to find a CareerStats
     * @example
     * // Get one CareerStats
     * const careerStats = await prisma.careerStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CareerStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, CareerStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerStatsFindFirstArgs} args - Arguments to find a CareerStats
     * @example
     * // Get one CareerStats
     * const careerStats = await prisma.careerStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CareerStatsFindFirstArgs>(args?: SelectSubset<T, CareerStatsFindFirstArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerStatsFindFirstOrThrowArgs} args - Arguments to find a CareerStats
     * @example
     * // Get one CareerStats
     * const careerStats = await prisma.careerStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CareerStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, CareerStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CareerStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareerStats
     * const careerStats = await prisma.careerStats.findMany()
     * 
     * // Get first 10 CareerStats
     * const careerStats = await prisma.careerStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerStatsWithIdOnly = await prisma.careerStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CareerStatsFindManyArgs>(args?: SelectSubset<T, CareerStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CareerStats.
     * @param {CareerStatsCreateArgs} args - Arguments to create a CareerStats.
     * @example
     * // Create one CareerStats
     * const CareerStats = await prisma.careerStats.create({
     *   data: {
     *     // ... data to create a CareerStats
     *   }
     * })
     * 
     */
    create<T extends CareerStatsCreateArgs>(args: SelectSubset<T, CareerStatsCreateArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CareerStats.
     * @param {CareerStatsCreateManyArgs} args - Arguments to create many CareerStats.
     * @example
     * // Create many CareerStats
     * const careerStats = await prisma.careerStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CareerStatsCreateManyArgs>(args?: SelectSubset<T, CareerStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CareerStats.
     * @param {CareerStatsDeleteArgs} args - Arguments to delete one CareerStats.
     * @example
     * // Delete one CareerStats
     * const CareerStats = await prisma.careerStats.delete({
     *   where: {
     *     // ... filter to delete one CareerStats
     *   }
     * })
     * 
     */
    delete<T extends CareerStatsDeleteArgs>(args: SelectSubset<T, CareerStatsDeleteArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CareerStats.
     * @param {CareerStatsUpdateArgs} args - Arguments to update one CareerStats.
     * @example
     * // Update one CareerStats
     * const careerStats = await prisma.careerStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CareerStatsUpdateArgs>(args: SelectSubset<T, CareerStatsUpdateArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CareerStats.
     * @param {CareerStatsDeleteManyArgs} args - Arguments to filter CareerStats to delete.
     * @example
     * // Delete a few CareerStats
     * const { count } = await prisma.careerStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CareerStatsDeleteManyArgs>(args?: SelectSubset<T, CareerStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareerStats
     * const careerStats = await prisma.careerStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CareerStatsUpdateManyArgs>(args: SelectSubset<T, CareerStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CareerStats.
     * @param {CareerStatsUpsertArgs} args - Arguments to update or create a CareerStats.
     * @example
     * // Update or create a CareerStats
     * const careerStats = await prisma.careerStats.upsert({
     *   create: {
     *     // ... data to create a CareerStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareerStats we want to update
     *   }
     * })
     */
    upsert<T extends CareerStatsUpsertArgs>(args: SelectSubset<T, CareerStatsUpsertArgs<ExtArgs>>): Prisma__CareerStatsClient<$Result.GetResult<Prisma.$CareerStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CareerStats that matches the filter.
     * @param {CareerStatsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const careerStats = await prisma.careerStats.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CareerStatsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CareerStats.
     * @param {CareerStatsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const careerStats = await prisma.careerStats.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CareerStatsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CareerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerStatsCountArgs} args - Arguments to filter CareerStats to count.
     * @example
     * // Count the number of CareerStats
     * const count = await prisma.careerStats.count({
     *   where: {
     *     // ... the filter for the CareerStats we want to count
     *   }
     * })
    **/
    count<T extends CareerStatsCountArgs>(
      args?: Subset<T, CareerStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerStatsAggregateArgs>(args: Subset<T, CareerStatsAggregateArgs>): Prisma.PrismaPromise<GetCareerStatsAggregateType<T>>

    /**
     * Group by CareerStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CareerStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CareerStatsGroupByArgs['orderBy'] }
        : { orderBy?: CareerStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CareerStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CareerStats model
   */
  readonly fields: CareerStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CareerStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CareerStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CareerStats model
   */
  interface CareerStatsFieldRefs {
    readonly id: FieldRef<"CareerStats", 'String'>
    readonly userId: FieldRef<"CareerStats", 'String'>
    readonly matchesPlayed: FieldRef<"CareerStats", 'Int'>
    readonly totalRuns: FieldRef<"CareerStats", 'Int'>
    readonly ballsFaced: FieldRef<"CareerStats", 'Int'>
    readonly strikeRate: FieldRef<"CareerStats", 'Float'>
    readonly highestScore: FieldRef<"CareerStats", 'Int'>
    readonly timesOut: FieldRef<"CareerStats", 'Int'>
    readonly oversBowled: FieldRef<"CareerStats", 'Float'>
    readonly runsConceded: FieldRef<"CareerStats", 'Int'>
    readonly wicketsTaken: FieldRef<"CareerStats", 'Int'>
    readonly economy: FieldRef<"CareerStats", 'Float'>
    readonly bestBowlingWickets: FieldRef<"CareerStats", 'Int'>
    readonly bestBowlingRuns: FieldRef<"CareerStats", 'Int'>
    readonly catchesTaken: FieldRef<"CareerStats", 'Int'>
    readonly runOuts: FieldRef<"CareerStats", 'Int'>
    readonly manOfTheMatchAwards: FieldRef<"CareerStats", 'Int'>
    readonly updatedAt: FieldRef<"CareerStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CareerStats findUnique
   */
  export type CareerStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * Filter, which CareerStats to fetch.
     */
    where: CareerStatsWhereUniqueInput
  }

  /**
   * CareerStats findUniqueOrThrow
   */
  export type CareerStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * Filter, which CareerStats to fetch.
     */
    where: CareerStatsWhereUniqueInput
  }

  /**
   * CareerStats findFirst
   */
  export type CareerStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * Filter, which CareerStats to fetch.
     */
    where?: CareerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerStats to fetch.
     */
    orderBy?: CareerStatsOrderByWithRelationInput | CareerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerStats.
     */
    cursor?: CareerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerStats.
     */
    distinct?: CareerStatsScalarFieldEnum | CareerStatsScalarFieldEnum[]
  }

  /**
   * CareerStats findFirstOrThrow
   */
  export type CareerStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * Filter, which CareerStats to fetch.
     */
    where?: CareerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerStats to fetch.
     */
    orderBy?: CareerStatsOrderByWithRelationInput | CareerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CareerStats.
     */
    cursor?: CareerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CareerStats.
     */
    distinct?: CareerStatsScalarFieldEnum | CareerStatsScalarFieldEnum[]
  }

  /**
   * CareerStats findMany
   */
  export type CareerStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * Filter, which CareerStats to fetch.
     */
    where?: CareerStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CareerStats to fetch.
     */
    orderBy?: CareerStatsOrderByWithRelationInput | CareerStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CareerStats.
     */
    cursor?: CareerStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CareerStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CareerStats.
     */
    skip?: number
    distinct?: CareerStatsScalarFieldEnum | CareerStatsScalarFieldEnum[]
  }

  /**
   * CareerStats create
   */
  export type CareerStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a CareerStats.
     */
    data: XOR<CareerStatsCreateInput, CareerStatsUncheckedCreateInput>
  }

  /**
   * CareerStats createMany
   */
  export type CareerStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CareerStats.
     */
    data: CareerStatsCreateManyInput | CareerStatsCreateManyInput[]
  }

  /**
   * CareerStats update
   */
  export type CareerStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a CareerStats.
     */
    data: XOR<CareerStatsUpdateInput, CareerStatsUncheckedUpdateInput>
    /**
     * Choose, which CareerStats to update.
     */
    where: CareerStatsWhereUniqueInput
  }

  /**
   * CareerStats updateMany
   */
  export type CareerStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CareerStats.
     */
    data: XOR<CareerStatsUpdateManyMutationInput, CareerStatsUncheckedUpdateManyInput>
    /**
     * Filter which CareerStats to update
     */
    where?: CareerStatsWhereInput
    /**
     * Limit how many CareerStats to update.
     */
    limit?: number
  }

  /**
   * CareerStats upsert
   */
  export type CareerStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the CareerStats to update in case it exists.
     */
    where: CareerStatsWhereUniqueInput
    /**
     * In case the CareerStats found by the `where` argument doesn't exist, create a new CareerStats with this data.
     */
    create: XOR<CareerStatsCreateInput, CareerStatsUncheckedCreateInput>
    /**
     * In case the CareerStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CareerStatsUpdateInput, CareerStatsUncheckedUpdateInput>
  }

  /**
   * CareerStats delete
   */
  export type CareerStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
    /**
     * Filter which CareerStats to delete.
     */
    where: CareerStatsWhereUniqueInput
  }

  /**
   * CareerStats deleteMany
   */
  export type CareerStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CareerStats to delete
     */
    where?: CareerStatsWhereInput
    /**
     * Limit how many CareerStats to delete.
     */
    limit?: number
  }

  /**
   * CareerStats findRaw
   */
  export type CareerStatsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CareerStats aggregateRaw
   */
  export type CareerStatsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CareerStats without action
   */
  export type CareerStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerStats
     */
    select?: CareerStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CareerStats
     */
    omit?: CareerStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CareerStatsInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    teamCode: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    createdById: string | null
    captainId: string | null
    viceCaptainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    teamCode: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    createdById: string | null
    captainId: string | null
    viceCaptainId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    teamCode: number
    name: number
    description: number
    logoUrl: number
    createdById: number
    captainId: number
    viceCaptainId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    teamCode?: true
    name?: true
    description?: true
    logoUrl?: true
    createdById?: true
    captainId?: true
    viceCaptainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    teamCode?: true
    name?: true
    description?: true
    logoUrl?: true
    createdById?: true
    captainId?: true
    viceCaptainId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    teamCode?: true
    name?: true
    description?: true
    logoUrl?: true
    createdById?: true
    captainId?: true
    viceCaptainId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    teamCode: string
    name: string
    description: string | null
    logoUrl: string | null
    createdById: string
    captainId: string | null
    viceCaptainId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamCode?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    createdById?: boolean
    captainId?: boolean
    viceCaptainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    captain?: boolean | Team$captainArgs<ExtArgs>
    viceCaptain?: boolean | Team$viceCaptainArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    guestPlayers?: boolean | Team$guestPlayersArgs<ExtArgs>
    invitations?: boolean | Team$invitationsArgs<ExtArgs>
    homeMatches?: boolean | Team$homeMatchesArgs<ExtArgs>
    awayMatches?: boolean | Team$awayMatchesArgs<ExtArgs>
    teamStats?: boolean | Team$teamStatsArgs<ExtArgs>
    teamMatchStats?: boolean | Team$teamMatchStatsArgs<ExtArgs>
    localMatchesAsMyTeam?: boolean | Team$localMatchesAsMyTeamArgs<ExtArgs>
    localMatchesAsOpponent?: boolean | Team$localMatchesAsOpponentArgs<ExtArgs>
    matchSummariesAsHome?: boolean | Team$matchSummariesAsHomeArgs<ExtArgs>
    matchSummariesAsAway?: boolean | Team$matchSummariesAsAwayArgs<ExtArgs>
    playerMatchHistory?: boolean | Team$playerMatchHistoryArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>



  export type TeamSelectScalar = {
    id?: boolean
    teamCode?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    createdById?: boolean
    captainId?: boolean
    viceCaptainId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamCode" | "name" | "description" | "logoUrl" | "createdById" | "captainId" | "viceCaptainId" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    captain?: boolean | Team$captainArgs<ExtArgs>
    viceCaptain?: boolean | Team$viceCaptainArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    guestPlayers?: boolean | Team$guestPlayersArgs<ExtArgs>
    invitations?: boolean | Team$invitationsArgs<ExtArgs>
    homeMatches?: boolean | Team$homeMatchesArgs<ExtArgs>
    awayMatches?: boolean | Team$awayMatchesArgs<ExtArgs>
    teamStats?: boolean | Team$teamStatsArgs<ExtArgs>
    teamMatchStats?: boolean | Team$teamMatchStatsArgs<ExtArgs>
    localMatchesAsMyTeam?: boolean | Team$localMatchesAsMyTeamArgs<ExtArgs>
    localMatchesAsOpponent?: boolean | Team$localMatchesAsOpponentArgs<ExtArgs>
    matchSummariesAsHome?: boolean | Team$matchSummariesAsHomeArgs<ExtArgs>
    matchSummariesAsAway?: boolean | Team$matchSummariesAsAwayArgs<ExtArgs>
    playerMatchHistory?: boolean | Team$playerMatchHistoryArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      captain: Prisma.$UserPayload<ExtArgs> | null
      viceCaptain: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      guestPlayers: Prisma.$GuestPlayerPayload<ExtArgs>[]
      invitations: Prisma.$TeamInvitationPayload<ExtArgs>[]
      homeMatches: Prisma.$TeamMatchPayload<ExtArgs>[]
      awayMatches: Prisma.$TeamMatchPayload<ExtArgs>[]
      teamStats: Prisma.$TeamStatisticsPayload<ExtArgs> | null
      teamMatchStats: Prisma.$TeamMatchPlayerPayload<ExtArgs>[]
      localMatchesAsMyTeam: Prisma.$LocalMatchPayload<ExtArgs>[]
      localMatchesAsOpponent: Prisma.$LocalMatchPayload<ExtArgs>[]
      matchSummariesAsHome: Prisma.$MatchSummaryPayload<ExtArgs>[]
      matchSummariesAsAway: Prisma.$MatchSummaryPayload<ExtArgs>[]
      playerMatchHistory: Prisma.$PlayerMatchHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamCode: string
      name: string
      description: string | null
      logoUrl: string | null
      createdById: string
      captainId: string | null
      viceCaptainId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * @param {TeamFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team = await prisma.team.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team.
     * @param {TeamAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team = await prisma.team.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    captain<T extends Team$captainArgs<ExtArgs> = {}>(args?: Subset<T, Team$captainArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    viceCaptain<T extends Team$viceCaptainArgs<ExtArgs> = {}>(args?: Subset<T, Team$viceCaptainArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guestPlayers<T extends Team$guestPlayersArgs<ExtArgs> = {}>(args?: Subset<T, Team$guestPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Team$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homeMatches<T extends Team$homeMatchesArgs<ExtArgs> = {}>(args?: Subset<T, Team$homeMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    awayMatches<T extends Team$awayMatchesArgs<ExtArgs> = {}>(args?: Subset<T, Team$awayMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamStats<T extends Team$teamStatsArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamStatsArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teamMatchStats<T extends Team$teamMatchStatsArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamMatchStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    localMatchesAsMyTeam<T extends Team$localMatchesAsMyTeamArgs<ExtArgs> = {}>(args?: Subset<T, Team$localMatchesAsMyTeamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    localMatchesAsOpponent<T extends Team$localMatchesAsOpponentArgs<ExtArgs> = {}>(args?: Subset<T, Team$localMatchesAsOpponentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchSummariesAsHome<T extends Team$matchSummariesAsHomeArgs<ExtArgs> = {}>(args?: Subset<T, Team$matchSummariesAsHomeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchSummariesAsAway<T extends Team$matchSummariesAsAwayArgs<ExtArgs> = {}>(args?: Subset<T, Team$matchSummariesAsAwayArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    playerMatchHistory<T extends Team$playerMatchHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Team$playerMatchHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly teamCode: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly logoUrl: FieldRef<"Team", 'String'>
    readonly createdById: FieldRef<"Team", 'String'>
    readonly captainId: FieldRef<"Team", 'String'>
    readonly viceCaptainId: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team findRaw
   */
  export type TeamFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Team aggregateRaw
   */
  export type TeamAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Team.captain
   */
  export type Team$captainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Team.viceCaptain
   */
  export type Team$viceCaptainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.guestPlayers
   */
  export type Team$guestPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    where?: GuestPlayerWhereInput
    orderBy?: GuestPlayerOrderByWithRelationInput | GuestPlayerOrderByWithRelationInput[]
    cursor?: GuestPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuestPlayerScalarFieldEnum | GuestPlayerScalarFieldEnum[]
  }

  /**
   * Team.invitations
   */
  export type Team$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    where?: TeamInvitationWhereInput
    orderBy?: TeamInvitationOrderByWithRelationInput | TeamInvitationOrderByWithRelationInput[]
    cursor?: TeamInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamInvitationScalarFieldEnum | TeamInvitationScalarFieldEnum[]
  }

  /**
   * Team.homeMatches
   */
  export type Team$homeMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    where?: TeamMatchWhereInput
    orderBy?: TeamMatchOrderByWithRelationInput | TeamMatchOrderByWithRelationInput[]
    cursor?: TeamMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMatchScalarFieldEnum | TeamMatchScalarFieldEnum[]
  }

  /**
   * Team.awayMatches
   */
  export type Team$awayMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    where?: TeamMatchWhereInput
    orderBy?: TeamMatchOrderByWithRelationInput | TeamMatchOrderByWithRelationInput[]
    cursor?: TeamMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMatchScalarFieldEnum | TeamMatchScalarFieldEnum[]
  }

  /**
   * Team.teamStats
   */
  export type Team$teamStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    where?: TeamStatisticsWhereInput
  }

  /**
   * Team.teamMatchStats
   */
  export type Team$teamMatchStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    where?: TeamMatchPlayerWhereInput
    orderBy?: TeamMatchPlayerOrderByWithRelationInput | TeamMatchPlayerOrderByWithRelationInput[]
    cursor?: TeamMatchPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMatchPlayerScalarFieldEnum | TeamMatchPlayerScalarFieldEnum[]
  }

  /**
   * Team.localMatchesAsMyTeam
   */
  export type Team$localMatchesAsMyTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    where?: LocalMatchWhereInput
    orderBy?: LocalMatchOrderByWithRelationInput | LocalMatchOrderByWithRelationInput[]
    cursor?: LocalMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalMatchScalarFieldEnum | LocalMatchScalarFieldEnum[]
  }

  /**
   * Team.localMatchesAsOpponent
   */
  export type Team$localMatchesAsOpponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    where?: LocalMatchWhereInput
    orderBy?: LocalMatchOrderByWithRelationInput | LocalMatchOrderByWithRelationInput[]
    cursor?: LocalMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalMatchScalarFieldEnum | LocalMatchScalarFieldEnum[]
  }

  /**
   * Team.matchSummariesAsHome
   */
  export type Team$matchSummariesAsHomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    where?: MatchSummaryWhereInput
    orderBy?: MatchSummaryOrderByWithRelationInput | MatchSummaryOrderByWithRelationInput[]
    cursor?: MatchSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchSummaryScalarFieldEnum | MatchSummaryScalarFieldEnum[]
  }

  /**
   * Team.matchSummariesAsAway
   */
  export type Team$matchSummariesAsAwayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    where?: MatchSummaryWhereInput
    orderBy?: MatchSummaryOrderByWithRelationInput | MatchSummaryOrderByWithRelationInput[]
    cursor?: MatchSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchSummaryScalarFieldEnum | MatchSummaryScalarFieldEnum[]
  }

  /**
   * Team.playerMatchHistory
   */
  export type Team$playerMatchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    where?: PlayerMatchHistoryWhereInput
    orderBy?: PlayerMatchHistoryOrderByWithRelationInput | PlayerMatchHistoryOrderByWithRelationInput[]
    cursor?: PlayerMatchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerMatchHistoryScalarFieldEnum | PlayerMatchHistoryScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    joinedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    joinedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    joinedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    joinedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    joinedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    joinedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>



  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    joinedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "joinedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      joinedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * @param {TeamMemberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamMember = await prisma.teamMember.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamMemberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamMember.
     * @param {TeamMemberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamMember = await prisma.teamMember.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamMemberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly joinedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember findRaw
   */
  export type TeamMemberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMember aggregateRaw
   */
  export type TeamMemberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model GuestPlayer
   */

  export type AggregateGuestPlayer = {
    _count: GuestPlayerCountAggregateOutputType | null
    _avg: GuestPlayerAvgAggregateOutputType | null
    _sum: GuestPlayerSumAggregateOutputType | null
    _min: GuestPlayerMinAggregateOutputType | null
    _max: GuestPlayerMaxAggregateOutputType | null
  }

  export type GuestPlayerAvgAggregateOutputType = {
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    fours: number | null
    sixes: number | null
    wicketsTaken: number | null
    runsConceded: number | null
    oversBowled: number | null
    catchesTaken: number | null
    runOuts: number | null
  }

  export type GuestPlayerSumAggregateOutputType = {
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    fours: number | null
    sixes: number | null
    wicketsTaken: number | null
    runsConceded: number | null
    oversBowled: number | null
    catchesTaken: number | null
    runOuts: number | null
  }

  export type GuestPlayerMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    name: string | null
    addedByUserId: string | null
    linkedUserId: string | null
    createdAt: Date | null
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    fours: number | null
    sixes: number | null
    wicketsTaken: number | null
    runsConceded: number | null
    oversBowled: number | null
    catchesTaken: number | null
    runOuts: number | null
  }

  export type GuestPlayerMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    name: string | null
    addedByUserId: string | null
    linkedUserId: string | null
    createdAt: Date | null
    matchesPlayed: number | null
    totalRuns: number | null
    ballsFaced: number | null
    fours: number | null
    sixes: number | null
    wicketsTaken: number | null
    runsConceded: number | null
    oversBowled: number | null
    catchesTaken: number | null
    runOuts: number | null
  }

  export type GuestPlayerCountAggregateOutputType = {
    id: number
    teamId: number
    name: number
    addedByUserId: number
    linkedUserId: number
    createdAt: number
    matchesPlayed: number
    totalRuns: number
    ballsFaced: number
    fours: number
    sixes: number
    wicketsTaken: number
    runsConceded: number
    oversBowled: number
    catchesTaken: number
    runOuts: number
    _all: number
  }


  export type GuestPlayerAvgAggregateInputType = {
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    fours?: true
    sixes?: true
    wicketsTaken?: true
    runsConceded?: true
    oversBowled?: true
    catchesTaken?: true
    runOuts?: true
  }

  export type GuestPlayerSumAggregateInputType = {
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    fours?: true
    sixes?: true
    wicketsTaken?: true
    runsConceded?: true
    oversBowled?: true
    catchesTaken?: true
    runOuts?: true
  }

  export type GuestPlayerMinAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    addedByUserId?: true
    linkedUserId?: true
    createdAt?: true
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    fours?: true
    sixes?: true
    wicketsTaken?: true
    runsConceded?: true
    oversBowled?: true
    catchesTaken?: true
    runOuts?: true
  }

  export type GuestPlayerMaxAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    addedByUserId?: true
    linkedUserId?: true
    createdAt?: true
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    fours?: true
    sixes?: true
    wicketsTaken?: true
    runsConceded?: true
    oversBowled?: true
    catchesTaken?: true
    runOuts?: true
  }

  export type GuestPlayerCountAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    addedByUserId?: true
    linkedUserId?: true
    createdAt?: true
    matchesPlayed?: true
    totalRuns?: true
    ballsFaced?: true
    fours?: true
    sixes?: true
    wicketsTaken?: true
    runsConceded?: true
    oversBowled?: true
    catchesTaken?: true
    runOuts?: true
    _all?: true
  }

  export type GuestPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuestPlayer to aggregate.
     */
    where?: GuestPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestPlayers to fetch.
     */
    orderBy?: GuestPlayerOrderByWithRelationInput | GuestPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuestPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuestPlayers
    **/
    _count?: true | GuestPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuestPlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuestPlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestPlayerMaxAggregateInputType
  }

  export type GetGuestPlayerAggregateType<T extends GuestPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateGuestPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuestPlayer[P]>
      : GetScalarType<T[P], AggregateGuestPlayer[P]>
  }




  export type GuestPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestPlayerWhereInput
    orderBy?: GuestPlayerOrderByWithAggregationInput | GuestPlayerOrderByWithAggregationInput[]
    by: GuestPlayerScalarFieldEnum[] | GuestPlayerScalarFieldEnum
    having?: GuestPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestPlayerCountAggregateInputType | true
    _avg?: GuestPlayerAvgAggregateInputType
    _sum?: GuestPlayerSumAggregateInputType
    _min?: GuestPlayerMinAggregateInputType
    _max?: GuestPlayerMaxAggregateInputType
  }

  export type GuestPlayerGroupByOutputType = {
    id: string
    teamId: string
    name: string
    addedByUserId: string
    linkedUserId: string | null
    createdAt: Date
    matchesPlayed: number
    totalRuns: number
    ballsFaced: number
    fours: number
    sixes: number
    wicketsTaken: number
    runsConceded: number
    oversBowled: number
    catchesTaken: number
    runOuts: number
    _count: GuestPlayerCountAggregateOutputType | null
    _avg: GuestPlayerAvgAggregateOutputType | null
    _sum: GuestPlayerSumAggregateOutputType | null
    _min: GuestPlayerMinAggregateOutputType | null
    _max: GuestPlayerMaxAggregateOutputType | null
  }

  type GetGuestPlayerGroupByPayload<T extends GuestPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuestPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], GuestPlayerGroupByOutputType[P]>
        }
      >
    >


  export type GuestPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    name?: boolean
    addedByUserId?: boolean
    linkedUserId?: boolean
    createdAt?: boolean
    matchesPlayed?: boolean
    totalRuns?: boolean
    ballsFaced?: boolean
    fours?: boolean
    sixes?: boolean
    wicketsTaken?: boolean
    runsConceded?: boolean
    oversBowled?: boolean
    catchesTaken?: boolean
    runOuts?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    linkedUser?: boolean | GuestPlayer$linkedUserArgs<ExtArgs>
  }, ExtArgs["result"]["guestPlayer"]>



  export type GuestPlayerSelectScalar = {
    id?: boolean
    teamId?: boolean
    name?: boolean
    addedByUserId?: boolean
    linkedUserId?: boolean
    createdAt?: boolean
    matchesPlayed?: boolean
    totalRuns?: boolean
    ballsFaced?: boolean
    fours?: boolean
    sixes?: boolean
    wicketsTaken?: boolean
    runsConceded?: boolean
    oversBowled?: boolean
    catchesTaken?: boolean
    runOuts?: boolean
  }

  export type GuestPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "name" | "addedByUserId" | "linkedUserId" | "createdAt" | "matchesPlayed" | "totalRuns" | "ballsFaced" | "fours" | "sixes" | "wicketsTaken" | "runsConceded" | "oversBowled" | "catchesTaken" | "runOuts", ExtArgs["result"]["guestPlayer"]>
  export type GuestPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    linkedUser?: boolean | GuestPlayer$linkedUserArgs<ExtArgs>
  }

  export type $GuestPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuestPlayer"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      addedBy: Prisma.$UserPayload<ExtArgs>
      linkedUser: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      name: string
      addedByUserId: string
      linkedUserId: string | null
      createdAt: Date
      matchesPlayed: number
      totalRuns: number
      ballsFaced: number
      fours: number
      sixes: number
      wicketsTaken: number
      runsConceded: number
      oversBowled: number
      catchesTaken: number
      runOuts: number
    }, ExtArgs["result"]["guestPlayer"]>
    composites: {}
  }

  type GuestPlayerGetPayload<S extends boolean | null | undefined | GuestPlayerDefaultArgs> = $Result.GetResult<Prisma.$GuestPlayerPayload, S>

  type GuestPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuestPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuestPlayerCountAggregateInputType | true
    }

  export interface GuestPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuestPlayer'], meta: { name: 'GuestPlayer' } }
    /**
     * Find zero or one GuestPlayer that matches the filter.
     * @param {GuestPlayerFindUniqueArgs} args - Arguments to find a GuestPlayer
     * @example
     * // Get one GuestPlayer
     * const guestPlayer = await prisma.guestPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuestPlayerFindUniqueArgs>(args: SelectSubset<T, GuestPlayerFindUniqueArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuestPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuestPlayerFindUniqueOrThrowArgs} args - Arguments to find a GuestPlayer
     * @example
     * // Get one GuestPlayer
     * const guestPlayer = await prisma.guestPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuestPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, GuestPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuestPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestPlayerFindFirstArgs} args - Arguments to find a GuestPlayer
     * @example
     * // Get one GuestPlayer
     * const guestPlayer = await prisma.guestPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuestPlayerFindFirstArgs>(args?: SelectSubset<T, GuestPlayerFindFirstArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuestPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestPlayerFindFirstOrThrowArgs} args - Arguments to find a GuestPlayer
     * @example
     * // Get one GuestPlayer
     * const guestPlayer = await prisma.guestPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuestPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, GuestPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuestPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuestPlayers
     * const guestPlayers = await prisma.guestPlayer.findMany()
     * 
     * // Get first 10 GuestPlayers
     * const guestPlayers = await prisma.guestPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guestPlayerWithIdOnly = await prisma.guestPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuestPlayerFindManyArgs>(args?: SelectSubset<T, GuestPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuestPlayer.
     * @param {GuestPlayerCreateArgs} args - Arguments to create a GuestPlayer.
     * @example
     * // Create one GuestPlayer
     * const GuestPlayer = await prisma.guestPlayer.create({
     *   data: {
     *     // ... data to create a GuestPlayer
     *   }
     * })
     * 
     */
    create<T extends GuestPlayerCreateArgs>(args: SelectSubset<T, GuestPlayerCreateArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuestPlayers.
     * @param {GuestPlayerCreateManyArgs} args - Arguments to create many GuestPlayers.
     * @example
     * // Create many GuestPlayers
     * const guestPlayer = await prisma.guestPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuestPlayerCreateManyArgs>(args?: SelectSubset<T, GuestPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuestPlayer.
     * @param {GuestPlayerDeleteArgs} args - Arguments to delete one GuestPlayer.
     * @example
     * // Delete one GuestPlayer
     * const GuestPlayer = await prisma.guestPlayer.delete({
     *   where: {
     *     // ... filter to delete one GuestPlayer
     *   }
     * })
     * 
     */
    delete<T extends GuestPlayerDeleteArgs>(args: SelectSubset<T, GuestPlayerDeleteArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuestPlayer.
     * @param {GuestPlayerUpdateArgs} args - Arguments to update one GuestPlayer.
     * @example
     * // Update one GuestPlayer
     * const guestPlayer = await prisma.guestPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuestPlayerUpdateArgs>(args: SelectSubset<T, GuestPlayerUpdateArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuestPlayers.
     * @param {GuestPlayerDeleteManyArgs} args - Arguments to filter GuestPlayers to delete.
     * @example
     * // Delete a few GuestPlayers
     * const { count } = await prisma.guestPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuestPlayerDeleteManyArgs>(args?: SelectSubset<T, GuestPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuestPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuestPlayers
     * const guestPlayer = await prisma.guestPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuestPlayerUpdateManyArgs>(args: SelectSubset<T, GuestPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuestPlayer.
     * @param {GuestPlayerUpsertArgs} args - Arguments to update or create a GuestPlayer.
     * @example
     * // Update or create a GuestPlayer
     * const guestPlayer = await prisma.guestPlayer.upsert({
     *   create: {
     *     // ... data to create a GuestPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuestPlayer we want to update
     *   }
     * })
     */
    upsert<T extends GuestPlayerUpsertArgs>(args: SelectSubset<T, GuestPlayerUpsertArgs<ExtArgs>>): Prisma__GuestPlayerClient<$Result.GetResult<Prisma.$GuestPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuestPlayers that matches the filter.
     * @param {GuestPlayerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const guestPlayer = await prisma.guestPlayer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GuestPlayerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GuestPlayer.
     * @param {GuestPlayerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const guestPlayer = await prisma.guestPlayer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GuestPlayerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GuestPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestPlayerCountArgs} args - Arguments to filter GuestPlayers to count.
     * @example
     * // Count the number of GuestPlayers
     * const count = await prisma.guestPlayer.count({
     *   where: {
     *     // ... the filter for the GuestPlayers we want to count
     *   }
     * })
    **/
    count<T extends GuestPlayerCountArgs>(
      args?: Subset<T, GuestPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuestPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestPlayerAggregateArgs>(args: Subset<T, GuestPlayerAggregateArgs>): Prisma.PrismaPromise<GetGuestPlayerAggregateType<T>>

    /**
     * Group by GuestPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuestPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuestPlayerGroupByArgs['orderBy'] }
        : { orderBy?: GuestPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuestPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuestPlayer model
   */
  readonly fields: GuestPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuestPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuestPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    linkedUser<T extends GuestPlayer$linkedUserArgs<ExtArgs> = {}>(args?: Subset<T, GuestPlayer$linkedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuestPlayer model
   */
  interface GuestPlayerFieldRefs {
    readonly id: FieldRef<"GuestPlayer", 'String'>
    readonly teamId: FieldRef<"GuestPlayer", 'String'>
    readonly name: FieldRef<"GuestPlayer", 'String'>
    readonly addedByUserId: FieldRef<"GuestPlayer", 'String'>
    readonly linkedUserId: FieldRef<"GuestPlayer", 'String'>
    readonly createdAt: FieldRef<"GuestPlayer", 'DateTime'>
    readonly matchesPlayed: FieldRef<"GuestPlayer", 'Int'>
    readonly totalRuns: FieldRef<"GuestPlayer", 'Int'>
    readonly ballsFaced: FieldRef<"GuestPlayer", 'Int'>
    readonly fours: FieldRef<"GuestPlayer", 'Int'>
    readonly sixes: FieldRef<"GuestPlayer", 'Int'>
    readonly wicketsTaken: FieldRef<"GuestPlayer", 'Int'>
    readonly runsConceded: FieldRef<"GuestPlayer", 'Int'>
    readonly oversBowled: FieldRef<"GuestPlayer", 'Float'>
    readonly catchesTaken: FieldRef<"GuestPlayer", 'Int'>
    readonly runOuts: FieldRef<"GuestPlayer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GuestPlayer findUnique
   */
  export type GuestPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * Filter, which GuestPlayer to fetch.
     */
    where: GuestPlayerWhereUniqueInput
  }

  /**
   * GuestPlayer findUniqueOrThrow
   */
  export type GuestPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * Filter, which GuestPlayer to fetch.
     */
    where: GuestPlayerWhereUniqueInput
  }

  /**
   * GuestPlayer findFirst
   */
  export type GuestPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * Filter, which GuestPlayer to fetch.
     */
    where?: GuestPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestPlayers to fetch.
     */
    orderBy?: GuestPlayerOrderByWithRelationInput | GuestPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuestPlayers.
     */
    cursor?: GuestPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuestPlayers.
     */
    distinct?: GuestPlayerScalarFieldEnum | GuestPlayerScalarFieldEnum[]
  }

  /**
   * GuestPlayer findFirstOrThrow
   */
  export type GuestPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * Filter, which GuestPlayer to fetch.
     */
    where?: GuestPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestPlayers to fetch.
     */
    orderBy?: GuestPlayerOrderByWithRelationInput | GuestPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuestPlayers.
     */
    cursor?: GuestPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuestPlayers.
     */
    distinct?: GuestPlayerScalarFieldEnum | GuestPlayerScalarFieldEnum[]
  }

  /**
   * GuestPlayer findMany
   */
  export type GuestPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * Filter, which GuestPlayers to fetch.
     */
    where?: GuestPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestPlayers to fetch.
     */
    orderBy?: GuestPlayerOrderByWithRelationInput | GuestPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuestPlayers.
     */
    cursor?: GuestPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestPlayers.
     */
    skip?: number
    distinct?: GuestPlayerScalarFieldEnum | GuestPlayerScalarFieldEnum[]
  }

  /**
   * GuestPlayer create
   */
  export type GuestPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a GuestPlayer.
     */
    data: XOR<GuestPlayerCreateInput, GuestPlayerUncheckedCreateInput>
  }

  /**
   * GuestPlayer createMany
   */
  export type GuestPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuestPlayers.
     */
    data: GuestPlayerCreateManyInput | GuestPlayerCreateManyInput[]
  }

  /**
   * GuestPlayer update
   */
  export type GuestPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a GuestPlayer.
     */
    data: XOR<GuestPlayerUpdateInput, GuestPlayerUncheckedUpdateInput>
    /**
     * Choose, which GuestPlayer to update.
     */
    where: GuestPlayerWhereUniqueInput
  }

  /**
   * GuestPlayer updateMany
   */
  export type GuestPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuestPlayers.
     */
    data: XOR<GuestPlayerUpdateManyMutationInput, GuestPlayerUncheckedUpdateManyInput>
    /**
     * Filter which GuestPlayers to update
     */
    where?: GuestPlayerWhereInput
    /**
     * Limit how many GuestPlayers to update.
     */
    limit?: number
  }

  /**
   * GuestPlayer upsert
   */
  export type GuestPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the GuestPlayer to update in case it exists.
     */
    where: GuestPlayerWhereUniqueInput
    /**
     * In case the GuestPlayer found by the `where` argument doesn't exist, create a new GuestPlayer with this data.
     */
    create: XOR<GuestPlayerCreateInput, GuestPlayerUncheckedCreateInput>
    /**
     * In case the GuestPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuestPlayerUpdateInput, GuestPlayerUncheckedUpdateInput>
  }

  /**
   * GuestPlayer delete
   */
  export type GuestPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
    /**
     * Filter which GuestPlayer to delete.
     */
    where: GuestPlayerWhereUniqueInput
  }

  /**
   * GuestPlayer deleteMany
   */
  export type GuestPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuestPlayers to delete
     */
    where?: GuestPlayerWhereInput
    /**
     * Limit how many GuestPlayers to delete.
     */
    limit?: number
  }

  /**
   * GuestPlayer findRaw
   */
  export type GuestPlayerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuestPlayer aggregateRaw
   */
  export type GuestPlayerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GuestPlayer.linkedUser
   */
  export type GuestPlayer$linkedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GuestPlayer without action
   */
  export type GuestPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestPlayer
     */
    select?: GuestPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestPlayer
     */
    omit?: GuestPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestPlayerInclude<ExtArgs> | null
  }


  /**
   * Model TeamInvitation
   */

  export type AggregateTeamInvitation = {
    _count: TeamInvitationCountAggregateOutputType | null
    _min: TeamInvitationMinAggregateOutputType | null
    _max: TeamInvitationMaxAggregateOutputType | null
  }

  export type TeamInvitationMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    invitedBy: string | null
    invitedUser: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
  }

  export type TeamInvitationMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    invitedBy: string | null
    invitedUser: string | null
    status: $Enums.InvitationStatus | null
    createdAt: Date | null
  }

  export type TeamInvitationCountAggregateOutputType = {
    id: number
    teamId: number
    invitedBy: number
    invitedUser: number
    status: number
    createdAt: number
    _all: number
  }


  export type TeamInvitationMinAggregateInputType = {
    id?: true
    teamId?: true
    invitedBy?: true
    invitedUser?: true
    status?: true
    createdAt?: true
  }

  export type TeamInvitationMaxAggregateInputType = {
    id?: true
    teamId?: true
    invitedBy?: true
    invitedUser?: true
    status?: true
    createdAt?: true
  }

  export type TeamInvitationCountAggregateInputType = {
    id?: true
    teamId?: true
    invitedBy?: true
    invitedUser?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type TeamInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamInvitation to aggregate.
     */
    where?: TeamInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvitations to fetch.
     */
    orderBy?: TeamInvitationOrderByWithRelationInput | TeamInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamInvitations
    **/
    _count?: true | TeamInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamInvitationMaxAggregateInputType
  }

  export type GetTeamInvitationAggregateType<T extends TeamInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamInvitation[P]>
      : GetScalarType<T[P], AggregateTeamInvitation[P]>
  }




  export type TeamInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamInvitationWhereInput
    orderBy?: TeamInvitationOrderByWithAggregationInput | TeamInvitationOrderByWithAggregationInput[]
    by: TeamInvitationScalarFieldEnum[] | TeamInvitationScalarFieldEnum
    having?: TeamInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamInvitationCountAggregateInputType | true
    _min?: TeamInvitationMinAggregateInputType
    _max?: TeamInvitationMaxAggregateInputType
  }

  export type TeamInvitationGroupByOutputType = {
    id: string
    teamId: string
    invitedBy: string
    invitedUser: string
    status: $Enums.InvitationStatus
    createdAt: Date
    _count: TeamInvitationCountAggregateOutputType | null
    _min: TeamInvitationMinAggregateOutputType | null
    _max: TeamInvitationMaxAggregateOutputType | null
  }

  type GetTeamInvitationGroupByPayload<T extends TeamInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], TeamInvitationGroupByOutputType[P]>
        }
      >
    >


  export type TeamInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    invitedBy?: boolean
    invitedUser?: boolean
    status?: boolean
    createdAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invited?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamInvitation"]>



  export type TeamInvitationSelectScalar = {
    id?: boolean
    teamId?: boolean
    invitedBy?: boolean
    invitedUser?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type TeamInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "invitedBy" | "invitedUser" | "status" | "createdAt", ExtArgs["result"]["teamInvitation"]>
  export type TeamInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
    invited?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamInvitation"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
      invited: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      invitedBy: string
      invitedUser: string
      status: $Enums.InvitationStatus
      createdAt: Date
    }, ExtArgs["result"]["teamInvitation"]>
    composites: {}
  }

  type TeamInvitationGetPayload<S extends boolean | null | undefined | TeamInvitationDefaultArgs> = $Result.GetResult<Prisma.$TeamInvitationPayload, S>

  type TeamInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamInvitationCountAggregateInputType | true
    }

  export interface TeamInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamInvitation'], meta: { name: 'TeamInvitation' } }
    /**
     * Find zero or one TeamInvitation that matches the filter.
     * @param {TeamInvitationFindUniqueArgs} args - Arguments to find a TeamInvitation
     * @example
     * // Get one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamInvitationFindUniqueArgs>(args: SelectSubset<T, TeamInvitationFindUniqueArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamInvitationFindUniqueOrThrowArgs} args - Arguments to find a TeamInvitation
     * @example
     * // Get one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInvitationFindFirstArgs} args - Arguments to find a TeamInvitation
     * @example
     * // Get one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamInvitationFindFirstArgs>(args?: SelectSubset<T, TeamInvitationFindFirstArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInvitationFindFirstOrThrowArgs} args - Arguments to find a TeamInvitation
     * @example
     * // Get one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamInvitations
     * const teamInvitations = await prisma.teamInvitation.findMany()
     * 
     * // Get first 10 TeamInvitations
     * const teamInvitations = await prisma.teamInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamInvitationWithIdOnly = await prisma.teamInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamInvitationFindManyArgs>(args?: SelectSubset<T, TeamInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamInvitation.
     * @param {TeamInvitationCreateArgs} args - Arguments to create a TeamInvitation.
     * @example
     * // Create one TeamInvitation
     * const TeamInvitation = await prisma.teamInvitation.create({
     *   data: {
     *     // ... data to create a TeamInvitation
     *   }
     * })
     * 
     */
    create<T extends TeamInvitationCreateArgs>(args: SelectSubset<T, TeamInvitationCreateArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamInvitations.
     * @param {TeamInvitationCreateManyArgs} args - Arguments to create many TeamInvitations.
     * @example
     * // Create many TeamInvitations
     * const teamInvitation = await prisma.teamInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamInvitationCreateManyArgs>(args?: SelectSubset<T, TeamInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamInvitation.
     * @param {TeamInvitationDeleteArgs} args - Arguments to delete one TeamInvitation.
     * @example
     * // Delete one TeamInvitation
     * const TeamInvitation = await prisma.teamInvitation.delete({
     *   where: {
     *     // ... filter to delete one TeamInvitation
     *   }
     * })
     * 
     */
    delete<T extends TeamInvitationDeleteArgs>(args: SelectSubset<T, TeamInvitationDeleteArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamInvitation.
     * @param {TeamInvitationUpdateArgs} args - Arguments to update one TeamInvitation.
     * @example
     * // Update one TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamInvitationUpdateArgs>(args: SelectSubset<T, TeamInvitationUpdateArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamInvitations.
     * @param {TeamInvitationDeleteManyArgs} args - Arguments to filter TeamInvitations to delete.
     * @example
     * // Delete a few TeamInvitations
     * const { count } = await prisma.teamInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamInvitationDeleteManyArgs>(args?: SelectSubset<T, TeamInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamInvitations
     * const teamInvitation = await prisma.teamInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamInvitationUpdateManyArgs>(args: SelectSubset<T, TeamInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamInvitation.
     * @param {TeamInvitationUpsertArgs} args - Arguments to update or create a TeamInvitation.
     * @example
     * // Update or create a TeamInvitation
     * const teamInvitation = await prisma.teamInvitation.upsert({
     *   create: {
     *     // ... data to create a TeamInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamInvitation we want to update
     *   }
     * })
     */
    upsert<T extends TeamInvitationUpsertArgs>(args: SelectSubset<T, TeamInvitationUpsertArgs<ExtArgs>>): Prisma__TeamInvitationClient<$Result.GetResult<Prisma.$TeamInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamInvitations that matches the filter.
     * @param {TeamInvitationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamInvitation = await prisma.teamInvitation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamInvitationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamInvitation.
     * @param {TeamInvitationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamInvitation = await prisma.teamInvitation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamInvitationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInvitationCountArgs} args - Arguments to filter TeamInvitations to count.
     * @example
     * // Count the number of TeamInvitations
     * const count = await prisma.teamInvitation.count({
     *   where: {
     *     // ... the filter for the TeamInvitations we want to count
     *   }
     * })
    **/
    count<T extends TeamInvitationCountArgs>(
      args?: Subset<T, TeamInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamInvitationAggregateArgs>(args: Subset<T, TeamInvitationAggregateArgs>): Prisma.PrismaPromise<GetTeamInvitationAggregateType<T>>

    /**
     * Group by TeamInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamInvitationGroupByArgs['orderBy'] }
        : { orderBy?: TeamInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamInvitation model
   */
  readonly fields: TeamInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invited<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamInvitation model
   */
  interface TeamInvitationFieldRefs {
    readonly id: FieldRef<"TeamInvitation", 'String'>
    readonly teamId: FieldRef<"TeamInvitation", 'String'>
    readonly invitedBy: FieldRef<"TeamInvitation", 'String'>
    readonly invitedUser: FieldRef<"TeamInvitation", 'String'>
    readonly status: FieldRef<"TeamInvitation", 'InvitationStatus'>
    readonly createdAt: FieldRef<"TeamInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamInvitation findUnique
   */
  export type TeamInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvitation to fetch.
     */
    where: TeamInvitationWhereUniqueInput
  }

  /**
   * TeamInvitation findUniqueOrThrow
   */
  export type TeamInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvitation to fetch.
     */
    where: TeamInvitationWhereUniqueInput
  }

  /**
   * TeamInvitation findFirst
   */
  export type TeamInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvitation to fetch.
     */
    where?: TeamInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvitations to fetch.
     */
    orderBy?: TeamInvitationOrderByWithRelationInput | TeamInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamInvitations.
     */
    cursor?: TeamInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamInvitations.
     */
    distinct?: TeamInvitationScalarFieldEnum | TeamInvitationScalarFieldEnum[]
  }

  /**
   * TeamInvitation findFirstOrThrow
   */
  export type TeamInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvitation to fetch.
     */
    where?: TeamInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvitations to fetch.
     */
    orderBy?: TeamInvitationOrderByWithRelationInput | TeamInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamInvitations.
     */
    cursor?: TeamInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamInvitations.
     */
    distinct?: TeamInvitationScalarFieldEnum | TeamInvitationScalarFieldEnum[]
  }

  /**
   * TeamInvitation findMany
   */
  export type TeamInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * Filter, which TeamInvitations to fetch.
     */
    where?: TeamInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamInvitations to fetch.
     */
    orderBy?: TeamInvitationOrderByWithRelationInput | TeamInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamInvitations.
     */
    cursor?: TeamInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamInvitations.
     */
    skip?: number
    distinct?: TeamInvitationScalarFieldEnum | TeamInvitationScalarFieldEnum[]
  }

  /**
   * TeamInvitation create
   */
  export type TeamInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamInvitation.
     */
    data: XOR<TeamInvitationCreateInput, TeamInvitationUncheckedCreateInput>
  }

  /**
   * TeamInvitation createMany
   */
  export type TeamInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamInvitations.
     */
    data: TeamInvitationCreateManyInput | TeamInvitationCreateManyInput[]
  }

  /**
   * TeamInvitation update
   */
  export type TeamInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamInvitation.
     */
    data: XOR<TeamInvitationUpdateInput, TeamInvitationUncheckedUpdateInput>
    /**
     * Choose, which TeamInvitation to update.
     */
    where: TeamInvitationWhereUniqueInput
  }

  /**
   * TeamInvitation updateMany
   */
  export type TeamInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamInvitations.
     */
    data: XOR<TeamInvitationUpdateManyMutationInput, TeamInvitationUncheckedUpdateManyInput>
    /**
     * Filter which TeamInvitations to update
     */
    where?: TeamInvitationWhereInput
    /**
     * Limit how many TeamInvitations to update.
     */
    limit?: number
  }

  /**
   * TeamInvitation upsert
   */
  export type TeamInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamInvitation to update in case it exists.
     */
    where: TeamInvitationWhereUniqueInput
    /**
     * In case the TeamInvitation found by the `where` argument doesn't exist, create a new TeamInvitation with this data.
     */
    create: XOR<TeamInvitationCreateInput, TeamInvitationUncheckedCreateInput>
    /**
     * In case the TeamInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamInvitationUpdateInput, TeamInvitationUncheckedUpdateInput>
  }

  /**
   * TeamInvitation delete
   */
  export type TeamInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
    /**
     * Filter which TeamInvitation to delete.
     */
    where: TeamInvitationWhereUniqueInput
  }

  /**
   * TeamInvitation deleteMany
   */
  export type TeamInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamInvitations to delete
     */
    where?: TeamInvitationWhereInput
    /**
     * Limit how many TeamInvitations to delete.
     */
    limit?: number
  }

  /**
   * TeamInvitation findRaw
   */
  export type TeamInvitationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamInvitation aggregateRaw
   */
  export type TeamInvitationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamInvitation without action
   */
  export type TeamInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamInvitation
     */
    select?: TeamInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamInvitation
     */
    omit?: TeamInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInvitationInclude<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    runsScored: number | null
    ballsFaced: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
    runOuts: number | null
  }

  export type MatchSumAggregateOutputType = {
    runsScored: number | null
    ballsFaced: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
    runOuts: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: string | null
    userId: string | null
    opponent: string | null
    matchDate: Date | null
    runsScored: number | null
    ballsFaced: number | null
    wasDismissed: boolean | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
    runOuts: number | null
    isManOfTheMatch: boolean | null
    createdAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    opponent: string | null
    matchDate: Date | null
    runsScored: number | null
    ballsFaced: number | null
    wasDismissed: boolean | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
    runOuts: number | null
    isManOfTheMatch: boolean | null
    createdAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    userId: number
    opponent: number
    matchDate: number
    runsScored: number
    ballsFaced: number
    wasDismissed: number
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts: number
    isManOfTheMatch: number
    createdAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    runsScored?: true
    ballsFaced?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
    runOuts?: true
  }

  export type MatchSumAggregateInputType = {
    runsScored?: true
    ballsFaced?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
    runOuts?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    userId?: true
    opponent?: true
    matchDate?: true
    runsScored?: true
    ballsFaced?: true
    wasDismissed?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
    runOuts?: true
    isManOfTheMatch?: true
    createdAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    userId?: true
    opponent?: true
    matchDate?: true
    runsScored?: true
    ballsFaced?: true
    wasDismissed?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
    runOuts?: true
    isManOfTheMatch?: true
    createdAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    userId?: true
    opponent?: true
    matchDate?: true
    runsScored?: true
    ballsFaced?: true
    wasDismissed?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
    runOuts?: true
    isManOfTheMatch?: true
    createdAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: string
    userId: string
    opponent: string
    matchDate: Date
    runsScored: number
    ballsFaced: number
    wasDismissed: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts: number
    isManOfTheMatch: boolean
    createdAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    opponent?: boolean
    matchDate?: boolean
    runsScored?: boolean
    ballsFaced?: boolean
    wasDismissed?: boolean
    oversBowled?: boolean
    runsConceded?: boolean
    wicketsTaken?: boolean
    catchesTaken?: boolean
    runOuts?: boolean
    isManOfTheMatch?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>



  export type MatchSelectScalar = {
    id?: boolean
    userId?: boolean
    opponent?: boolean
    matchDate?: boolean
    runsScored?: boolean
    ballsFaced?: boolean
    wasDismissed?: boolean
    oversBowled?: boolean
    runsConceded?: boolean
    wicketsTaken?: boolean
    catchesTaken?: boolean
    runOuts?: boolean
    isManOfTheMatch?: boolean
    createdAt?: boolean
  }

  export type MatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "opponent" | "matchDate" | "runsScored" | "ballsFaced" | "wasDismissed" | "oversBowled" | "runsConceded" | "wicketsTaken" | "catchesTaken" | "runOuts" | "isManOfTheMatch" | "createdAt", ExtArgs["result"]["match"]>
  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      opponent: string
      matchDate: Date
      runsScored: number
      ballsFaced: number
      wasDismissed: boolean
      oversBowled: number
      runsConceded: number
      wicketsTaken: number
      catchesTaken: number
      runOuts: number
      isManOfTheMatch: boolean
      createdAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * @param {MatchFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const match = await prisma.match.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MatchFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Match.
     * @param {MatchAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const match = await prisma.match.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MatchAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'String'>
    readonly userId: FieldRef<"Match", 'String'>
    readonly opponent: FieldRef<"Match", 'String'>
    readonly matchDate: FieldRef<"Match", 'DateTime'>
    readonly runsScored: FieldRef<"Match", 'Int'>
    readonly ballsFaced: FieldRef<"Match", 'Int'>
    readonly wasDismissed: FieldRef<"Match", 'Boolean'>
    readonly oversBowled: FieldRef<"Match", 'Float'>
    readonly runsConceded: FieldRef<"Match", 'Int'>
    readonly wicketsTaken: FieldRef<"Match", 'Int'>
    readonly catchesTaken: FieldRef<"Match", 'Int'>
    readonly runOuts: FieldRef<"Match", 'Int'>
    readonly isManOfTheMatch: FieldRef<"Match", 'Boolean'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to delete.
     */
    limit?: number
  }

  /**
   * Match findRaw
   */
  export type MatchFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Match aggregateRaw
   */
  export type MatchAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model TeamMatch
   */

  export type AggregateTeamMatch = {
    _count: TeamMatchCountAggregateOutputType | null
    _avg: TeamMatchAvgAggregateOutputType | null
    _sum: TeamMatchSumAggregateOutputType | null
    _min: TeamMatchMinAggregateOutputType | null
    _max: TeamMatchMaxAggregateOutputType | null
  }

  export type TeamMatchAvgAggregateOutputType = {
    homeTeamRuns: number | null
    homeTeamWickets: number | null
    homeTeamOvers: number | null
    awayTeamRuns: number | null
    awayTeamWickets: number | null
    awayTeamOvers: number | null
  }

  export type TeamMatchSumAggregateOutputType = {
    homeTeamRuns: number | null
    homeTeamWickets: number | null
    homeTeamOvers: number | null
    awayTeamRuns: number | null
    awayTeamWickets: number | null
    awayTeamOvers: number | null
  }

  export type TeamMatchMinAggregateOutputType = {
    id: string | null
    homeTeamId: string | null
    awayTeamId: string | null
    matchDate: Date | null
    venue: string | null
    status: $Enums.MatchStatus | null
    result: $Enums.MatchResult | null
    homeTeamRuns: number | null
    homeTeamWickets: number | null
    homeTeamOvers: number | null
    awayTeamRuns: number | null
    awayTeamWickets: number | null
    awayTeamOvers: number | null
    createdAt: Date | null
  }

  export type TeamMatchMaxAggregateOutputType = {
    id: string | null
    homeTeamId: string | null
    awayTeamId: string | null
    matchDate: Date | null
    venue: string | null
    status: $Enums.MatchStatus | null
    result: $Enums.MatchResult | null
    homeTeamRuns: number | null
    homeTeamWickets: number | null
    homeTeamOvers: number | null
    awayTeamRuns: number | null
    awayTeamWickets: number | null
    awayTeamOvers: number | null
    createdAt: Date | null
  }

  export type TeamMatchCountAggregateOutputType = {
    id: number
    homeTeamId: number
    awayTeamId: number
    matchDate: number
    venue: number
    status: number
    result: number
    homeTeamRuns: number
    homeTeamWickets: number
    homeTeamOvers: number
    awayTeamRuns: number
    awayTeamWickets: number
    awayTeamOvers: number
    createdAt: number
    _all: number
  }


  export type TeamMatchAvgAggregateInputType = {
    homeTeamRuns?: true
    homeTeamWickets?: true
    homeTeamOvers?: true
    awayTeamRuns?: true
    awayTeamWickets?: true
    awayTeamOvers?: true
  }

  export type TeamMatchSumAggregateInputType = {
    homeTeamRuns?: true
    homeTeamWickets?: true
    homeTeamOvers?: true
    awayTeamRuns?: true
    awayTeamWickets?: true
    awayTeamOvers?: true
  }

  export type TeamMatchMinAggregateInputType = {
    id?: true
    homeTeamId?: true
    awayTeamId?: true
    matchDate?: true
    venue?: true
    status?: true
    result?: true
    homeTeamRuns?: true
    homeTeamWickets?: true
    homeTeamOvers?: true
    awayTeamRuns?: true
    awayTeamWickets?: true
    awayTeamOvers?: true
    createdAt?: true
  }

  export type TeamMatchMaxAggregateInputType = {
    id?: true
    homeTeamId?: true
    awayTeamId?: true
    matchDate?: true
    venue?: true
    status?: true
    result?: true
    homeTeamRuns?: true
    homeTeamWickets?: true
    homeTeamOvers?: true
    awayTeamRuns?: true
    awayTeamWickets?: true
    awayTeamOvers?: true
    createdAt?: true
  }

  export type TeamMatchCountAggregateInputType = {
    id?: true
    homeTeamId?: true
    awayTeamId?: true
    matchDate?: true
    venue?: true
    status?: true
    result?: true
    homeTeamRuns?: true
    homeTeamWickets?: true
    homeTeamOvers?: true
    awayTeamRuns?: true
    awayTeamWickets?: true
    awayTeamOvers?: true
    createdAt?: true
    _all?: true
  }

  export type TeamMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMatch to aggregate.
     */
    where?: TeamMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatches to fetch.
     */
    orderBy?: TeamMatchOrderByWithRelationInput | TeamMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMatches
    **/
    _count?: true | TeamMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMatchMaxAggregateInputType
  }

  export type GetTeamMatchAggregateType<T extends TeamMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMatch[P]>
      : GetScalarType<T[P], AggregateTeamMatch[P]>
  }




  export type TeamMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMatchWhereInput
    orderBy?: TeamMatchOrderByWithAggregationInput | TeamMatchOrderByWithAggregationInput[]
    by: TeamMatchScalarFieldEnum[] | TeamMatchScalarFieldEnum
    having?: TeamMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMatchCountAggregateInputType | true
    _avg?: TeamMatchAvgAggregateInputType
    _sum?: TeamMatchSumAggregateInputType
    _min?: TeamMatchMinAggregateInputType
    _max?: TeamMatchMaxAggregateInputType
  }

  export type TeamMatchGroupByOutputType = {
    id: string
    homeTeamId: string
    awayTeamId: string
    matchDate: Date
    venue: string
    status: $Enums.MatchStatus
    result: $Enums.MatchResult | null
    homeTeamRuns: number
    homeTeamWickets: number
    homeTeamOvers: number
    awayTeamRuns: number
    awayTeamWickets: number
    awayTeamOvers: number
    createdAt: Date
    _count: TeamMatchCountAggregateOutputType | null
    _avg: TeamMatchAvgAggregateOutputType | null
    _sum: TeamMatchSumAggregateOutputType | null
    _min: TeamMatchMinAggregateOutputType | null
    _max: TeamMatchMaxAggregateOutputType | null
  }

  type GetTeamMatchGroupByPayload<T extends TeamMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMatchGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMatchGroupByOutputType[P]>
        }
      >
    >


  export type TeamMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    matchDate?: boolean
    venue?: boolean
    status?: boolean
    result?: boolean
    homeTeamRuns?: boolean
    homeTeamWickets?: boolean
    homeTeamOvers?: boolean
    awayTeamRuns?: boolean
    awayTeamWickets?: boolean
    awayTeamOvers?: boolean
    createdAt?: boolean
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    playerStats?: boolean | TeamMatch$playerStatsArgs<ExtArgs>
    _count?: boolean | TeamMatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMatch"]>



  export type TeamMatchSelectScalar = {
    id?: boolean
    homeTeamId?: boolean
    awayTeamId?: boolean
    matchDate?: boolean
    venue?: boolean
    status?: boolean
    result?: boolean
    homeTeamRuns?: boolean
    homeTeamWickets?: boolean
    homeTeamOvers?: boolean
    awayTeamRuns?: boolean
    awayTeamWickets?: boolean
    awayTeamOvers?: boolean
    createdAt?: boolean
  }

  export type TeamMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "homeTeamId" | "awayTeamId" | "matchDate" | "venue" | "status" | "result" | "homeTeamRuns" | "homeTeamWickets" | "homeTeamOvers" | "awayTeamRuns" | "awayTeamWickets" | "awayTeamOvers" | "createdAt", ExtArgs["result"]["teamMatch"]>
  export type TeamMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    homeTeam?: boolean | TeamDefaultArgs<ExtArgs>
    awayTeam?: boolean | TeamDefaultArgs<ExtArgs>
    playerStats?: boolean | TeamMatch$playerStatsArgs<ExtArgs>
    _count?: boolean | TeamMatchCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMatch"
    objects: {
      homeTeam: Prisma.$TeamPayload<ExtArgs>
      awayTeam: Prisma.$TeamPayload<ExtArgs>
      playerStats: Prisma.$TeamMatchPlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      homeTeamId: string
      awayTeamId: string
      matchDate: Date
      venue: string
      status: $Enums.MatchStatus
      result: $Enums.MatchResult | null
      homeTeamRuns: number
      homeTeamWickets: number
      homeTeamOvers: number
      awayTeamRuns: number
      awayTeamWickets: number
      awayTeamOvers: number
      createdAt: Date
    }, ExtArgs["result"]["teamMatch"]>
    composites: {}
  }

  type TeamMatchGetPayload<S extends boolean | null | undefined | TeamMatchDefaultArgs> = $Result.GetResult<Prisma.$TeamMatchPayload, S>

  type TeamMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMatchCountAggregateInputType | true
    }

  export interface TeamMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMatch'], meta: { name: 'TeamMatch' } }
    /**
     * Find zero or one TeamMatch that matches the filter.
     * @param {TeamMatchFindUniqueArgs} args - Arguments to find a TeamMatch
     * @example
     * // Get one TeamMatch
     * const teamMatch = await prisma.teamMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMatchFindUniqueArgs>(args: SelectSubset<T, TeamMatchFindUniqueArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMatchFindUniqueOrThrowArgs} args - Arguments to find a TeamMatch
     * @example
     * // Get one TeamMatch
     * const teamMatch = await prisma.teamMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchFindFirstArgs} args - Arguments to find a TeamMatch
     * @example
     * // Get one TeamMatch
     * const teamMatch = await prisma.teamMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMatchFindFirstArgs>(args?: SelectSubset<T, TeamMatchFindFirstArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchFindFirstOrThrowArgs} args - Arguments to find a TeamMatch
     * @example
     * // Get one TeamMatch
     * const teamMatch = await prisma.teamMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMatches
     * const teamMatches = await prisma.teamMatch.findMany()
     * 
     * // Get first 10 TeamMatches
     * const teamMatches = await prisma.teamMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMatchWithIdOnly = await prisma.teamMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMatchFindManyArgs>(args?: SelectSubset<T, TeamMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMatch.
     * @param {TeamMatchCreateArgs} args - Arguments to create a TeamMatch.
     * @example
     * // Create one TeamMatch
     * const TeamMatch = await prisma.teamMatch.create({
     *   data: {
     *     // ... data to create a TeamMatch
     *   }
     * })
     * 
     */
    create<T extends TeamMatchCreateArgs>(args: SelectSubset<T, TeamMatchCreateArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMatches.
     * @param {TeamMatchCreateManyArgs} args - Arguments to create many TeamMatches.
     * @example
     * // Create many TeamMatches
     * const teamMatch = await prisma.teamMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMatchCreateManyArgs>(args?: SelectSubset<T, TeamMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMatch.
     * @param {TeamMatchDeleteArgs} args - Arguments to delete one TeamMatch.
     * @example
     * // Delete one TeamMatch
     * const TeamMatch = await prisma.teamMatch.delete({
     *   where: {
     *     // ... filter to delete one TeamMatch
     *   }
     * })
     * 
     */
    delete<T extends TeamMatchDeleteArgs>(args: SelectSubset<T, TeamMatchDeleteArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMatch.
     * @param {TeamMatchUpdateArgs} args - Arguments to update one TeamMatch.
     * @example
     * // Update one TeamMatch
     * const teamMatch = await prisma.teamMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMatchUpdateArgs>(args: SelectSubset<T, TeamMatchUpdateArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMatches.
     * @param {TeamMatchDeleteManyArgs} args - Arguments to filter TeamMatches to delete.
     * @example
     * // Delete a few TeamMatches
     * const { count } = await prisma.teamMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMatchDeleteManyArgs>(args?: SelectSubset<T, TeamMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMatches
     * const teamMatch = await prisma.teamMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMatchUpdateManyArgs>(args: SelectSubset<T, TeamMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMatch.
     * @param {TeamMatchUpsertArgs} args - Arguments to update or create a TeamMatch.
     * @example
     * // Update or create a TeamMatch
     * const teamMatch = await prisma.teamMatch.upsert({
     *   create: {
     *     // ... data to create a TeamMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMatch we want to update
     *   }
     * })
     */
    upsert<T extends TeamMatchUpsertArgs>(args: SelectSubset<T, TeamMatchUpsertArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMatches that matches the filter.
     * @param {TeamMatchFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamMatch = await prisma.teamMatch.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamMatchFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamMatch.
     * @param {TeamMatchAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamMatch = await prisma.teamMatch.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamMatchAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchCountArgs} args - Arguments to filter TeamMatches to count.
     * @example
     * // Count the number of TeamMatches
     * const count = await prisma.teamMatch.count({
     *   where: {
     *     // ... the filter for the TeamMatches we want to count
     *   }
     * })
    **/
    count<T extends TeamMatchCountArgs>(
      args?: Subset<T, TeamMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMatchAggregateArgs>(args: Subset<T, TeamMatchAggregateArgs>): Prisma.PrismaPromise<GetTeamMatchAggregateType<T>>

    /**
     * Group by TeamMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMatchGroupByArgs['orderBy'] }
        : { orderBy?: TeamMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMatch model
   */
  readonly fields: TeamMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    homeTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    awayTeam<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    playerStats<T extends TeamMatch$playerStatsArgs<ExtArgs> = {}>(args?: Subset<T, TeamMatch$playerStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMatch model
   */
  interface TeamMatchFieldRefs {
    readonly id: FieldRef<"TeamMatch", 'String'>
    readonly homeTeamId: FieldRef<"TeamMatch", 'String'>
    readonly awayTeamId: FieldRef<"TeamMatch", 'String'>
    readonly matchDate: FieldRef<"TeamMatch", 'DateTime'>
    readonly venue: FieldRef<"TeamMatch", 'String'>
    readonly status: FieldRef<"TeamMatch", 'MatchStatus'>
    readonly result: FieldRef<"TeamMatch", 'MatchResult'>
    readonly homeTeamRuns: FieldRef<"TeamMatch", 'Int'>
    readonly homeTeamWickets: FieldRef<"TeamMatch", 'Int'>
    readonly homeTeamOvers: FieldRef<"TeamMatch", 'Float'>
    readonly awayTeamRuns: FieldRef<"TeamMatch", 'Int'>
    readonly awayTeamWickets: FieldRef<"TeamMatch", 'Int'>
    readonly awayTeamOvers: FieldRef<"TeamMatch", 'Float'>
    readonly createdAt: FieldRef<"TeamMatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMatch findUnique
   */
  export type TeamMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatch to fetch.
     */
    where: TeamMatchWhereUniqueInput
  }

  /**
   * TeamMatch findUniqueOrThrow
   */
  export type TeamMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatch to fetch.
     */
    where: TeamMatchWhereUniqueInput
  }

  /**
   * TeamMatch findFirst
   */
  export type TeamMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatch to fetch.
     */
    where?: TeamMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatches to fetch.
     */
    orderBy?: TeamMatchOrderByWithRelationInput | TeamMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMatches.
     */
    cursor?: TeamMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMatches.
     */
    distinct?: TeamMatchScalarFieldEnum | TeamMatchScalarFieldEnum[]
  }

  /**
   * TeamMatch findFirstOrThrow
   */
  export type TeamMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatch to fetch.
     */
    where?: TeamMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatches to fetch.
     */
    orderBy?: TeamMatchOrderByWithRelationInput | TeamMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMatches.
     */
    cursor?: TeamMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMatches.
     */
    distinct?: TeamMatchScalarFieldEnum | TeamMatchScalarFieldEnum[]
  }

  /**
   * TeamMatch findMany
   */
  export type TeamMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatches to fetch.
     */
    where?: TeamMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatches to fetch.
     */
    orderBy?: TeamMatchOrderByWithRelationInput | TeamMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMatches.
     */
    cursor?: TeamMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatches.
     */
    skip?: number
    distinct?: TeamMatchScalarFieldEnum | TeamMatchScalarFieldEnum[]
  }

  /**
   * TeamMatch create
   */
  export type TeamMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMatch.
     */
    data: XOR<TeamMatchCreateInput, TeamMatchUncheckedCreateInput>
  }

  /**
   * TeamMatch createMany
   */
  export type TeamMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMatches.
     */
    data: TeamMatchCreateManyInput | TeamMatchCreateManyInput[]
  }

  /**
   * TeamMatch update
   */
  export type TeamMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMatch.
     */
    data: XOR<TeamMatchUpdateInput, TeamMatchUncheckedUpdateInput>
    /**
     * Choose, which TeamMatch to update.
     */
    where: TeamMatchWhereUniqueInput
  }

  /**
   * TeamMatch updateMany
   */
  export type TeamMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMatches.
     */
    data: XOR<TeamMatchUpdateManyMutationInput, TeamMatchUncheckedUpdateManyInput>
    /**
     * Filter which TeamMatches to update
     */
    where?: TeamMatchWhereInput
    /**
     * Limit how many TeamMatches to update.
     */
    limit?: number
  }

  /**
   * TeamMatch upsert
   */
  export type TeamMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMatch to update in case it exists.
     */
    where: TeamMatchWhereUniqueInput
    /**
     * In case the TeamMatch found by the `where` argument doesn't exist, create a new TeamMatch with this data.
     */
    create: XOR<TeamMatchCreateInput, TeamMatchUncheckedCreateInput>
    /**
     * In case the TeamMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMatchUpdateInput, TeamMatchUncheckedUpdateInput>
  }

  /**
   * TeamMatch delete
   */
  export type TeamMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
    /**
     * Filter which TeamMatch to delete.
     */
    where: TeamMatchWhereUniqueInput
  }

  /**
   * TeamMatch deleteMany
   */
  export type TeamMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMatches to delete
     */
    where?: TeamMatchWhereInput
    /**
     * Limit how many TeamMatches to delete.
     */
    limit?: number
  }

  /**
   * TeamMatch findRaw
   */
  export type TeamMatchFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMatch aggregateRaw
   */
  export type TeamMatchAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMatch.playerStats
   */
  export type TeamMatch$playerStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    where?: TeamMatchPlayerWhereInput
    orderBy?: TeamMatchPlayerOrderByWithRelationInput | TeamMatchPlayerOrderByWithRelationInput[]
    cursor?: TeamMatchPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMatchPlayerScalarFieldEnum | TeamMatchPlayerScalarFieldEnum[]
  }

  /**
   * TeamMatch without action
   */
  export type TeamMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatch
     */
    select?: TeamMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatch
     */
    omit?: TeamMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchInclude<ExtArgs> | null
  }


  /**
   * Model TeamMatchPlayer
   */

  export type AggregateTeamMatchPlayer = {
    _count: TeamMatchPlayerCountAggregateOutputType | null
    _avg: TeamMatchPlayerAvgAggregateOutputType | null
    _sum: TeamMatchPlayerSumAggregateOutputType | null
    _min: TeamMatchPlayerMinAggregateOutputType | null
    _max: TeamMatchPlayerMaxAggregateOutputType | null
  }

  export type TeamMatchPlayerAvgAggregateOutputType = {
    runsScored: number | null
    ballsFaced: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
  }

  export type TeamMatchPlayerSumAggregateOutputType = {
    runsScored: number | null
    ballsFaced: number | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
  }

  export type TeamMatchPlayerMinAggregateOutputType = {
    id: string | null
    teamMatchId: string | null
    userId: string | null
    teamId: string | null
    runsScored: number | null
    ballsFaced: number | null
    wasDismissed: boolean | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
  }

  export type TeamMatchPlayerMaxAggregateOutputType = {
    id: string | null
    teamMatchId: string | null
    userId: string | null
    teamId: string | null
    runsScored: number | null
    ballsFaced: number | null
    wasDismissed: boolean | null
    oversBowled: number | null
    runsConceded: number | null
    wicketsTaken: number | null
    catchesTaken: number | null
  }

  export type TeamMatchPlayerCountAggregateOutputType = {
    id: number
    teamMatchId: number
    userId: number
    teamId: number
    runsScored: number
    ballsFaced: number
    wasDismissed: number
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    _all: number
  }


  export type TeamMatchPlayerAvgAggregateInputType = {
    runsScored?: true
    ballsFaced?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
  }

  export type TeamMatchPlayerSumAggregateInputType = {
    runsScored?: true
    ballsFaced?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
  }

  export type TeamMatchPlayerMinAggregateInputType = {
    id?: true
    teamMatchId?: true
    userId?: true
    teamId?: true
    runsScored?: true
    ballsFaced?: true
    wasDismissed?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
  }

  export type TeamMatchPlayerMaxAggregateInputType = {
    id?: true
    teamMatchId?: true
    userId?: true
    teamId?: true
    runsScored?: true
    ballsFaced?: true
    wasDismissed?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
  }

  export type TeamMatchPlayerCountAggregateInputType = {
    id?: true
    teamMatchId?: true
    userId?: true
    teamId?: true
    runsScored?: true
    ballsFaced?: true
    wasDismissed?: true
    oversBowled?: true
    runsConceded?: true
    wicketsTaken?: true
    catchesTaken?: true
    _all?: true
  }

  export type TeamMatchPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMatchPlayer to aggregate.
     */
    where?: TeamMatchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatchPlayers to fetch.
     */
    orderBy?: TeamMatchPlayerOrderByWithRelationInput | TeamMatchPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMatchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatchPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMatchPlayers
    **/
    _count?: true | TeamMatchPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMatchPlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMatchPlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMatchPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMatchPlayerMaxAggregateInputType
  }

  export type GetTeamMatchPlayerAggregateType<T extends TeamMatchPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMatchPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMatchPlayer[P]>
      : GetScalarType<T[P], AggregateTeamMatchPlayer[P]>
  }




  export type TeamMatchPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMatchPlayerWhereInput
    orderBy?: TeamMatchPlayerOrderByWithAggregationInput | TeamMatchPlayerOrderByWithAggregationInput[]
    by: TeamMatchPlayerScalarFieldEnum[] | TeamMatchPlayerScalarFieldEnum
    having?: TeamMatchPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMatchPlayerCountAggregateInputType | true
    _avg?: TeamMatchPlayerAvgAggregateInputType
    _sum?: TeamMatchPlayerSumAggregateInputType
    _min?: TeamMatchPlayerMinAggregateInputType
    _max?: TeamMatchPlayerMaxAggregateInputType
  }

  export type TeamMatchPlayerGroupByOutputType = {
    id: string
    teamMatchId: string
    userId: string
    teamId: string
    runsScored: number
    ballsFaced: number
    wasDismissed: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    _count: TeamMatchPlayerCountAggregateOutputType | null
    _avg: TeamMatchPlayerAvgAggregateOutputType | null
    _sum: TeamMatchPlayerSumAggregateOutputType | null
    _min: TeamMatchPlayerMinAggregateOutputType | null
    _max: TeamMatchPlayerMaxAggregateOutputType | null
  }

  type GetTeamMatchPlayerGroupByPayload<T extends TeamMatchPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMatchPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMatchPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMatchPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMatchPlayerGroupByOutputType[P]>
        }
      >
    >


  export type TeamMatchPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamMatchId?: boolean
    userId?: boolean
    teamId?: boolean
    runsScored?: boolean
    ballsFaced?: boolean
    wasDismissed?: boolean
    oversBowled?: boolean
    runsConceded?: boolean
    wicketsTaken?: boolean
    catchesTaken?: boolean
    teamMatch?: boolean | TeamMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMatchPlayer"]>



  export type TeamMatchPlayerSelectScalar = {
    id?: boolean
    teamMatchId?: boolean
    userId?: boolean
    teamId?: boolean
    runsScored?: boolean
    ballsFaced?: boolean
    wasDismissed?: boolean
    oversBowled?: boolean
    runsConceded?: boolean
    wicketsTaken?: boolean
    catchesTaken?: boolean
  }

  export type TeamMatchPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamMatchId" | "userId" | "teamId" | "runsScored" | "ballsFaced" | "wasDismissed" | "oversBowled" | "runsConceded" | "wicketsTaken" | "catchesTaken", ExtArgs["result"]["teamMatchPlayer"]>
  export type TeamMatchPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMatch?: boolean | TeamMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $TeamMatchPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMatchPlayer"
    objects: {
      teamMatch: Prisma.$TeamMatchPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamMatchId: string
      userId: string
      teamId: string
      runsScored: number
      ballsFaced: number
      wasDismissed: boolean
      oversBowled: number
      runsConceded: number
      wicketsTaken: number
      catchesTaken: number
    }, ExtArgs["result"]["teamMatchPlayer"]>
    composites: {}
  }

  type TeamMatchPlayerGetPayload<S extends boolean | null | undefined | TeamMatchPlayerDefaultArgs> = $Result.GetResult<Prisma.$TeamMatchPlayerPayload, S>

  type TeamMatchPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMatchPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMatchPlayerCountAggregateInputType | true
    }

  export interface TeamMatchPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMatchPlayer'], meta: { name: 'TeamMatchPlayer' } }
    /**
     * Find zero or one TeamMatchPlayer that matches the filter.
     * @param {TeamMatchPlayerFindUniqueArgs} args - Arguments to find a TeamMatchPlayer
     * @example
     * // Get one TeamMatchPlayer
     * const teamMatchPlayer = await prisma.teamMatchPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMatchPlayerFindUniqueArgs>(args: SelectSubset<T, TeamMatchPlayerFindUniqueArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMatchPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMatchPlayerFindUniqueOrThrowArgs} args - Arguments to find a TeamMatchPlayer
     * @example
     * // Get one TeamMatchPlayer
     * const teamMatchPlayer = await prisma.teamMatchPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMatchPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMatchPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMatchPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchPlayerFindFirstArgs} args - Arguments to find a TeamMatchPlayer
     * @example
     * // Get one TeamMatchPlayer
     * const teamMatchPlayer = await prisma.teamMatchPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMatchPlayerFindFirstArgs>(args?: SelectSubset<T, TeamMatchPlayerFindFirstArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMatchPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchPlayerFindFirstOrThrowArgs} args - Arguments to find a TeamMatchPlayer
     * @example
     * // Get one TeamMatchPlayer
     * const teamMatchPlayer = await prisma.teamMatchPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMatchPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMatchPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMatchPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMatchPlayers
     * const teamMatchPlayers = await prisma.teamMatchPlayer.findMany()
     * 
     * // Get first 10 TeamMatchPlayers
     * const teamMatchPlayers = await prisma.teamMatchPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMatchPlayerWithIdOnly = await prisma.teamMatchPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMatchPlayerFindManyArgs>(args?: SelectSubset<T, TeamMatchPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMatchPlayer.
     * @param {TeamMatchPlayerCreateArgs} args - Arguments to create a TeamMatchPlayer.
     * @example
     * // Create one TeamMatchPlayer
     * const TeamMatchPlayer = await prisma.teamMatchPlayer.create({
     *   data: {
     *     // ... data to create a TeamMatchPlayer
     *   }
     * })
     * 
     */
    create<T extends TeamMatchPlayerCreateArgs>(args: SelectSubset<T, TeamMatchPlayerCreateArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMatchPlayers.
     * @param {TeamMatchPlayerCreateManyArgs} args - Arguments to create many TeamMatchPlayers.
     * @example
     * // Create many TeamMatchPlayers
     * const teamMatchPlayer = await prisma.teamMatchPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMatchPlayerCreateManyArgs>(args?: SelectSubset<T, TeamMatchPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMatchPlayer.
     * @param {TeamMatchPlayerDeleteArgs} args - Arguments to delete one TeamMatchPlayer.
     * @example
     * // Delete one TeamMatchPlayer
     * const TeamMatchPlayer = await prisma.teamMatchPlayer.delete({
     *   where: {
     *     // ... filter to delete one TeamMatchPlayer
     *   }
     * })
     * 
     */
    delete<T extends TeamMatchPlayerDeleteArgs>(args: SelectSubset<T, TeamMatchPlayerDeleteArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMatchPlayer.
     * @param {TeamMatchPlayerUpdateArgs} args - Arguments to update one TeamMatchPlayer.
     * @example
     * // Update one TeamMatchPlayer
     * const teamMatchPlayer = await prisma.teamMatchPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMatchPlayerUpdateArgs>(args: SelectSubset<T, TeamMatchPlayerUpdateArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMatchPlayers.
     * @param {TeamMatchPlayerDeleteManyArgs} args - Arguments to filter TeamMatchPlayers to delete.
     * @example
     * // Delete a few TeamMatchPlayers
     * const { count } = await prisma.teamMatchPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMatchPlayerDeleteManyArgs>(args?: SelectSubset<T, TeamMatchPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMatchPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMatchPlayers
     * const teamMatchPlayer = await prisma.teamMatchPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMatchPlayerUpdateManyArgs>(args: SelectSubset<T, TeamMatchPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMatchPlayer.
     * @param {TeamMatchPlayerUpsertArgs} args - Arguments to update or create a TeamMatchPlayer.
     * @example
     * // Update or create a TeamMatchPlayer
     * const teamMatchPlayer = await prisma.teamMatchPlayer.upsert({
     *   create: {
     *     // ... data to create a TeamMatchPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMatchPlayer we want to update
     *   }
     * })
     */
    upsert<T extends TeamMatchPlayerUpsertArgs>(args: SelectSubset<T, TeamMatchPlayerUpsertArgs<ExtArgs>>): Prisma__TeamMatchPlayerClient<$Result.GetResult<Prisma.$TeamMatchPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMatchPlayers that matches the filter.
     * @param {TeamMatchPlayerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamMatchPlayer = await prisma.teamMatchPlayer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamMatchPlayerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamMatchPlayer.
     * @param {TeamMatchPlayerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamMatchPlayer = await prisma.teamMatchPlayer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamMatchPlayerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamMatchPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchPlayerCountArgs} args - Arguments to filter TeamMatchPlayers to count.
     * @example
     * // Count the number of TeamMatchPlayers
     * const count = await prisma.teamMatchPlayer.count({
     *   where: {
     *     // ... the filter for the TeamMatchPlayers we want to count
     *   }
     * })
    **/
    count<T extends TeamMatchPlayerCountArgs>(
      args?: Subset<T, TeamMatchPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMatchPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMatchPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMatchPlayerAggregateArgs>(args: Subset<T, TeamMatchPlayerAggregateArgs>): Prisma.PrismaPromise<GetTeamMatchPlayerAggregateType<T>>

    /**
     * Group by TeamMatchPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMatchPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMatchPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMatchPlayerGroupByArgs['orderBy'] }
        : { orderBy?: TeamMatchPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMatchPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMatchPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMatchPlayer model
   */
  readonly fields: TeamMatchPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMatchPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMatchPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teamMatch<T extends TeamMatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamMatchDefaultArgs<ExtArgs>>): Prisma__TeamMatchClient<$Result.GetResult<Prisma.$TeamMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMatchPlayer model
   */
  interface TeamMatchPlayerFieldRefs {
    readonly id: FieldRef<"TeamMatchPlayer", 'String'>
    readonly teamMatchId: FieldRef<"TeamMatchPlayer", 'String'>
    readonly userId: FieldRef<"TeamMatchPlayer", 'String'>
    readonly teamId: FieldRef<"TeamMatchPlayer", 'String'>
    readonly runsScored: FieldRef<"TeamMatchPlayer", 'Int'>
    readonly ballsFaced: FieldRef<"TeamMatchPlayer", 'Int'>
    readonly wasDismissed: FieldRef<"TeamMatchPlayer", 'Boolean'>
    readonly oversBowled: FieldRef<"TeamMatchPlayer", 'Float'>
    readonly runsConceded: FieldRef<"TeamMatchPlayer", 'Int'>
    readonly wicketsTaken: FieldRef<"TeamMatchPlayer", 'Int'>
    readonly catchesTaken: FieldRef<"TeamMatchPlayer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeamMatchPlayer findUnique
   */
  export type TeamMatchPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatchPlayer to fetch.
     */
    where: TeamMatchPlayerWhereUniqueInput
  }

  /**
   * TeamMatchPlayer findUniqueOrThrow
   */
  export type TeamMatchPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatchPlayer to fetch.
     */
    where: TeamMatchPlayerWhereUniqueInput
  }

  /**
   * TeamMatchPlayer findFirst
   */
  export type TeamMatchPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatchPlayer to fetch.
     */
    where?: TeamMatchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatchPlayers to fetch.
     */
    orderBy?: TeamMatchPlayerOrderByWithRelationInput | TeamMatchPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMatchPlayers.
     */
    cursor?: TeamMatchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatchPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMatchPlayers.
     */
    distinct?: TeamMatchPlayerScalarFieldEnum | TeamMatchPlayerScalarFieldEnum[]
  }

  /**
   * TeamMatchPlayer findFirstOrThrow
   */
  export type TeamMatchPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatchPlayer to fetch.
     */
    where?: TeamMatchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatchPlayers to fetch.
     */
    orderBy?: TeamMatchPlayerOrderByWithRelationInput | TeamMatchPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMatchPlayers.
     */
    cursor?: TeamMatchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatchPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMatchPlayers.
     */
    distinct?: TeamMatchPlayerScalarFieldEnum | TeamMatchPlayerScalarFieldEnum[]
  }

  /**
   * TeamMatchPlayer findMany
   */
  export type TeamMatchPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * Filter, which TeamMatchPlayers to fetch.
     */
    where?: TeamMatchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMatchPlayers to fetch.
     */
    orderBy?: TeamMatchPlayerOrderByWithRelationInput | TeamMatchPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMatchPlayers.
     */
    cursor?: TeamMatchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMatchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMatchPlayers.
     */
    skip?: number
    distinct?: TeamMatchPlayerScalarFieldEnum | TeamMatchPlayerScalarFieldEnum[]
  }

  /**
   * TeamMatchPlayer create
   */
  export type TeamMatchPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMatchPlayer.
     */
    data: XOR<TeamMatchPlayerCreateInput, TeamMatchPlayerUncheckedCreateInput>
  }

  /**
   * TeamMatchPlayer createMany
   */
  export type TeamMatchPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMatchPlayers.
     */
    data: TeamMatchPlayerCreateManyInput | TeamMatchPlayerCreateManyInput[]
  }

  /**
   * TeamMatchPlayer update
   */
  export type TeamMatchPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMatchPlayer.
     */
    data: XOR<TeamMatchPlayerUpdateInput, TeamMatchPlayerUncheckedUpdateInput>
    /**
     * Choose, which TeamMatchPlayer to update.
     */
    where: TeamMatchPlayerWhereUniqueInput
  }

  /**
   * TeamMatchPlayer updateMany
   */
  export type TeamMatchPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMatchPlayers.
     */
    data: XOR<TeamMatchPlayerUpdateManyMutationInput, TeamMatchPlayerUncheckedUpdateManyInput>
    /**
     * Filter which TeamMatchPlayers to update
     */
    where?: TeamMatchPlayerWhereInput
    /**
     * Limit how many TeamMatchPlayers to update.
     */
    limit?: number
  }

  /**
   * TeamMatchPlayer upsert
   */
  export type TeamMatchPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMatchPlayer to update in case it exists.
     */
    where: TeamMatchPlayerWhereUniqueInput
    /**
     * In case the TeamMatchPlayer found by the `where` argument doesn't exist, create a new TeamMatchPlayer with this data.
     */
    create: XOR<TeamMatchPlayerCreateInput, TeamMatchPlayerUncheckedCreateInput>
    /**
     * In case the TeamMatchPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMatchPlayerUpdateInput, TeamMatchPlayerUncheckedUpdateInput>
  }

  /**
   * TeamMatchPlayer delete
   */
  export type TeamMatchPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
    /**
     * Filter which TeamMatchPlayer to delete.
     */
    where: TeamMatchPlayerWhereUniqueInput
  }

  /**
   * TeamMatchPlayer deleteMany
   */
  export type TeamMatchPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMatchPlayers to delete
     */
    where?: TeamMatchPlayerWhereInput
    /**
     * Limit how many TeamMatchPlayers to delete.
     */
    limit?: number
  }

  /**
   * TeamMatchPlayer findRaw
   */
  export type TeamMatchPlayerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMatchPlayer aggregateRaw
   */
  export type TeamMatchPlayerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamMatchPlayer without action
   */
  export type TeamMatchPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMatchPlayer
     */
    select?: TeamMatchPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMatchPlayer
     */
    omit?: TeamMatchPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMatchPlayerInclude<ExtArgs> | null
  }


  /**
   * Model TeamStatistics
   */

  export type AggregateTeamStatistics = {
    _count: TeamStatisticsCountAggregateOutputType | null
    _avg: TeamStatisticsAvgAggregateOutputType | null
    _sum: TeamStatisticsSumAggregateOutputType | null
    _min: TeamStatisticsMinAggregateOutputType | null
    _max: TeamStatisticsMaxAggregateOutputType | null
  }

  export type TeamStatisticsAvgAggregateOutputType = {
    matchesPlayed: number | null
    matchesWon: number | null
    matchesLost: number | null
    matchesDrawn: number | null
    winRatio: number | null
    topRunScorerRuns: number | null
    topWicketTakerWickets: number | null
    bestStrikeRate: number | null
    bestEconomy: number | null
    mostManOfTheMatchAwards: number | null
  }

  export type TeamStatisticsSumAggregateOutputType = {
    matchesPlayed: number | null
    matchesWon: number | null
    matchesLost: number | null
    matchesDrawn: number | null
    winRatio: number | null
    topRunScorerRuns: number | null
    topWicketTakerWickets: number | null
    bestStrikeRate: number | null
    bestEconomy: number | null
    mostManOfTheMatchAwards: number | null
  }

  export type TeamStatisticsMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    matchesPlayed: number | null
    matchesWon: number | null
    matchesLost: number | null
    matchesDrawn: number | null
    winRatio: number | null
    topRunScorerId: string | null
    topRunScorerRuns: number | null
    topWicketTakerId: string | null
    topWicketTakerWickets: number | null
    bestStrikeRatePlayerId: string | null
    bestStrikeRate: number | null
    bestEconomyPlayerId: string | null
    bestEconomy: number | null
    mostManOfTheMatchPlayerId: string | null
    mostManOfTheMatchAwards: number | null
    updatedAt: Date | null
  }

  export type TeamStatisticsMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    matchesPlayed: number | null
    matchesWon: number | null
    matchesLost: number | null
    matchesDrawn: number | null
    winRatio: number | null
    topRunScorerId: string | null
    topRunScorerRuns: number | null
    topWicketTakerId: string | null
    topWicketTakerWickets: number | null
    bestStrikeRatePlayerId: string | null
    bestStrikeRate: number | null
    bestEconomyPlayerId: string | null
    bestEconomy: number | null
    mostManOfTheMatchPlayerId: string | null
    mostManOfTheMatchAwards: number | null
    updatedAt: Date | null
  }

  export type TeamStatisticsCountAggregateOutputType = {
    id: number
    teamId: number
    matchesPlayed: number
    matchesWon: number
    matchesLost: number
    matchesDrawn: number
    winRatio: number
    topRunScorerId: number
    topRunScorerRuns: number
    topWicketTakerId: number
    topWicketTakerWickets: number
    bestStrikeRatePlayerId: number
    bestStrikeRate: number
    bestEconomyPlayerId: number
    bestEconomy: number
    mostManOfTheMatchPlayerId: number
    mostManOfTheMatchAwards: number
    updatedAt: number
    _all: number
  }


  export type TeamStatisticsAvgAggregateInputType = {
    matchesPlayed?: true
    matchesWon?: true
    matchesLost?: true
    matchesDrawn?: true
    winRatio?: true
    topRunScorerRuns?: true
    topWicketTakerWickets?: true
    bestStrikeRate?: true
    bestEconomy?: true
    mostManOfTheMatchAwards?: true
  }

  export type TeamStatisticsSumAggregateInputType = {
    matchesPlayed?: true
    matchesWon?: true
    matchesLost?: true
    matchesDrawn?: true
    winRatio?: true
    topRunScorerRuns?: true
    topWicketTakerWickets?: true
    bestStrikeRate?: true
    bestEconomy?: true
    mostManOfTheMatchAwards?: true
  }

  export type TeamStatisticsMinAggregateInputType = {
    id?: true
    teamId?: true
    matchesPlayed?: true
    matchesWon?: true
    matchesLost?: true
    matchesDrawn?: true
    winRatio?: true
    topRunScorerId?: true
    topRunScorerRuns?: true
    topWicketTakerId?: true
    topWicketTakerWickets?: true
    bestStrikeRatePlayerId?: true
    bestStrikeRate?: true
    bestEconomyPlayerId?: true
    bestEconomy?: true
    mostManOfTheMatchPlayerId?: true
    mostManOfTheMatchAwards?: true
    updatedAt?: true
  }

  export type TeamStatisticsMaxAggregateInputType = {
    id?: true
    teamId?: true
    matchesPlayed?: true
    matchesWon?: true
    matchesLost?: true
    matchesDrawn?: true
    winRatio?: true
    topRunScorerId?: true
    topRunScorerRuns?: true
    topWicketTakerId?: true
    topWicketTakerWickets?: true
    bestStrikeRatePlayerId?: true
    bestStrikeRate?: true
    bestEconomyPlayerId?: true
    bestEconomy?: true
    mostManOfTheMatchPlayerId?: true
    mostManOfTheMatchAwards?: true
    updatedAt?: true
  }

  export type TeamStatisticsCountAggregateInputType = {
    id?: true
    teamId?: true
    matchesPlayed?: true
    matchesWon?: true
    matchesLost?: true
    matchesDrawn?: true
    winRatio?: true
    topRunScorerId?: true
    topRunScorerRuns?: true
    topWicketTakerId?: true
    topWicketTakerWickets?: true
    bestStrikeRatePlayerId?: true
    bestStrikeRate?: true
    bestEconomyPlayerId?: true
    bestEconomy?: true
    mostManOfTheMatchPlayerId?: true
    mostManOfTheMatchAwards?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamStatisticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamStatistics to aggregate.
     */
    where?: TeamStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamStatistics to fetch.
     */
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamStatistics
    **/
    _count?: true | TeamStatisticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamStatisticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamStatisticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamStatisticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamStatisticsMaxAggregateInputType
  }

  export type GetTeamStatisticsAggregateType<T extends TeamStatisticsAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamStatistics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamStatistics[P]>
      : GetScalarType<T[P], AggregateTeamStatistics[P]>
  }




  export type TeamStatisticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamStatisticsWhereInput
    orderBy?: TeamStatisticsOrderByWithAggregationInput | TeamStatisticsOrderByWithAggregationInput[]
    by: TeamStatisticsScalarFieldEnum[] | TeamStatisticsScalarFieldEnum
    having?: TeamStatisticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamStatisticsCountAggregateInputType | true
    _avg?: TeamStatisticsAvgAggregateInputType
    _sum?: TeamStatisticsSumAggregateInputType
    _min?: TeamStatisticsMinAggregateInputType
    _max?: TeamStatisticsMaxAggregateInputType
  }

  export type TeamStatisticsGroupByOutputType = {
    id: string
    teamId: string
    matchesPlayed: number
    matchesWon: number
    matchesLost: number
    matchesDrawn: number
    winRatio: number
    topRunScorerId: string | null
    topRunScorerRuns: number
    topWicketTakerId: string | null
    topWicketTakerWickets: number
    bestStrikeRatePlayerId: string | null
    bestStrikeRate: number
    bestEconomyPlayerId: string | null
    bestEconomy: number
    mostManOfTheMatchPlayerId: string | null
    mostManOfTheMatchAwards: number
    updatedAt: Date
    _count: TeamStatisticsCountAggregateOutputType | null
    _avg: TeamStatisticsAvgAggregateOutputType | null
    _sum: TeamStatisticsSumAggregateOutputType | null
    _min: TeamStatisticsMinAggregateOutputType | null
    _max: TeamStatisticsMaxAggregateOutputType | null
  }

  type GetTeamStatisticsGroupByPayload<T extends TeamStatisticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamStatisticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamStatisticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamStatisticsGroupByOutputType[P]>
            : GetScalarType<T[P], TeamStatisticsGroupByOutputType[P]>
        }
      >
    >


  export type TeamStatisticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    matchesPlayed?: boolean
    matchesWon?: boolean
    matchesLost?: boolean
    matchesDrawn?: boolean
    winRatio?: boolean
    topRunScorerId?: boolean
    topRunScorerRuns?: boolean
    topWicketTakerId?: boolean
    topWicketTakerWickets?: boolean
    bestStrikeRatePlayerId?: boolean
    bestStrikeRate?: boolean
    bestEconomyPlayerId?: boolean
    bestEconomy?: boolean
    mostManOfTheMatchPlayerId?: boolean
    mostManOfTheMatchAwards?: boolean
    updatedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    topRunScorer?: boolean | TeamStatistics$topRunScorerArgs<ExtArgs>
    topWicketTaker?: boolean | TeamStatistics$topWicketTakerArgs<ExtArgs>
    bestStrikeRatePlayer?: boolean | TeamStatistics$bestStrikeRatePlayerArgs<ExtArgs>
    bestEconomyPlayer?: boolean | TeamStatistics$bestEconomyPlayerArgs<ExtArgs>
    mostManOfTheMatchPlayer?: boolean | TeamStatistics$mostManOfTheMatchPlayerArgs<ExtArgs>
  }, ExtArgs["result"]["teamStatistics"]>



  export type TeamStatisticsSelectScalar = {
    id?: boolean
    teamId?: boolean
    matchesPlayed?: boolean
    matchesWon?: boolean
    matchesLost?: boolean
    matchesDrawn?: boolean
    winRatio?: boolean
    topRunScorerId?: boolean
    topRunScorerRuns?: boolean
    topWicketTakerId?: boolean
    topWicketTakerWickets?: boolean
    bestStrikeRatePlayerId?: boolean
    bestStrikeRate?: boolean
    bestEconomyPlayerId?: boolean
    bestEconomy?: boolean
    mostManOfTheMatchPlayerId?: boolean
    mostManOfTheMatchAwards?: boolean
    updatedAt?: boolean
  }

  export type TeamStatisticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "matchesPlayed" | "matchesWon" | "matchesLost" | "matchesDrawn" | "winRatio" | "topRunScorerId" | "topRunScorerRuns" | "topWicketTakerId" | "topWicketTakerWickets" | "bestStrikeRatePlayerId" | "bestStrikeRate" | "bestEconomyPlayerId" | "bestEconomy" | "mostManOfTheMatchPlayerId" | "mostManOfTheMatchAwards" | "updatedAt", ExtArgs["result"]["teamStatistics"]>
  export type TeamStatisticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    topRunScorer?: boolean | TeamStatistics$topRunScorerArgs<ExtArgs>
    topWicketTaker?: boolean | TeamStatistics$topWicketTakerArgs<ExtArgs>
    bestStrikeRatePlayer?: boolean | TeamStatistics$bestStrikeRatePlayerArgs<ExtArgs>
    bestEconomyPlayer?: boolean | TeamStatistics$bestEconomyPlayerArgs<ExtArgs>
    mostManOfTheMatchPlayer?: boolean | TeamStatistics$mostManOfTheMatchPlayerArgs<ExtArgs>
  }

  export type $TeamStatisticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamStatistics"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      topRunScorer: Prisma.$UserPayload<ExtArgs> | null
      topWicketTaker: Prisma.$UserPayload<ExtArgs> | null
      bestStrikeRatePlayer: Prisma.$UserPayload<ExtArgs> | null
      bestEconomyPlayer: Prisma.$UserPayload<ExtArgs> | null
      mostManOfTheMatchPlayer: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      matchesPlayed: number
      matchesWon: number
      matchesLost: number
      matchesDrawn: number
      winRatio: number
      topRunScorerId: string | null
      topRunScorerRuns: number
      topWicketTakerId: string | null
      topWicketTakerWickets: number
      bestStrikeRatePlayerId: string | null
      bestStrikeRate: number
      bestEconomyPlayerId: string | null
      bestEconomy: number
      mostManOfTheMatchPlayerId: string | null
      mostManOfTheMatchAwards: number
      updatedAt: Date
    }, ExtArgs["result"]["teamStatistics"]>
    composites: {}
  }

  type TeamStatisticsGetPayload<S extends boolean | null | undefined | TeamStatisticsDefaultArgs> = $Result.GetResult<Prisma.$TeamStatisticsPayload, S>

  type TeamStatisticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamStatisticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamStatisticsCountAggregateInputType | true
    }

  export interface TeamStatisticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamStatistics'], meta: { name: 'TeamStatistics' } }
    /**
     * Find zero or one TeamStatistics that matches the filter.
     * @param {TeamStatisticsFindUniqueArgs} args - Arguments to find a TeamStatistics
     * @example
     * // Get one TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamStatisticsFindUniqueArgs>(args: SelectSubset<T, TeamStatisticsFindUniqueArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamStatistics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamStatisticsFindUniqueOrThrowArgs} args - Arguments to find a TeamStatistics
     * @example
     * // Get one TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamStatisticsFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamStatisticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamStatisticsFindFirstArgs} args - Arguments to find a TeamStatistics
     * @example
     * // Get one TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamStatisticsFindFirstArgs>(args?: SelectSubset<T, TeamStatisticsFindFirstArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamStatistics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamStatisticsFindFirstOrThrowArgs} args - Arguments to find a TeamStatistics
     * @example
     * // Get one TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamStatisticsFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamStatisticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamStatisticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.findMany()
     * 
     * // Get first 10 TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamStatisticsWithIdOnly = await prisma.teamStatistics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamStatisticsFindManyArgs>(args?: SelectSubset<T, TeamStatisticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamStatistics.
     * @param {TeamStatisticsCreateArgs} args - Arguments to create a TeamStatistics.
     * @example
     * // Create one TeamStatistics
     * const TeamStatistics = await prisma.teamStatistics.create({
     *   data: {
     *     // ... data to create a TeamStatistics
     *   }
     * })
     * 
     */
    create<T extends TeamStatisticsCreateArgs>(args: SelectSubset<T, TeamStatisticsCreateArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamStatistics.
     * @param {TeamStatisticsCreateManyArgs} args - Arguments to create many TeamStatistics.
     * @example
     * // Create many TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamStatisticsCreateManyArgs>(args?: SelectSubset<T, TeamStatisticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamStatistics.
     * @param {TeamStatisticsDeleteArgs} args - Arguments to delete one TeamStatistics.
     * @example
     * // Delete one TeamStatistics
     * const TeamStatistics = await prisma.teamStatistics.delete({
     *   where: {
     *     // ... filter to delete one TeamStatistics
     *   }
     * })
     * 
     */
    delete<T extends TeamStatisticsDeleteArgs>(args: SelectSubset<T, TeamStatisticsDeleteArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamStatistics.
     * @param {TeamStatisticsUpdateArgs} args - Arguments to update one TeamStatistics.
     * @example
     * // Update one TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamStatisticsUpdateArgs>(args: SelectSubset<T, TeamStatisticsUpdateArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamStatistics.
     * @param {TeamStatisticsDeleteManyArgs} args - Arguments to filter TeamStatistics to delete.
     * @example
     * // Delete a few TeamStatistics
     * const { count } = await prisma.teamStatistics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamStatisticsDeleteManyArgs>(args?: SelectSubset<T, TeamStatisticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamStatisticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamStatisticsUpdateManyArgs>(args: SelectSubset<T, TeamStatisticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamStatistics.
     * @param {TeamStatisticsUpsertArgs} args - Arguments to update or create a TeamStatistics.
     * @example
     * // Update or create a TeamStatistics
     * const teamStatistics = await prisma.teamStatistics.upsert({
     *   create: {
     *     // ... data to create a TeamStatistics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamStatistics we want to update
     *   }
     * })
     */
    upsert<T extends TeamStatisticsUpsertArgs>(args: SelectSubset<T, TeamStatisticsUpsertArgs<ExtArgs>>): Prisma__TeamStatisticsClient<$Result.GetResult<Prisma.$TeamStatisticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamStatistics that matches the filter.
     * @param {TeamStatisticsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamStatistics = await prisma.teamStatistics.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TeamStatisticsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamStatistics.
     * @param {TeamStatisticsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamStatistics = await prisma.teamStatistics.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TeamStatisticsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TeamStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamStatisticsCountArgs} args - Arguments to filter TeamStatistics to count.
     * @example
     * // Count the number of TeamStatistics
     * const count = await prisma.teamStatistics.count({
     *   where: {
     *     // ... the filter for the TeamStatistics we want to count
     *   }
     * })
    **/
    count<T extends TeamStatisticsCountArgs>(
      args?: Subset<T, TeamStatisticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamStatisticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamStatisticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamStatisticsAggregateArgs>(args: Subset<T, TeamStatisticsAggregateArgs>): Prisma.PrismaPromise<GetTeamStatisticsAggregateType<T>>

    /**
     * Group by TeamStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamStatisticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamStatisticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamStatisticsGroupByArgs['orderBy'] }
        : { orderBy?: TeamStatisticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamStatisticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamStatisticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamStatistics model
   */
  readonly fields: TeamStatisticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamStatistics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamStatisticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    topRunScorer<T extends TeamStatistics$topRunScorerArgs<ExtArgs> = {}>(args?: Subset<T, TeamStatistics$topRunScorerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    topWicketTaker<T extends TeamStatistics$topWicketTakerArgs<ExtArgs> = {}>(args?: Subset<T, TeamStatistics$topWicketTakerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bestStrikeRatePlayer<T extends TeamStatistics$bestStrikeRatePlayerArgs<ExtArgs> = {}>(args?: Subset<T, TeamStatistics$bestStrikeRatePlayerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bestEconomyPlayer<T extends TeamStatistics$bestEconomyPlayerArgs<ExtArgs> = {}>(args?: Subset<T, TeamStatistics$bestEconomyPlayerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mostManOfTheMatchPlayer<T extends TeamStatistics$mostManOfTheMatchPlayerArgs<ExtArgs> = {}>(args?: Subset<T, TeamStatistics$mostManOfTheMatchPlayerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamStatistics model
   */
  interface TeamStatisticsFieldRefs {
    readonly id: FieldRef<"TeamStatistics", 'String'>
    readonly teamId: FieldRef<"TeamStatistics", 'String'>
    readonly matchesPlayed: FieldRef<"TeamStatistics", 'Int'>
    readonly matchesWon: FieldRef<"TeamStatistics", 'Int'>
    readonly matchesLost: FieldRef<"TeamStatistics", 'Int'>
    readonly matchesDrawn: FieldRef<"TeamStatistics", 'Int'>
    readonly winRatio: FieldRef<"TeamStatistics", 'Float'>
    readonly topRunScorerId: FieldRef<"TeamStatistics", 'String'>
    readonly topRunScorerRuns: FieldRef<"TeamStatistics", 'Int'>
    readonly topWicketTakerId: FieldRef<"TeamStatistics", 'String'>
    readonly topWicketTakerWickets: FieldRef<"TeamStatistics", 'Int'>
    readonly bestStrikeRatePlayerId: FieldRef<"TeamStatistics", 'String'>
    readonly bestStrikeRate: FieldRef<"TeamStatistics", 'Float'>
    readonly bestEconomyPlayerId: FieldRef<"TeamStatistics", 'String'>
    readonly bestEconomy: FieldRef<"TeamStatistics", 'Float'>
    readonly mostManOfTheMatchPlayerId: FieldRef<"TeamStatistics", 'String'>
    readonly mostManOfTheMatchAwards: FieldRef<"TeamStatistics", 'Int'>
    readonly updatedAt: FieldRef<"TeamStatistics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamStatistics findUnique
   */
  export type TeamStatisticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which TeamStatistics to fetch.
     */
    where: TeamStatisticsWhereUniqueInput
  }

  /**
   * TeamStatistics findUniqueOrThrow
   */
  export type TeamStatisticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which TeamStatistics to fetch.
     */
    where: TeamStatisticsWhereUniqueInput
  }

  /**
   * TeamStatistics findFirst
   */
  export type TeamStatisticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which TeamStatistics to fetch.
     */
    where?: TeamStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamStatistics to fetch.
     */
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamStatistics.
     */
    cursor?: TeamStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamStatistics.
     */
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * TeamStatistics findFirstOrThrow
   */
  export type TeamStatisticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which TeamStatistics to fetch.
     */
    where?: TeamStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamStatistics to fetch.
     */
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamStatistics.
     */
    cursor?: TeamStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamStatistics.
     */
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * TeamStatistics findMany
   */
  export type TeamStatisticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * Filter, which TeamStatistics to fetch.
     */
    where?: TeamStatisticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamStatistics to fetch.
     */
    orderBy?: TeamStatisticsOrderByWithRelationInput | TeamStatisticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamStatistics.
     */
    cursor?: TeamStatisticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamStatistics.
     */
    skip?: number
    distinct?: TeamStatisticsScalarFieldEnum | TeamStatisticsScalarFieldEnum[]
  }

  /**
   * TeamStatistics create
   */
  export type TeamStatisticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamStatistics.
     */
    data: XOR<TeamStatisticsCreateInput, TeamStatisticsUncheckedCreateInput>
  }

  /**
   * TeamStatistics createMany
   */
  export type TeamStatisticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamStatistics.
     */
    data: TeamStatisticsCreateManyInput | TeamStatisticsCreateManyInput[]
  }

  /**
   * TeamStatistics update
   */
  export type TeamStatisticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamStatistics.
     */
    data: XOR<TeamStatisticsUpdateInput, TeamStatisticsUncheckedUpdateInput>
    /**
     * Choose, which TeamStatistics to update.
     */
    where: TeamStatisticsWhereUniqueInput
  }

  /**
   * TeamStatistics updateMany
   */
  export type TeamStatisticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamStatistics.
     */
    data: XOR<TeamStatisticsUpdateManyMutationInput, TeamStatisticsUncheckedUpdateManyInput>
    /**
     * Filter which TeamStatistics to update
     */
    where?: TeamStatisticsWhereInput
    /**
     * Limit how many TeamStatistics to update.
     */
    limit?: number
  }

  /**
   * TeamStatistics upsert
   */
  export type TeamStatisticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamStatistics to update in case it exists.
     */
    where: TeamStatisticsWhereUniqueInput
    /**
     * In case the TeamStatistics found by the `where` argument doesn't exist, create a new TeamStatistics with this data.
     */
    create: XOR<TeamStatisticsCreateInput, TeamStatisticsUncheckedCreateInput>
    /**
     * In case the TeamStatistics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamStatisticsUpdateInput, TeamStatisticsUncheckedUpdateInput>
  }

  /**
   * TeamStatistics delete
   */
  export type TeamStatisticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
    /**
     * Filter which TeamStatistics to delete.
     */
    where: TeamStatisticsWhereUniqueInput
  }

  /**
   * TeamStatistics deleteMany
   */
  export type TeamStatisticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamStatistics to delete
     */
    where?: TeamStatisticsWhereInput
    /**
     * Limit how many TeamStatistics to delete.
     */
    limit?: number
  }

  /**
   * TeamStatistics findRaw
   */
  export type TeamStatisticsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamStatistics aggregateRaw
   */
  export type TeamStatisticsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TeamStatistics.topRunScorer
   */
  export type TeamStatistics$topRunScorerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TeamStatistics.topWicketTaker
   */
  export type TeamStatistics$topWicketTakerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TeamStatistics.bestStrikeRatePlayer
   */
  export type TeamStatistics$bestStrikeRatePlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TeamStatistics.bestEconomyPlayer
   */
  export type TeamStatistics$bestEconomyPlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TeamStatistics.mostManOfTheMatchPlayer
   */
  export type TeamStatistics$mostManOfTheMatchPlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TeamStatistics without action
   */
  export type TeamStatisticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamStatistics
     */
    select?: TeamStatisticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamStatistics
     */
    omit?: TeamStatisticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamStatisticsInclude<ExtArgs> | null
  }


  /**
   * Model LocalMatch
   */

  export type AggregateLocalMatch = {
    _count: LocalMatchCountAggregateOutputType | null
    _avg: LocalMatchAvgAggregateOutputType | null
    _sum: LocalMatchSumAggregateOutputType | null
    _min: LocalMatchMinAggregateOutputType | null
    _max: LocalMatchMaxAggregateOutputType | null
  }

  export type LocalMatchAvgAggregateOutputType = {
    overs: number | null
    currentInnings: number | null
    currentOver: number | null
    currentBall: number | null
    myTeamScore: number | null
    myTeamWickets: number | null
    myTeamOvers: number | null
    opponentTeamScore: number | null
    opponentTeamWickets: number | null
    opponentTeamOvers: number | null
  }

  export type LocalMatchSumAggregateOutputType = {
    overs: number | null
    currentInnings: number | null
    currentOver: number | null
    currentBall: number | null
    myTeamScore: number | null
    myTeamWickets: number | null
    myTeamOvers: number | null
    opponentTeamScore: number | null
    opponentTeamWickets: number | null
    opponentTeamOvers: number | null
  }

  export type LocalMatchMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    matchName: string | null
    venue: string | null
    matchDate: Date | null
    overs: number | null
    myTeamName: string | null
    myTeamId: string | null
    opponentTeamName: string | null
    opponentTeamId: string | null
    allowSpectators: boolean | null
    isRoomMatch: boolean | null
    roomPassword: string | null
    status: $Enums.LocalMatchStatus | null
    currentInnings: number | null
    currentOver: number | null
    currentBall: number | null
    myTeamScore: number | null
    myTeamWickets: number | null
    myTeamOvers: number | null
    opponentTeamScore: number | null
    opponentTeamWickets: number | null
    opponentTeamOvers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalMatchMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    matchName: string | null
    venue: string | null
    matchDate: Date | null
    overs: number | null
    myTeamName: string | null
    myTeamId: string | null
    opponentTeamName: string | null
    opponentTeamId: string | null
    allowSpectators: boolean | null
    isRoomMatch: boolean | null
    roomPassword: string | null
    status: $Enums.LocalMatchStatus | null
    currentInnings: number | null
    currentOver: number | null
    currentBall: number | null
    myTeamScore: number | null
    myTeamWickets: number | null
    myTeamOvers: number | null
    opponentTeamScore: number | null
    opponentTeamWickets: number | null
    opponentTeamOvers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalMatchCountAggregateOutputType = {
    id: number
    creatorId: number
    matchName: number
    venue: number
    matchDate: number
    overs: number
    myTeamName: number
    myTeamId: number
    opponentTeamName: number
    opponentTeamId: number
    myTeamPlayers: number
    opponentTeamPlayers: number
    allowSpectators: number
    isRoomMatch: number
    roomPassword: number
    status: number
    currentInnings: number
    currentOver: number
    currentBall: number
    myTeamScore: number
    myTeamWickets: number
    myTeamOvers: number
    opponentTeamScore: number
    opponentTeamWickets: number
    opponentTeamOvers: number
    fullState: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocalMatchAvgAggregateInputType = {
    overs?: true
    currentInnings?: true
    currentOver?: true
    currentBall?: true
    myTeamScore?: true
    myTeamWickets?: true
    myTeamOvers?: true
    opponentTeamScore?: true
    opponentTeamWickets?: true
    opponentTeamOvers?: true
  }

  export type LocalMatchSumAggregateInputType = {
    overs?: true
    currentInnings?: true
    currentOver?: true
    currentBall?: true
    myTeamScore?: true
    myTeamWickets?: true
    myTeamOvers?: true
    opponentTeamScore?: true
    opponentTeamWickets?: true
    opponentTeamOvers?: true
  }

  export type LocalMatchMinAggregateInputType = {
    id?: true
    creatorId?: true
    matchName?: true
    venue?: true
    matchDate?: true
    overs?: true
    myTeamName?: true
    myTeamId?: true
    opponentTeamName?: true
    opponentTeamId?: true
    allowSpectators?: true
    isRoomMatch?: true
    roomPassword?: true
    status?: true
    currentInnings?: true
    currentOver?: true
    currentBall?: true
    myTeamScore?: true
    myTeamWickets?: true
    myTeamOvers?: true
    opponentTeamScore?: true
    opponentTeamWickets?: true
    opponentTeamOvers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalMatchMaxAggregateInputType = {
    id?: true
    creatorId?: true
    matchName?: true
    venue?: true
    matchDate?: true
    overs?: true
    myTeamName?: true
    myTeamId?: true
    opponentTeamName?: true
    opponentTeamId?: true
    allowSpectators?: true
    isRoomMatch?: true
    roomPassword?: true
    status?: true
    currentInnings?: true
    currentOver?: true
    currentBall?: true
    myTeamScore?: true
    myTeamWickets?: true
    myTeamOvers?: true
    opponentTeamScore?: true
    opponentTeamWickets?: true
    opponentTeamOvers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalMatchCountAggregateInputType = {
    id?: true
    creatorId?: true
    matchName?: true
    venue?: true
    matchDate?: true
    overs?: true
    myTeamName?: true
    myTeamId?: true
    opponentTeamName?: true
    opponentTeamId?: true
    myTeamPlayers?: true
    opponentTeamPlayers?: true
    allowSpectators?: true
    isRoomMatch?: true
    roomPassword?: true
    status?: true
    currentInnings?: true
    currentOver?: true
    currentBall?: true
    myTeamScore?: true
    myTeamWickets?: true
    myTeamOvers?: true
    opponentTeamScore?: true
    opponentTeamWickets?: true
    opponentTeamOvers?: true
    fullState?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocalMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalMatch to aggregate.
     */
    where?: LocalMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalMatches to fetch.
     */
    orderBy?: LocalMatchOrderByWithRelationInput | LocalMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalMatches
    **/
    _count?: true | LocalMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalMatchMaxAggregateInputType
  }

  export type GetLocalMatchAggregateType<T extends LocalMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalMatch[P]>
      : GetScalarType<T[P], AggregateLocalMatch[P]>
  }




  export type LocalMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalMatchWhereInput
    orderBy?: LocalMatchOrderByWithAggregationInput | LocalMatchOrderByWithAggregationInput[]
    by: LocalMatchScalarFieldEnum[] | LocalMatchScalarFieldEnum
    having?: LocalMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalMatchCountAggregateInputType | true
    _avg?: LocalMatchAvgAggregateInputType
    _sum?: LocalMatchSumAggregateInputType
    _min?: LocalMatchMinAggregateInputType
    _max?: LocalMatchMaxAggregateInputType
  }

  export type LocalMatchGroupByOutputType = {
    id: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date
    overs: number
    myTeamName: string | null
    myTeamId: string | null
    opponentTeamName: string | null
    opponentTeamId: string | null
    myTeamPlayers: JsonValue
    opponentTeamPlayers: JsonValue
    allowSpectators: boolean
    isRoomMatch: boolean
    roomPassword: string | null
    status: $Enums.LocalMatchStatus
    currentInnings: number
    currentOver: number
    currentBall: number
    myTeamScore: number
    myTeamWickets: number
    myTeamOvers: number
    opponentTeamScore: number
    opponentTeamWickets: number
    opponentTeamOvers: number
    fullState: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LocalMatchCountAggregateOutputType | null
    _avg: LocalMatchAvgAggregateOutputType | null
    _sum: LocalMatchSumAggregateOutputType | null
    _min: LocalMatchMinAggregateOutputType | null
    _max: LocalMatchMaxAggregateOutputType | null
  }

  type GetLocalMatchGroupByPayload<T extends LocalMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalMatchGroupByOutputType[P]>
            : GetScalarType<T[P], LocalMatchGroupByOutputType[P]>
        }
      >
    >


  export type LocalMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    matchName?: boolean
    venue?: boolean
    matchDate?: boolean
    overs?: boolean
    myTeamName?: boolean
    myTeamId?: boolean
    opponentTeamName?: boolean
    opponentTeamId?: boolean
    myTeamPlayers?: boolean
    opponentTeamPlayers?: boolean
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: boolean
    status?: boolean
    currentInnings?: boolean
    currentOver?: boolean
    currentBall?: boolean
    myTeamScore?: boolean
    myTeamWickets?: boolean
    myTeamOvers?: boolean
    opponentTeamScore?: boolean
    opponentTeamWickets?: boolean
    opponentTeamOvers?: boolean
    fullState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    myTeam?: boolean | LocalMatch$myTeamArgs<ExtArgs>
    opponentTeam?: boolean | LocalMatch$opponentTeamArgs<ExtArgs>
    spectators?: boolean | LocalMatch$spectatorsArgs<ExtArgs>
    overHistory?: boolean | LocalMatch$overHistoryArgs<ExtArgs>
    _count?: boolean | LocalMatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localMatch"]>



  export type LocalMatchSelectScalar = {
    id?: boolean
    creatorId?: boolean
    matchName?: boolean
    venue?: boolean
    matchDate?: boolean
    overs?: boolean
    myTeamName?: boolean
    myTeamId?: boolean
    opponentTeamName?: boolean
    opponentTeamId?: boolean
    myTeamPlayers?: boolean
    opponentTeamPlayers?: boolean
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: boolean
    status?: boolean
    currentInnings?: boolean
    currentOver?: boolean
    currentBall?: boolean
    myTeamScore?: boolean
    myTeamWickets?: boolean
    myTeamOvers?: boolean
    opponentTeamScore?: boolean
    opponentTeamWickets?: boolean
    opponentTeamOvers?: boolean
    fullState?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocalMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorId" | "matchName" | "venue" | "matchDate" | "overs" | "myTeamName" | "myTeamId" | "opponentTeamName" | "opponentTeamId" | "myTeamPlayers" | "opponentTeamPlayers" | "allowSpectators" | "isRoomMatch" | "roomPassword" | "status" | "currentInnings" | "currentOver" | "currentBall" | "myTeamScore" | "myTeamWickets" | "myTeamOvers" | "opponentTeamScore" | "opponentTeamWickets" | "opponentTeamOvers" | "fullState" | "createdAt" | "updatedAt", ExtArgs["result"]["localMatch"]>
  export type LocalMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    myTeam?: boolean | LocalMatch$myTeamArgs<ExtArgs>
    opponentTeam?: boolean | LocalMatch$opponentTeamArgs<ExtArgs>
    spectators?: boolean | LocalMatch$spectatorsArgs<ExtArgs>
    overHistory?: boolean | LocalMatch$overHistoryArgs<ExtArgs>
    _count?: boolean | LocalMatchCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LocalMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalMatch"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      myTeam: Prisma.$TeamPayload<ExtArgs> | null
      opponentTeam: Prisma.$TeamPayload<ExtArgs> | null
      spectators: Prisma.$MatchSpectatorPayload<ExtArgs>[]
      overHistory: Prisma.$OverHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      matchName: string
      venue: string
      matchDate: Date
      overs: number
      myTeamName: string | null
      myTeamId: string | null
      opponentTeamName: string | null
      opponentTeamId: string | null
      myTeamPlayers: Prisma.JsonValue
      opponentTeamPlayers: Prisma.JsonValue
      allowSpectators: boolean
      isRoomMatch: boolean
      roomPassword: string | null
      status: $Enums.LocalMatchStatus
      currentInnings: number
      currentOver: number
      currentBall: number
      myTeamScore: number
      myTeamWickets: number
      myTeamOvers: number
      opponentTeamScore: number
      opponentTeamWickets: number
      opponentTeamOvers: number
      fullState: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["localMatch"]>
    composites: {}
  }

  type LocalMatchGetPayload<S extends boolean | null | undefined | LocalMatchDefaultArgs> = $Result.GetResult<Prisma.$LocalMatchPayload, S>

  type LocalMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocalMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalMatchCountAggregateInputType | true
    }

  export interface LocalMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalMatch'], meta: { name: 'LocalMatch' } }
    /**
     * Find zero or one LocalMatch that matches the filter.
     * @param {LocalMatchFindUniqueArgs} args - Arguments to find a LocalMatch
     * @example
     * // Get one LocalMatch
     * const localMatch = await prisma.localMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalMatchFindUniqueArgs>(args: SelectSubset<T, LocalMatchFindUniqueArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocalMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocalMatchFindUniqueOrThrowArgs} args - Arguments to find a LocalMatch
     * @example
     * // Get one LocalMatch
     * const localMatch = await prisma.localMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalMatchFindFirstArgs} args - Arguments to find a LocalMatch
     * @example
     * // Get one LocalMatch
     * const localMatch = await prisma.localMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalMatchFindFirstArgs>(args?: SelectSubset<T, LocalMatchFindFirstArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalMatchFindFirstOrThrowArgs} args - Arguments to find a LocalMatch
     * @example
     * // Get one LocalMatch
     * const localMatch = await prisma.localMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocalMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalMatches
     * const localMatches = await prisma.localMatch.findMany()
     * 
     * // Get first 10 LocalMatches
     * const localMatches = await prisma.localMatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localMatchWithIdOnly = await prisma.localMatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalMatchFindManyArgs>(args?: SelectSubset<T, LocalMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocalMatch.
     * @param {LocalMatchCreateArgs} args - Arguments to create a LocalMatch.
     * @example
     * // Create one LocalMatch
     * const LocalMatch = await prisma.localMatch.create({
     *   data: {
     *     // ... data to create a LocalMatch
     *   }
     * })
     * 
     */
    create<T extends LocalMatchCreateArgs>(args: SelectSubset<T, LocalMatchCreateArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocalMatches.
     * @param {LocalMatchCreateManyArgs} args - Arguments to create many LocalMatches.
     * @example
     * // Create many LocalMatches
     * const localMatch = await prisma.localMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalMatchCreateManyArgs>(args?: SelectSubset<T, LocalMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocalMatch.
     * @param {LocalMatchDeleteArgs} args - Arguments to delete one LocalMatch.
     * @example
     * // Delete one LocalMatch
     * const LocalMatch = await prisma.localMatch.delete({
     *   where: {
     *     // ... filter to delete one LocalMatch
     *   }
     * })
     * 
     */
    delete<T extends LocalMatchDeleteArgs>(args: SelectSubset<T, LocalMatchDeleteArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocalMatch.
     * @param {LocalMatchUpdateArgs} args - Arguments to update one LocalMatch.
     * @example
     * // Update one LocalMatch
     * const localMatch = await prisma.localMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalMatchUpdateArgs>(args: SelectSubset<T, LocalMatchUpdateArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocalMatches.
     * @param {LocalMatchDeleteManyArgs} args - Arguments to filter LocalMatches to delete.
     * @example
     * // Delete a few LocalMatches
     * const { count } = await prisma.localMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalMatchDeleteManyArgs>(args?: SelectSubset<T, LocalMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalMatches
     * const localMatch = await prisma.localMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalMatchUpdateManyArgs>(args: SelectSubset<T, LocalMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocalMatch.
     * @param {LocalMatchUpsertArgs} args - Arguments to update or create a LocalMatch.
     * @example
     * // Update or create a LocalMatch
     * const localMatch = await prisma.localMatch.upsert({
     *   create: {
     *     // ... data to create a LocalMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalMatch we want to update
     *   }
     * })
     */
    upsert<T extends LocalMatchUpsertArgs>(args: SelectSubset<T, LocalMatchUpsertArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocalMatches that matches the filter.
     * @param {LocalMatchFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const localMatch = await prisma.localMatch.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LocalMatchFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LocalMatch.
     * @param {LocalMatchAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const localMatch = await prisma.localMatch.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LocalMatchAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LocalMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalMatchCountArgs} args - Arguments to filter LocalMatches to count.
     * @example
     * // Count the number of LocalMatches
     * const count = await prisma.localMatch.count({
     *   where: {
     *     // ... the filter for the LocalMatches we want to count
     *   }
     * })
    **/
    count<T extends LocalMatchCountArgs>(
      args?: Subset<T, LocalMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalMatchAggregateArgs>(args: Subset<T, LocalMatchAggregateArgs>): Prisma.PrismaPromise<GetLocalMatchAggregateType<T>>

    /**
     * Group by LocalMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalMatchGroupByArgs['orderBy'] }
        : { orderBy?: LocalMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalMatch model
   */
  readonly fields: LocalMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    myTeam<T extends LocalMatch$myTeamArgs<ExtArgs> = {}>(args?: Subset<T, LocalMatch$myTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    opponentTeam<T extends LocalMatch$opponentTeamArgs<ExtArgs> = {}>(args?: Subset<T, LocalMatch$opponentTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    spectators<T extends LocalMatch$spectatorsArgs<ExtArgs> = {}>(args?: Subset<T, LocalMatch$spectatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overHistory<T extends LocalMatch$overHistoryArgs<ExtArgs> = {}>(args?: Subset<T, LocalMatch$overHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalMatch model
   */
  interface LocalMatchFieldRefs {
    readonly id: FieldRef<"LocalMatch", 'String'>
    readonly creatorId: FieldRef<"LocalMatch", 'String'>
    readonly matchName: FieldRef<"LocalMatch", 'String'>
    readonly venue: FieldRef<"LocalMatch", 'String'>
    readonly matchDate: FieldRef<"LocalMatch", 'DateTime'>
    readonly overs: FieldRef<"LocalMatch", 'Int'>
    readonly myTeamName: FieldRef<"LocalMatch", 'String'>
    readonly myTeamId: FieldRef<"LocalMatch", 'String'>
    readonly opponentTeamName: FieldRef<"LocalMatch", 'String'>
    readonly opponentTeamId: FieldRef<"LocalMatch", 'String'>
    readonly myTeamPlayers: FieldRef<"LocalMatch", 'Json'>
    readonly opponentTeamPlayers: FieldRef<"LocalMatch", 'Json'>
    readonly allowSpectators: FieldRef<"LocalMatch", 'Boolean'>
    readonly isRoomMatch: FieldRef<"LocalMatch", 'Boolean'>
    readonly roomPassword: FieldRef<"LocalMatch", 'String'>
    readonly status: FieldRef<"LocalMatch", 'LocalMatchStatus'>
    readonly currentInnings: FieldRef<"LocalMatch", 'Int'>
    readonly currentOver: FieldRef<"LocalMatch", 'Int'>
    readonly currentBall: FieldRef<"LocalMatch", 'Int'>
    readonly myTeamScore: FieldRef<"LocalMatch", 'Int'>
    readonly myTeamWickets: FieldRef<"LocalMatch", 'Int'>
    readonly myTeamOvers: FieldRef<"LocalMatch", 'Float'>
    readonly opponentTeamScore: FieldRef<"LocalMatch", 'Int'>
    readonly opponentTeamWickets: FieldRef<"LocalMatch", 'Int'>
    readonly opponentTeamOvers: FieldRef<"LocalMatch", 'Float'>
    readonly fullState: FieldRef<"LocalMatch", 'Json'>
    readonly createdAt: FieldRef<"LocalMatch", 'DateTime'>
    readonly updatedAt: FieldRef<"LocalMatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalMatch findUnique
   */
  export type LocalMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalMatch to fetch.
     */
    where: LocalMatchWhereUniqueInput
  }

  /**
   * LocalMatch findUniqueOrThrow
   */
  export type LocalMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalMatch to fetch.
     */
    where: LocalMatchWhereUniqueInput
  }

  /**
   * LocalMatch findFirst
   */
  export type LocalMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalMatch to fetch.
     */
    where?: LocalMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalMatches to fetch.
     */
    orderBy?: LocalMatchOrderByWithRelationInput | LocalMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalMatches.
     */
    cursor?: LocalMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalMatches.
     */
    distinct?: LocalMatchScalarFieldEnum | LocalMatchScalarFieldEnum[]
  }

  /**
   * LocalMatch findFirstOrThrow
   */
  export type LocalMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalMatch to fetch.
     */
    where?: LocalMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalMatches to fetch.
     */
    orderBy?: LocalMatchOrderByWithRelationInput | LocalMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalMatches.
     */
    cursor?: LocalMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalMatches.
     */
    distinct?: LocalMatchScalarFieldEnum | LocalMatchScalarFieldEnum[]
  }

  /**
   * LocalMatch findMany
   */
  export type LocalMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * Filter, which LocalMatches to fetch.
     */
    where?: LocalMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalMatches to fetch.
     */
    orderBy?: LocalMatchOrderByWithRelationInput | LocalMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalMatches.
     */
    cursor?: LocalMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalMatches.
     */
    skip?: number
    distinct?: LocalMatchScalarFieldEnum | LocalMatchScalarFieldEnum[]
  }

  /**
   * LocalMatch create
   */
  export type LocalMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a LocalMatch.
     */
    data: XOR<LocalMatchCreateInput, LocalMatchUncheckedCreateInput>
  }

  /**
   * LocalMatch createMany
   */
  export type LocalMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalMatches.
     */
    data: LocalMatchCreateManyInput | LocalMatchCreateManyInput[]
  }

  /**
   * LocalMatch update
   */
  export type LocalMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a LocalMatch.
     */
    data: XOR<LocalMatchUpdateInput, LocalMatchUncheckedUpdateInput>
    /**
     * Choose, which LocalMatch to update.
     */
    where: LocalMatchWhereUniqueInput
  }

  /**
   * LocalMatch updateMany
   */
  export type LocalMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalMatches.
     */
    data: XOR<LocalMatchUpdateManyMutationInput, LocalMatchUncheckedUpdateManyInput>
    /**
     * Filter which LocalMatches to update
     */
    where?: LocalMatchWhereInput
    /**
     * Limit how many LocalMatches to update.
     */
    limit?: number
  }

  /**
   * LocalMatch upsert
   */
  export type LocalMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the LocalMatch to update in case it exists.
     */
    where: LocalMatchWhereUniqueInput
    /**
     * In case the LocalMatch found by the `where` argument doesn't exist, create a new LocalMatch with this data.
     */
    create: XOR<LocalMatchCreateInput, LocalMatchUncheckedCreateInput>
    /**
     * In case the LocalMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalMatchUpdateInput, LocalMatchUncheckedUpdateInput>
  }

  /**
   * LocalMatch delete
   */
  export type LocalMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
    /**
     * Filter which LocalMatch to delete.
     */
    where: LocalMatchWhereUniqueInput
  }

  /**
   * LocalMatch deleteMany
   */
  export type LocalMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalMatches to delete
     */
    where?: LocalMatchWhereInput
    /**
     * Limit how many LocalMatches to delete.
     */
    limit?: number
  }

  /**
   * LocalMatch findRaw
   */
  export type LocalMatchFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocalMatch aggregateRaw
   */
  export type LocalMatchAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocalMatch.myTeam
   */
  export type LocalMatch$myTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * LocalMatch.opponentTeam
   */
  export type LocalMatch$opponentTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * LocalMatch.spectators
   */
  export type LocalMatch$spectatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    where?: MatchSpectatorWhereInput
    orderBy?: MatchSpectatorOrderByWithRelationInput | MatchSpectatorOrderByWithRelationInput[]
    cursor?: MatchSpectatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchSpectatorScalarFieldEnum | MatchSpectatorScalarFieldEnum[]
  }

  /**
   * LocalMatch.overHistory
   */
  export type LocalMatch$overHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    where?: OverHistoryWhereInput
    orderBy?: OverHistoryOrderByWithRelationInput | OverHistoryOrderByWithRelationInput[]
    cursor?: OverHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OverHistoryScalarFieldEnum | OverHistoryScalarFieldEnum[]
  }

  /**
   * LocalMatch without action
   */
  export type LocalMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalMatch
     */
    select?: LocalMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalMatch
     */
    omit?: LocalMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalMatchInclude<ExtArgs> | null
  }


  /**
   * Model MatchSpectator
   */

  export type AggregateMatchSpectator = {
    _count: MatchSpectatorCountAggregateOutputType | null
    _min: MatchSpectatorMinAggregateOutputType | null
    _max: MatchSpectatorMaxAggregateOutputType | null
  }

  export type MatchSpectatorMinAggregateOutputType = {
    id: string | null
    localMatchId: string | null
    userId: string | null
    addedBy: string | null
    addedAt: Date | null
    notified: boolean | null
  }

  export type MatchSpectatorMaxAggregateOutputType = {
    id: string | null
    localMatchId: string | null
    userId: string | null
    addedBy: string | null
    addedAt: Date | null
    notified: boolean | null
  }

  export type MatchSpectatorCountAggregateOutputType = {
    id: number
    localMatchId: number
    userId: number
    addedBy: number
    addedAt: number
    notified: number
    _all: number
  }


  export type MatchSpectatorMinAggregateInputType = {
    id?: true
    localMatchId?: true
    userId?: true
    addedBy?: true
    addedAt?: true
    notified?: true
  }

  export type MatchSpectatorMaxAggregateInputType = {
    id?: true
    localMatchId?: true
    userId?: true
    addedBy?: true
    addedAt?: true
    notified?: true
  }

  export type MatchSpectatorCountAggregateInputType = {
    id?: true
    localMatchId?: true
    userId?: true
    addedBy?: true
    addedAt?: true
    notified?: true
    _all?: true
  }

  export type MatchSpectatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchSpectator to aggregate.
     */
    where?: MatchSpectatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSpectators to fetch.
     */
    orderBy?: MatchSpectatorOrderByWithRelationInput | MatchSpectatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchSpectatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSpectators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSpectators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchSpectators
    **/
    _count?: true | MatchSpectatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchSpectatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchSpectatorMaxAggregateInputType
  }

  export type GetMatchSpectatorAggregateType<T extends MatchSpectatorAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchSpectator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchSpectator[P]>
      : GetScalarType<T[P], AggregateMatchSpectator[P]>
  }




  export type MatchSpectatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSpectatorWhereInput
    orderBy?: MatchSpectatorOrderByWithAggregationInput | MatchSpectatorOrderByWithAggregationInput[]
    by: MatchSpectatorScalarFieldEnum[] | MatchSpectatorScalarFieldEnum
    having?: MatchSpectatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchSpectatorCountAggregateInputType | true
    _min?: MatchSpectatorMinAggregateInputType
    _max?: MatchSpectatorMaxAggregateInputType
  }

  export type MatchSpectatorGroupByOutputType = {
    id: string
    localMatchId: string
    userId: string
    addedBy: string
    addedAt: Date
    notified: boolean
    _count: MatchSpectatorCountAggregateOutputType | null
    _min: MatchSpectatorMinAggregateOutputType | null
    _max: MatchSpectatorMaxAggregateOutputType | null
  }

  type GetMatchSpectatorGroupByPayload<T extends MatchSpectatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchSpectatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchSpectatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchSpectatorGroupByOutputType[P]>
            : GetScalarType<T[P], MatchSpectatorGroupByOutputType[P]>
        }
      >
    >


  export type MatchSpectatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localMatchId?: boolean
    userId?: boolean
    addedBy?: boolean
    addedAt?: boolean
    notified?: boolean
    localMatch?: boolean | LocalMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchSpectator"]>



  export type MatchSpectatorSelectScalar = {
    id?: boolean
    localMatchId?: boolean
    userId?: boolean
    addedBy?: boolean
    addedAt?: boolean
    notified?: boolean
  }

  export type MatchSpectatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "localMatchId" | "userId" | "addedBy" | "addedAt" | "notified", ExtArgs["result"]["matchSpectator"]>
  export type MatchSpectatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localMatch?: boolean | LocalMatchDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    addedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MatchSpectatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchSpectator"
    objects: {
      localMatch: Prisma.$LocalMatchPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      addedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      localMatchId: string
      userId: string
      addedBy: string
      addedAt: Date
      notified: boolean
    }, ExtArgs["result"]["matchSpectator"]>
    composites: {}
  }

  type MatchSpectatorGetPayload<S extends boolean | null | undefined | MatchSpectatorDefaultArgs> = $Result.GetResult<Prisma.$MatchSpectatorPayload, S>

  type MatchSpectatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchSpectatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchSpectatorCountAggregateInputType | true
    }

  export interface MatchSpectatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchSpectator'], meta: { name: 'MatchSpectator' } }
    /**
     * Find zero or one MatchSpectator that matches the filter.
     * @param {MatchSpectatorFindUniqueArgs} args - Arguments to find a MatchSpectator
     * @example
     * // Get one MatchSpectator
     * const matchSpectator = await prisma.matchSpectator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchSpectatorFindUniqueArgs>(args: SelectSubset<T, MatchSpectatorFindUniqueArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchSpectator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchSpectatorFindUniqueOrThrowArgs} args - Arguments to find a MatchSpectator
     * @example
     * // Get one MatchSpectator
     * const matchSpectator = await prisma.matchSpectator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchSpectatorFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchSpectatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchSpectator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSpectatorFindFirstArgs} args - Arguments to find a MatchSpectator
     * @example
     * // Get one MatchSpectator
     * const matchSpectator = await prisma.matchSpectator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchSpectatorFindFirstArgs>(args?: SelectSubset<T, MatchSpectatorFindFirstArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchSpectator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSpectatorFindFirstOrThrowArgs} args - Arguments to find a MatchSpectator
     * @example
     * // Get one MatchSpectator
     * const matchSpectator = await prisma.matchSpectator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchSpectatorFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchSpectatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchSpectators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSpectatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchSpectators
     * const matchSpectators = await prisma.matchSpectator.findMany()
     * 
     * // Get first 10 MatchSpectators
     * const matchSpectators = await prisma.matchSpectator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchSpectatorWithIdOnly = await prisma.matchSpectator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchSpectatorFindManyArgs>(args?: SelectSubset<T, MatchSpectatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchSpectator.
     * @param {MatchSpectatorCreateArgs} args - Arguments to create a MatchSpectator.
     * @example
     * // Create one MatchSpectator
     * const MatchSpectator = await prisma.matchSpectator.create({
     *   data: {
     *     // ... data to create a MatchSpectator
     *   }
     * })
     * 
     */
    create<T extends MatchSpectatorCreateArgs>(args: SelectSubset<T, MatchSpectatorCreateArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchSpectators.
     * @param {MatchSpectatorCreateManyArgs} args - Arguments to create many MatchSpectators.
     * @example
     * // Create many MatchSpectators
     * const matchSpectator = await prisma.matchSpectator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchSpectatorCreateManyArgs>(args?: SelectSubset<T, MatchSpectatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MatchSpectator.
     * @param {MatchSpectatorDeleteArgs} args - Arguments to delete one MatchSpectator.
     * @example
     * // Delete one MatchSpectator
     * const MatchSpectator = await prisma.matchSpectator.delete({
     *   where: {
     *     // ... filter to delete one MatchSpectator
     *   }
     * })
     * 
     */
    delete<T extends MatchSpectatorDeleteArgs>(args: SelectSubset<T, MatchSpectatorDeleteArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchSpectator.
     * @param {MatchSpectatorUpdateArgs} args - Arguments to update one MatchSpectator.
     * @example
     * // Update one MatchSpectator
     * const matchSpectator = await prisma.matchSpectator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchSpectatorUpdateArgs>(args: SelectSubset<T, MatchSpectatorUpdateArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchSpectators.
     * @param {MatchSpectatorDeleteManyArgs} args - Arguments to filter MatchSpectators to delete.
     * @example
     * // Delete a few MatchSpectators
     * const { count } = await prisma.matchSpectator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchSpectatorDeleteManyArgs>(args?: SelectSubset<T, MatchSpectatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchSpectators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSpectatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchSpectators
     * const matchSpectator = await prisma.matchSpectator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchSpectatorUpdateManyArgs>(args: SelectSubset<T, MatchSpectatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatchSpectator.
     * @param {MatchSpectatorUpsertArgs} args - Arguments to update or create a MatchSpectator.
     * @example
     * // Update or create a MatchSpectator
     * const matchSpectator = await prisma.matchSpectator.upsert({
     *   create: {
     *     // ... data to create a MatchSpectator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchSpectator we want to update
     *   }
     * })
     */
    upsert<T extends MatchSpectatorUpsertArgs>(args: SelectSubset<T, MatchSpectatorUpsertArgs<ExtArgs>>): Prisma__MatchSpectatorClient<$Result.GetResult<Prisma.$MatchSpectatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchSpectators that matches the filter.
     * @param {MatchSpectatorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const matchSpectator = await prisma.matchSpectator.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MatchSpectatorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MatchSpectator.
     * @param {MatchSpectatorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const matchSpectator = await prisma.matchSpectator.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MatchSpectatorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MatchSpectators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSpectatorCountArgs} args - Arguments to filter MatchSpectators to count.
     * @example
     * // Count the number of MatchSpectators
     * const count = await prisma.matchSpectator.count({
     *   where: {
     *     // ... the filter for the MatchSpectators we want to count
     *   }
     * })
    **/
    count<T extends MatchSpectatorCountArgs>(
      args?: Subset<T, MatchSpectatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchSpectatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchSpectator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSpectatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchSpectatorAggregateArgs>(args: Subset<T, MatchSpectatorAggregateArgs>): Prisma.PrismaPromise<GetMatchSpectatorAggregateType<T>>

    /**
     * Group by MatchSpectator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSpectatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchSpectatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchSpectatorGroupByArgs['orderBy'] }
        : { orderBy?: MatchSpectatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchSpectatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchSpectatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchSpectator model
   */
  readonly fields: MatchSpectatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchSpectator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchSpectatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    localMatch<T extends LocalMatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalMatchDefaultArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchSpectator model
   */
  interface MatchSpectatorFieldRefs {
    readonly id: FieldRef<"MatchSpectator", 'String'>
    readonly localMatchId: FieldRef<"MatchSpectator", 'String'>
    readonly userId: FieldRef<"MatchSpectator", 'String'>
    readonly addedBy: FieldRef<"MatchSpectator", 'String'>
    readonly addedAt: FieldRef<"MatchSpectator", 'DateTime'>
    readonly notified: FieldRef<"MatchSpectator", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MatchSpectator findUnique
   */
  export type MatchSpectatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * Filter, which MatchSpectator to fetch.
     */
    where: MatchSpectatorWhereUniqueInput
  }

  /**
   * MatchSpectator findUniqueOrThrow
   */
  export type MatchSpectatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * Filter, which MatchSpectator to fetch.
     */
    where: MatchSpectatorWhereUniqueInput
  }

  /**
   * MatchSpectator findFirst
   */
  export type MatchSpectatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * Filter, which MatchSpectator to fetch.
     */
    where?: MatchSpectatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSpectators to fetch.
     */
    orderBy?: MatchSpectatorOrderByWithRelationInput | MatchSpectatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchSpectators.
     */
    cursor?: MatchSpectatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSpectators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSpectators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchSpectators.
     */
    distinct?: MatchSpectatorScalarFieldEnum | MatchSpectatorScalarFieldEnum[]
  }

  /**
   * MatchSpectator findFirstOrThrow
   */
  export type MatchSpectatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * Filter, which MatchSpectator to fetch.
     */
    where?: MatchSpectatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSpectators to fetch.
     */
    orderBy?: MatchSpectatorOrderByWithRelationInput | MatchSpectatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchSpectators.
     */
    cursor?: MatchSpectatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSpectators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSpectators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchSpectators.
     */
    distinct?: MatchSpectatorScalarFieldEnum | MatchSpectatorScalarFieldEnum[]
  }

  /**
   * MatchSpectator findMany
   */
  export type MatchSpectatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * Filter, which MatchSpectators to fetch.
     */
    where?: MatchSpectatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSpectators to fetch.
     */
    orderBy?: MatchSpectatorOrderByWithRelationInput | MatchSpectatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchSpectators.
     */
    cursor?: MatchSpectatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSpectators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSpectators.
     */
    skip?: number
    distinct?: MatchSpectatorScalarFieldEnum | MatchSpectatorScalarFieldEnum[]
  }

  /**
   * MatchSpectator create
   */
  export type MatchSpectatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchSpectator.
     */
    data: XOR<MatchSpectatorCreateInput, MatchSpectatorUncheckedCreateInput>
  }

  /**
   * MatchSpectator createMany
   */
  export type MatchSpectatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchSpectators.
     */
    data: MatchSpectatorCreateManyInput | MatchSpectatorCreateManyInput[]
  }

  /**
   * MatchSpectator update
   */
  export type MatchSpectatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchSpectator.
     */
    data: XOR<MatchSpectatorUpdateInput, MatchSpectatorUncheckedUpdateInput>
    /**
     * Choose, which MatchSpectator to update.
     */
    where: MatchSpectatorWhereUniqueInput
  }

  /**
   * MatchSpectator updateMany
   */
  export type MatchSpectatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchSpectators.
     */
    data: XOR<MatchSpectatorUpdateManyMutationInput, MatchSpectatorUncheckedUpdateManyInput>
    /**
     * Filter which MatchSpectators to update
     */
    where?: MatchSpectatorWhereInput
    /**
     * Limit how many MatchSpectators to update.
     */
    limit?: number
  }

  /**
   * MatchSpectator upsert
   */
  export type MatchSpectatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchSpectator to update in case it exists.
     */
    where: MatchSpectatorWhereUniqueInput
    /**
     * In case the MatchSpectator found by the `where` argument doesn't exist, create a new MatchSpectator with this data.
     */
    create: XOR<MatchSpectatorCreateInput, MatchSpectatorUncheckedCreateInput>
    /**
     * In case the MatchSpectator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchSpectatorUpdateInput, MatchSpectatorUncheckedUpdateInput>
  }

  /**
   * MatchSpectator delete
   */
  export type MatchSpectatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
    /**
     * Filter which MatchSpectator to delete.
     */
    where: MatchSpectatorWhereUniqueInput
  }

  /**
   * MatchSpectator deleteMany
   */
  export type MatchSpectatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchSpectators to delete
     */
    where?: MatchSpectatorWhereInput
    /**
     * Limit how many MatchSpectators to delete.
     */
    limit?: number
  }

  /**
   * MatchSpectator findRaw
   */
  export type MatchSpectatorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MatchSpectator aggregateRaw
   */
  export type MatchSpectatorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MatchSpectator without action
   */
  export type MatchSpectatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSpectator
     */
    select?: MatchSpectatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSpectator
     */
    omit?: MatchSpectatorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSpectatorInclude<ExtArgs> | null
  }


  /**
   * Model OverHistory
   */

  export type AggregateOverHistory = {
    _count: OverHistoryCountAggregateOutputType | null
    _avg: OverHistoryAvgAggregateOutputType | null
    _sum: OverHistorySumAggregateOutputType | null
    _min: OverHistoryMinAggregateOutputType | null
    _max: OverHistoryMaxAggregateOutputType | null
  }

  export type OverHistoryAvgAggregateOutputType = {
    overNumber: number | null
    innings: number | null
    totalRuns: number | null
    wickets: number | null
  }

  export type OverHistorySumAggregateOutputType = {
    overNumber: number | null
    innings: number | null
    totalRuns: number | null
    wickets: number | null
  }

  export type OverHistoryMinAggregateOutputType = {
    id: string | null
    localMatchId: string | null
    overNumber: number | null
    innings: number | null
    totalRuns: number | null
    wickets: number | null
    createdAt: Date | null
  }

  export type OverHistoryMaxAggregateOutputType = {
    id: string | null
    localMatchId: string | null
    overNumber: number | null
    innings: number | null
    totalRuns: number | null
    wickets: number | null
    createdAt: Date | null
  }

  export type OverHistoryCountAggregateOutputType = {
    id: number
    localMatchId: number
    overNumber: number
    innings: number
    balls: number
    totalRuns: number
    wickets: number
    createdAt: number
    _all: number
  }


  export type OverHistoryAvgAggregateInputType = {
    overNumber?: true
    innings?: true
    totalRuns?: true
    wickets?: true
  }

  export type OverHistorySumAggregateInputType = {
    overNumber?: true
    innings?: true
    totalRuns?: true
    wickets?: true
  }

  export type OverHistoryMinAggregateInputType = {
    id?: true
    localMatchId?: true
    overNumber?: true
    innings?: true
    totalRuns?: true
    wickets?: true
    createdAt?: true
  }

  export type OverHistoryMaxAggregateInputType = {
    id?: true
    localMatchId?: true
    overNumber?: true
    innings?: true
    totalRuns?: true
    wickets?: true
    createdAt?: true
  }

  export type OverHistoryCountAggregateInputType = {
    id?: true
    localMatchId?: true
    overNumber?: true
    innings?: true
    balls?: true
    totalRuns?: true
    wickets?: true
    createdAt?: true
    _all?: true
  }

  export type OverHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OverHistory to aggregate.
     */
    where?: OverHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OverHistories to fetch.
     */
    orderBy?: OverHistoryOrderByWithRelationInput | OverHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OverHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OverHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OverHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OverHistories
    **/
    _count?: true | OverHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OverHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OverHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OverHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OverHistoryMaxAggregateInputType
  }

  export type GetOverHistoryAggregateType<T extends OverHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateOverHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOverHistory[P]>
      : GetScalarType<T[P], AggregateOverHistory[P]>
  }




  export type OverHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OverHistoryWhereInput
    orderBy?: OverHistoryOrderByWithAggregationInput | OverHistoryOrderByWithAggregationInput[]
    by: OverHistoryScalarFieldEnum[] | OverHistoryScalarFieldEnum
    having?: OverHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OverHistoryCountAggregateInputType | true
    _avg?: OverHistoryAvgAggregateInputType
    _sum?: OverHistorySumAggregateInputType
    _min?: OverHistoryMinAggregateInputType
    _max?: OverHistoryMaxAggregateInputType
  }

  export type OverHistoryGroupByOutputType = {
    id: string
    localMatchId: string
    overNumber: number
    innings: number
    balls: JsonValue
    totalRuns: number
    wickets: number
    createdAt: Date
    _count: OverHistoryCountAggregateOutputType | null
    _avg: OverHistoryAvgAggregateOutputType | null
    _sum: OverHistorySumAggregateOutputType | null
    _min: OverHistoryMinAggregateOutputType | null
    _max: OverHistoryMaxAggregateOutputType | null
  }

  type GetOverHistoryGroupByPayload<T extends OverHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OverHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OverHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OverHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], OverHistoryGroupByOutputType[P]>
        }
      >
    >


  export type OverHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    localMatchId?: boolean
    overNumber?: boolean
    innings?: boolean
    balls?: boolean
    totalRuns?: boolean
    wickets?: boolean
    createdAt?: boolean
    localMatch?: boolean | LocalMatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overHistory"]>



  export type OverHistorySelectScalar = {
    id?: boolean
    localMatchId?: boolean
    overNumber?: boolean
    innings?: boolean
    balls?: boolean
    totalRuns?: boolean
    wickets?: boolean
    createdAt?: boolean
  }

  export type OverHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "localMatchId" | "overNumber" | "innings" | "balls" | "totalRuns" | "wickets" | "createdAt", ExtArgs["result"]["overHistory"]>
  export type OverHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localMatch?: boolean | LocalMatchDefaultArgs<ExtArgs>
  }

  export type $OverHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OverHistory"
    objects: {
      localMatch: Prisma.$LocalMatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      localMatchId: string
      overNumber: number
      innings: number
      balls: Prisma.JsonValue
      totalRuns: number
      wickets: number
      createdAt: Date
    }, ExtArgs["result"]["overHistory"]>
    composites: {}
  }

  type OverHistoryGetPayload<S extends boolean | null | undefined | OverHistoryDefaultArgs> = $Result.GetResult<Prisma.$OverHistoryPayload, S>

  type OverHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OverHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OverHistoryCountAggregateInputType | true
    }

  export interface OverHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OverHistory'], meta: { name: 'OverHistory' } }
    /**
     * Find zero or one OverHistory that matches the filter.
     * @param {OverHistoryFindUniqueArgs} args - Arguments to find a OverHistory
     * @example
     * // Get one OverHistory
     * const overHistory = await prisma.overHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OverHistoryFindUniqueArgs>(args: SelectSubset<T, OverHistoryFindUniqueArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OverHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OverHistoryFindUniqueOrThrowArgs} args - Arguments to find a OverHistory
     * @example
     * // Get one OverHistory
     * const overHistory = await prisma.overHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OverHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, OverHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OverHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverHistoryFindFirstArgs} args - Arguments to find a OverHistory
     * @example
     * // Get one OverHistory
     * const overHistory = await prisma.overHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OverHistoryFindFirstArgs>(args?: SelectSubset<T, OverHistoryFindFirstArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OverHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverHistoryFindFirstOrThrowArgs} args - Arguments to find a OverHistory
     * @example
     * // Get one OverHistory
     * const overHistory = await prisma.overHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OverHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, OverHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OverHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OverHistories
     * const overHistories = await prisma.overHistory.findMany()
     * 
     * // Get first 10 OverHistories
     * const overHistories = await prisma.overHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overHistoryWithIdOnly = await prisma.overHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OverHistoryFindManyArgs>(args?: SelectSubset<T, OverHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OverHistory.
     * @param {OverHistoryCreateArgs} args - Arguments to create a OverHistory.
     * @example
     * // Create one OverHistory
     * const OverHistory = await prisma.overHistory.create({
     *   data: {
     *     // ... data to create a OverHistory
     *   }
     * })
     * 
     */
    create<T extends OverHistoryCreateArgs>(args: SelectSubset<T, OverHistoryCreateArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OverHistories.
     * @param {OverHistoryCreateManyArgs} args - Arguments to create many OverHistories.
     * @example
     * // Create many OverHistories
     * const overHistory = await prisma.overHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OverHistoryCreateManyArgs>(args?: SelectSubset<T, OverHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OverHistory.
     * @param {OverHistoryDeleteArgs} args - Arguments to delete one OverHistory.
     * @example
     * // Delete one OverHistory
     * const OverHistory = await prisma.overHistory.delete({
     *   where: {
     *     // ... filter to delete one OverHistory
     *   }
     * })
     * 
     */
    delete<T extends OverHistoryDeleteArgs>(args: SelectSubset<T, OverHistoryDeleteArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OverHistory.
     * @param {OverHistoryUpdateArgs} args - Arguments to update one OverHistory.
     * @example
     * // Update one OverHistory
     * const overHistory = await prisma.overHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OverHistoryUpdateArgs>(args: SelectSubset<T, OverHistoryUpdateArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OverHistories.
     * @param {OverHistoryDeleteManyArgs} args - Arguments to filter OverHistories to delete.
     * @example
     * // Delete a few OverHistories
     * const { count } = await prisma.overHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OverHistoryDeleteManyArgs>(args?: SelectSubset<T, OverHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OverHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OverHistories
     * const overHistory = await prisma.overHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OverHistoryUpdateManyArgs>(args: SelectSubset<T, OverHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OverHistory.
     * @param {OverHistoryUpsertArgs} args - Arguments to update or create a OverHistory.
     * @example
     * // Update or create a OverHistory
     * const overHistory = await prisma.overHistory.upsert({
     *   create: {
     *     // ... data to create a OverHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OverHistory we want to update
     *   }
     * })
     */
    upsert<T extends OverHistoryUpsertArgs>(args: SelectSubset<T, OverHistoryUpsertArgs<ExtArgs>>): Prisma__OverHistoryClient<$Result.GetResult<Prisma.$OverHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OverHistories that matches the filter.
     * @param {OverHistoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const overHistory = await prisma.overHistory.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OverHistoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OverHistory.
     * @param {OverHistoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const overHistory = await prisma.overHistory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OverHistoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OverHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverHistoryCountArgs} args - Arguments to filter OverHistories to count.
     * @example
     * // Count the number of OverHistories
     * const count = await prisma.overHistory.count({
     *   where: {
     *     // ... the filter for the OverHistories we want to count
     *   }
     * })
    **/
    count<T extends OverHistoryCountArgs>(
      args?: Subset<T, OverHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OverHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OverHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OverHistoryAggregateArgs>(args: Subset<T, OverHistoryAggregateArgs>): Prisma.PrismaPromise<GetOverHistoryAggregateType<T>>

    /**
     * Group by OverHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OverHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OverHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OverHistoryGroupByArgs['orderBy'] }
        : { orderBy?: OverHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OverHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOverHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OverHistory model
   */
  readonly fields: OverHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OverHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OverHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    localMatch<T extends LocalMatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalMatchDefaultArgs<ExtArgs>>): Prisma__LocalMatchClient<$Result.GetResult<Prisma.$LocalMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OverHistory model
   */
  interface OverHistoryFieldRefs {
    readonly id: FieldRef<"OverHistory", 'String'>
    readonly localMatchId: FieldRef<"OverHistory", 'String'>
    readonly overNumber: FieldRef<"OverHistory", 'Int'>
    readonly innings: FieldRef<"OverHistory", 'Int'>
    readonly balls: FieldRef<"OverHistory", 'Json'>
    readonly totalRuns: FieldRef<"OverHistory", 'Int'>
    readonly wickets: FieldRef<"OverHistory", 'Int'>
    readonly createdAt: FieldRef<"OverHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OverHistory findUnique
   */
  export type OverHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OverHistory to fetch.
     */
    where: OverHistoryWhereUniqueInput
  }

  /**
   * OverHistory findUniqueOrThrow
   */
  export type OverHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OverHistory to fetch.
     */
    where: OverHistoryWhereUniqueInput
  }

  /**
   * OverHistory findFirst
   */
  export type OverHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OverHistory to fetch.
     */
    where?: OverHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OverHistories to fetch.
     */
    orderBy?: OverHistoryOrderByWithRelationInput | OverHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OverHistories.
     */
    cursor?: OverHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OverHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OverHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OverHistories.
     */
    distinct?: OverHistoryScalarFieldEnum | OverHistoryScalarFieldEnum[]
  }

  /**
   * OverHistory findFirstOrThrow
   */
  export type OverHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OverHistory to fetch.
     */
    where?: OverHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OverHistories to fetch.
     */
    orderBy?: OverHistoryOrderByWithRelationInput | OverHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OverHistories.
     */
    cursor?: OverHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OverHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OverHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OverHistories.
     */
    distinct?: OverHistoryScalarFieldEnum | OverHistoryScalarFieldEnum[]
  }

  /**
   * OverHistory findMany
   */
  export type OverHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OverHistories to fetch.
     */
    where?: OverHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OverHistories to fetch.
     */
    orderBy?: OverHistoryOrderByWithRelationInput | OverHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OverHistories.
     */
    cursor?: OverHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OverHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OverHistories.
     */
    skip?: number
    distinct?: OverHistoryScalarFieldEnum | OverHistoryScalarFieldEnum[]
  }

  /**
   * OverHistory create
   */
  export type OverHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a OverHistory.
     */
    data: XOR<OverHistoryCreateInput, OverHistoryUncheckedCreateInput>
  }

  /**
   * OverHistory createMany
   */
  export type OverHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OverHistories.
     */
    data: OverHistoryCreateManyInput | OverHistoryCreateManyInput[]
  }

  /**
   * OverHistory update
   */
  export type OverHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a OverHistory.
     */
    data: XOR<OverHistoryUpdateInput, OverHistoryUncheckedUpdateInput>
    /**
     * Choose, which OverHistory to update.
     */
    where: OverHistoryWhereUniqueInput
  }

  /**
   * OverHistory updateMany
   */
  export type OverHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OverHistories.
     */
    data: XOR<OverHistoryUpdateManyMutationInput, OverHistoryUncheckedUpdateManyInput>
    /**
     * Filter which OverHistories to update
     */
    where?: OverHistoryWhereInput
    /**
     * Limit how many OverHistories to update.
     */
    limit?: number
  }

  /**
   * OverHistory upsert
   */
  export type OverHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the OverHistory to update in case it exists.
     */
    where: OverHistoryWhereUniqueInput
    /**
     * In case the OverHistory found by the `where` argument doesn't exist, create a new OverHistory with this data.
     */
    create: XOR<OverHistoryCreateInput, OverHistoryUncheckedCreateInput>
    /**
     * In case the OverHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OverHistoryUpdateInput, OverHistoryUncheckedUpdateInput>
  }

  /**
   * OverHistory delete
   */
  export type OverHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
    /**
     * Filter which OverHistory to delete.
     */
    where: OverHistoryWhereUniqueInput
  }

  /**
   * OverHistory deleteMany
   */
  export type OverHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OverHistories to delete
     */
    where?: OverHistoryWhereInput
    /**
     * Limit how many OverHistories to delete.
     */
    limit?: number
  }

  /**
   * OverHistory findRaw
   */
  export type OverHistoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OverHistory aggregateRaw
   */
  export type OverHistoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OverHistory without action
   */
  export type OverHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OverHistory
     */
    select?: OverHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OverHistory
     */
    omit?: OverHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OverHistoryInclude<ExtArgs> | null
  }


  /**
   * Model MatchSummary
   */

  export type AggregateMatchSummary = {
    _count: MatchSummaryCountAggregateOutputType | null
    _avg: MatchSummaryAvgAggregateOutputType | null
    _sum: MatchSummarySumAggregateOutputType | null
    _min: MatchSummaryMinAggregateOutputType | null
    _max: MatchSummaryMaxAggregateOutputType | null
  }

  export type MatchSummaryAvgAggregateOutputType = {
    firstInningsRuns: number | null
    firstInningsWickets: number | null
    firstInningsOvers: number | null
    secondInningsRuns: number | null
    secondInningsWickets: number | null
    secondInningsOvers: number | null
    target: number | null
    totalOvers: number | null
  }

  export type MatchSummarySumAggregateOutputType = {
    firstInningsRuns: number | null
    firstInningsWickets: number | null
    firstInningsOvers: number | null
    secondInningsRuns: number | null
    secondInningsWickets: number | null
    secondInningsOvers: number | null
    target: number | null
    totalOvers: number | null
  }

  export type MatchSummaryMinAggregateOutputType = {
    id: string | null
    matchDate: Date | null
    venue: string | null
    homeTeamName: string | null
    homeTeamId: string | null
    awayTeamName: string | null
    awayTeamId: string | null
    result: $Enums.MatchResult | null
    winningTeam: string | null
    firstInningsTeam: string | null
    firstInningsRuns: number | null
    firstInningsWickets: number | null
    firstInningsOvers: number | null
    secondInningsTeam: string | null
    secondInningsRuns: number | null
    secondInningsWickets: number | null
    secondInningsOvers: number | null
    target: number | null
    totalOvers: number | null
    manOfTheMatchPlayerName: string | null
    manOfTheMatchUserId: string | null
    createdAt: Date | null
  }

  export type MatchSummaryMaxAggregateOutputType = {
    id: string | null
    matchDate: Date | null
    venue: string | null
    homeTeamName: string | null
    homeTeamId: string | null
    awayTeamName: string | null
    awayTeamId: string | null
    result: $Enums.MatchResult | null
    winningTeam: string | null
    firstInningsTeam: string | null
    firstInningsRuns: number | null
    firstInningsWickets: number | null
    firstInningsOvers: number | null
    secondInningsTeam: string | null
    secondInningsRuns: number | null
    secondInningsWickets: number | null
    secondInningsOvers: number | null
    target: number | null
    totalOvers: number | null
    manOfTheMatchPlayerName: string | null
    manOfTheMatchUserId: string | null
    createdAt: Date | null
  }

  export type MatchSummaryCountAggregateOutputType = {
    id: number
    matchDate: number
    venue: number
    homeTeamName: number
    homeTeamId: number
    awayTeamName: number
    awayTeamId: number
    result: number
    winningTeam: number
    firstInningsTeam: number
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: number
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target: number
    totalOvers: number
    manOfTheMatchPlayerName: number
    manOfTheMatchUserId: number
    manOfTheMatchStats: number
    firstInningsBatsmen: number
    firstInningsBowlers: number
    secondInningsBatsmen: number
    secondInningsBowlers: number
    createdAt: number
    _all: number
  }


  export type MatchSummaryAvgAggregateInputType = {
    firstInningsRuns?: true
    firstInningsWickets?: true
    firstInningsOvers?: true
    secondInningsRuns?: true
    secondInningsWickets?: true
    secondInningsOvers?: true
    target?: true
    totalOvers?: true
  }

  export type MatchSummarySumAggregateInputType = {
    firstInningsRuns?: true
    firstInningsWickets?: true
    firstInningsOvers?: true
    secondInningsRuns?: true
    secondInningsWickets?: true
    secondInningsOvers?: true
    target?: true
    totalOvers?: true
  }

  export type MatchSummaryMinAggregateInputType = {
    id?: true
    matchDate?: true
    venue?: true
    homeTeamName?: true
    homeTeamId?: true
    awayTeamName?: true
    awayTeamId?: true
    result?: true
    winningTeam?: true
    firstInningsTeam?: true
    firstInningsRuns?: true
    firstInningsWickets?: true
    firstInningsOvers?: true
    secondInningsTeam?: true
    secondInningsRuns?: true
    secondInningsWickets?: true
    secondInningsOvers?: true
    target?: true
    totalOvers?: true
    manOfTheMatchPlayerName?: true
    manOfTheMatchUserId?: true
    createdAt?: true
  }

  export type MatchSummaryMaxAggregateInputType = {
    id?: true
    matchDate?: true
    venue?: true
    homeTeamName?: true
    homeTeamId?: true
    awayTeamName?: true
    awayTeamId?: true
    result?: true
    winningTeam?: true
    firstInningsTeam?: true
    firstInningsRuns?: true
    firstInningsWickets?: true
    firstInningsOvers?: true
    secondInningsTeam?: true
    secondInningsRuns?: true
    secondInningsWickets?: true
    secondInningsOvers?: true
    target?: true
    totalOvers?: true
    manOfTheMatchPlayerName?: true
    manOfTheMatchUserId?: true
    createdAt?: true
  }

  export type MatchSummaryCountAggregateInputType = {
    id?: true
    matchDate?: true
    venue?: true
    homeTeamName?: true
    homeTeamId?: true
    awayTeamName?: true
    awayTeamId?: true
    result?: true
    winningTeam?: true
    firstInningsTeam?: true
    firstInningsRuns?: true
    firstInningsWickets?: true
    firstInningsOvers?: true
    secondInningsTeam?: true
    secondInningsRuns?: true
    secondInningsWickets?: true
    secondInningsOvers?: true
    target?: true
    totalOvers?: true
    manOfTheMatchPlayerName?: true
    manOfTheMatchUserId?: true
    manOfTheMatchStats?: true
    firstInningsBatsmen?: true
    firstInningsBowlers?: true
    secondInningsBatsmen?: true
    secondInningsBowlers?: true
    createdAt?: true
    _all?: true
  }

  export type MatchSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchSummary to aggregate.
     */
    where?: MatchSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSummaries to fetch.
     */
    orderBy?: MatchSummaryOrderByWithRelationInput | MatchSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchSummaries
    **/
    _count?: true | MatchSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchSummaryMaxAggregateInputType
  }

  export type GetMatchSummaryAggregateType<T extends MatchSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchSummary[P]>
      : GetScalarType<T[P], AggregateMatchSummary[P]>
  }




  export type MatchSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchSummaryWhereInput
    orderBy?: MatchSummaryOrderByWithAggregationInput | MatchSummaryOrderByWithAggregationInput[]
    by: MatchSummaryScalarFieldEnum[] | MatchSummaryScalarFieldEnum
    having?: MatchSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchSummaryCountAggregateInputType | true
    _avg?: MatchSummaryAvgAggregateInputType
    _sum?: MatchSummarySumAggregateInputType
    _min?: MatchSummaryMinAggregateInputType
    _max?: MatchSummaryMaxAggregateInputType
  }

  export type MatchSummaryGroupByOutputType = {
    id: string
    matchDate: Date
    venue: string
    homeTeamName: string
    homeTeamId: string | null
    awayTeamName: string
    awayTeamId: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target: number | null
    totalOvers: number
    manOfTheMatchPlayerName: string | null
    manOfTheMatchUserId: string | null
    manOfTheMatchStats: JsonValue | null
    firstInningsBatsmen: JsonValue
    firstInningsBowlers: JsonValue
    secondInningsBatsmen: JsonValue
    secondInningsBowlers: JsonValue
    createdAt: Date
    _count: MatchSummaryCountAggregateOutputType | null
    _avg: MatchSummaryAvgAggregateOutputType | null
    _sum: MatchSummarySumAggregateOutputType | null
    _min: MatchSummaryMinAggregateOutputType | null
    _max: MatchSummaryMaxAggregateOutputType | null
  }

  type GetMatchSummaryGroupByPayload<T extends MatchSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], MatchSummaryGroupByOutputType[P]>
        }
      >
    >


  export type MatchSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    matchDate?: boolean
    venue?: boolean
    homeTeamName?: boolean
    homeTeamId?: boolean
    awayTeamName?: boolean
    awayTeamId?: boolean
    result?: boolean
    winningTeam?: boolean
    firstInningsTeam?: boolean
    firstInningsRuns?: boolean
    firstInningsWickets?: boolean
    firstInningsOvers?: boolean
    secondInningsTeam?: boolean
    secondInningsRuns?: boolean
    secondInningsWickets?: boolean
    secondInningsOvers?: boolean
    target?: boolean
    totalOvers?: boolean
    manOfTheMatchPlayerName?: boolean
    manOfTheMatchUserId?: boolean
    manOfTheMatchStats?: boolean
    firstInningsBatsmen?: boolean
    firstInningsBowlers?: boolean
    secondInningsBatsmen?: boolean
    secondInningsBowlers?: boolean
    createdAt?: boolean
    homeTeam?: boolean | MatchSummary$homeTeamArgs<ExtArgs>
    awayTeam?: boolean | MatchSummary$awayTeamArgs<ExtArgs>
    manOfTheMatchUser?: boolean | MatchSummary$manOfTheMatchUserArgs<ExtArgs>
    playerHistory?: boolean | MatchSummary$playerHistoryArgs<ExtArgs>
    _count?: boolean | MatchSummaryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchSummary"]>



  export type MatchSummarySelectScalar = {
    id?: boolean
    matchDate?: boolean
    venue?: boolean
    homeTeamName?: boolean
    homeTeamId?: boolean
    awayTeamName?: boolean
    awayTeamId?: boolean
    result?: boolean
    winningTeam?: boolean
    firstInningsTeam?: boolean
    firstInningsRuns?: boolean
    firstInningsWickets?: boolean
    firstInningsOvers?: boolean
    secondInningsTeam?: boolean
    secondInningsRuns?: boolean
    secondInningsWickets?: boolean
    secondInningsOvers?: boolean
    target?: boolean
    totalOvers?: boolean
    manOfTheMatchPlayerName?: boolean
    manOfTheMatchUserId?: boolean
    manOfTheMatchStats?: boolean
    firstInningsBatsmen?: boolean
    firstInningsBowlers?: boolean
    secondInningsBatsmen?: boolean
    secondInningsBowlers?: boolean
    createdAt?: boolean
  }

  export type MatchSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "matchDate" | "venue" | "homeTeamName" | "homeTeamId" | "awayTeamName" | "awayTeamId" | "result" | "winningTeam" | "firstInningsTeam" | "firstInningsRuns" | "firstInningsWickets" | "firstInningsOvers" | "secondInningsTeam" | "secondInningsRuns" | "secondInningsWickets" | "secondInningsOvers" | "target" | "totalOvers" | "manOfTheMatchPlayerName" | "manOfTheMatchUserId" | "manOfTheMatchStats" | "firstInningsBatsmen" | "firstInningsBowlers" | "secondInningsBatsmen" | "secondInningsBowlers" | "createdAt", ExtArgs["result"]["matchSummary"]>
  export type MatchSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    homeTeam?: boolean | MatchSummary$homeTeamArgs<ExtArgs>
    awayTeam?: boolean | MatchSummary$awayTeamArgs<ExtArgs>
    manOfTheMatchUser?: boolean | MatchSummary$manOfTheMatchUserArgs<ExtArgs>
    playerHistory?: boolean | MatchSummary$playerHistoryArgs<ExtArgs>
    _count?: boolean | MatchSummaryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MatchSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchSummary"
    objects: {
      homeTeam: Prisma.$TeamPayload<ExtArgs> | null
      awayTeam: Prisma.$TeamPayload<ExtArgs> | null
      manOfTheMatchUser: Prisma.$UserPayload<ExtArgs> | null
      playerHistory: Prisma.$PlayerMatchHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      matchDate: Date
      venue: string
      homeTeamName: string
      homeTeamId: string | null
      awayTeamName: string
      awayTeamId: string | null
      result: $Enums.MatchResult
      winningTeam: string
      firstInningsTeam: string
      firstInningsRuns: number
      firstInningsWickets: number
      firstInningsOvers: number
      secondInningsTeam: string
      secondInningsRuns: number
      secondInningsWickets: number
      secondInningsOvers: number
      target: number | null
      totalOvers: number
      manOfTheMatchPlayerName: string | null
      manOfTheMatchUserId: string | null
      manOfTheMatchStats: Prisma.JsonValue | null
      firstInningsBatsmen: Prisma.JsonValue
      firstInningsBowlers: Prisma.JsonValue
      secondInningsBatsmen: Prisma.JsonValue
      secondInningsBowlers: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["matchSummary"]>
    composites: {}
  }

  type MatchSummaryGetPayload<S extends boolean | null | undefined | MatchSummaryDefaultArgs> = $Result.GetResult<Prisma.$MatchSummaryPayload, S>

  type MatchSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchSummaryCountAggregateInputType | true
    }

  export interface MatchSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchSummary'], meta: { name: 'MatchSummary' } }
    /**
     * Find zero or one MatchSummary that matches the filter.
     * @param {MatchSummaryFindUniqueArgs} args - Arguments to find a MatchSummary
     * @example
     * // Get one MatchSummary
     * const matchSummary = await prisma.matchSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchSummaryFindUniqueArgs>(args: SelectSubset<T, MatchSummaryFindUniqueArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchSummaryFindUniqueOrThrowArgs} args - Arguments to find a MatchSummary
     * @example
     * // Get one MatchSummary
     * const matchSummary = await prisma.matchSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSummaryFindFirstArgs} args - Arguments to find a MatchSummary
     * @example
     * // Get one MatchSummary
     * const matchSummary = await prisma.matchSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchSummaryFindFirstArgs>(args?: SelectSubset<T, MatchSummaryFindFirstArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSummaryFindFirstOrThrowArgs} args - Arguments to find a MatchSummary
     * @example
     * // Get one MatchSummary
     * const matchSummary = await prisma.matchSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchSummaries
     * const matchSummaries = await prisma.matchSummary.findMany()
     * 
     * // Get first 10 MatchSummaries
     * const matchSummaries = await prisma.matchSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchSummaryWithIdOnly = await prisma.matchSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchSummaryFindManyArgs>(args?: SelectSubset<T, MatchSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchSummary.
     * @param {MatchSummaryCreateArgs} args - Arguments to create a MatchSummary.
     * @example
     * // Create one MatchSummary
     * const MatchSummary = await prisma.matchSummary.create({
     *   data: {
     *     // ... data to create a MatchSummary
     *   }
     * })
     * 
     */
    create<T extends MatchSummaryCreateArgs>(args: SelectSubset<T, MatchSummaryCreateArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchSummaries.
     * @param {MatchSummaryCreateManyArgs} args - Arguments to create many MatchSummaries.
     * @example
     * // Create many MatchSummaries
     * const matchSummary = await prisma.matchSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchSummaryCreateManyArgs>(args?: SelectSubset<T, MatchSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MatchSummary.
     * @param {MatchSummaryDeleteArgs} args - Arguments to delete one MatchSummary.
     * @example
     * // Delete one MatchSummary
     * const MatchSummary = await prisma.matchSummary.delete({
     *   where: {
     *     // ... filter to delete one MatchSummary
     *   }
     * })
     * 
     */
    delete<T extends MatchSummaryDeleteArgs>(args: SelectSubset<T, MatchSummaryDeleteArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchSummary.
     * @param {MatchSummaryUpdateArgs} args - Arguments to update one MatchSummary.
     * @example
     * // Update one MatchSummary
     * const matchSummary = await prisma.matchSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchSummaryUpdateArgs>(args: SelectSubset<T, MatchSummaryUpdateArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchSummaries.
     * @param {MatchSummaryDeleteManyArgs} args - Arguments to filter MatchSummaries to delete.
     * @example
     * // Delete a few MatchSummaries
     * const { count } = await prisma.matchSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchSummaryDeleteManyArgs>(args?: SelectSubset<T, MatchSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchSummaries
     * const matchSummary = await prisma.matchSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchSummaryUpdateManyArgs>(args: SelectSubset<T, MatchSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatchSummary.
     * @param {MatchSummaryUpsertArgs} args - Arguments to update or create a MatchSummary.
     * @example
     * // Update or create a MatchSummary
     * const matchSummary = await prisma.matchSummary.upsert({
     *   create: {
     *     // ... data to create a MatchSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchSummary we want to update
     *   }
     * })
     */
    upsert<T extends MatchSummaryUpsertArgs>(args: SelectSubset<T, MatchSummaryUpsertArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchSummaries that matches the filter.
     * @param {MatchSummaryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const matchSummary = await prisma.matchSummary.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MatchSummaryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MatchSummary.
     * @param {MatchSummaryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const matchSummary = await prisma.matchSummary.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MatchSummaryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MatchSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSummaryCountArgs} args - Arguments to filter MatchSummaries to count.
     * @example
     * // Count the number of MatchSummaries
     * const count = await prisma.matchSummary.count({
     *   where: {
     *     // ... the filter for the MatchSummaries we want to count
     *   }
     * })
    **/
    count<T extends MatchSummaryCountArgs>(
      args?: Subset<T, MatchSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchSummaryAggregateArgs>(args: Subset<T, MatchSummaryAggregateArgs>): Prisma.PrismaPromise<GetMatchSummaryAggregateType<T>>

    /**
     * Group by MatchSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchSummaryGroupByArgs['orderBy'] }
        : { orderBy?: MatchSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchSummary model
   */
  readonly fields: MatchSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    homeTeam<T extends MatchSummary$homeTeamArgs<ExtArgs> = {}>(args?: Subset<T, MatchSummary$homeTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    awayTeam<T extends MatchSummary$awayTeamArgs<ExtArgs> = {}>(args?: Subset<T, MatchSummary$awayTeamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manOfTheMatchUser<T extends MatchSummary$manOfTheMatchUserArgs<ExtArgs> = {}>(args?: Subset<T, MatchSummary$manOfTheMatchUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    playerHistory<T extends MatchSummary$playerHistoryArgs<ExtArgs> = {}>(args?: Subset<T, MatchSummary$playerHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchSummary model
   */
  interface MatchSummaryFieldRefs {
    readonly id: FieldRef<"MatchSummary", 'String'>
    readonly matchDate: FieldRef<"MatchSummary", 'DateTime'>
    readonly venue: FieldRef<"MatchSummary", 'String'>
    readonly homeTeamName: FieldRef<"MatchSummary", 'String'>
    readonly homeTeamId: FieldRef<"MatchSummary", 'String'>
    readonly awayTeamName: FieldRef<"MatchSummary", 'String'>
    readonly awayTeamId: FieldRef<"MatchSummary", 'String'>
    readonly result: FieldRef<"MatchSummary", 'MatchResult'>
    readonly winningTeam: FieldRef<"MatchSummary", 'String'>
    readonly firstInningsTeam: FieldRef<"MatchSummary", 'String'>
    readonly firstInningsRuns: FieldRef<"MatchSummary", 'Int'>
    readonly firstInningsWickets: FieldRef<"MatchSummary", 'Int'>
    readonly firstInningsOvers: FieldRef<"MatchSummary", 'Float'>
    readonly secondInningsTeam: FieldRef<"MatchSummary", 'String'>
    readonly secondInningsRuns: FieldRef<"MatchSummary", 'Int'>
    readonly secondInningsWickets: FieldRef<"MatchSummary", 'Int'>
    readonly secondInningsOvers: FieldRef<"MatchSummary", 'Float'>
    readonly target: FieldRef<"MatchSummary", 'Int'>
    readonly totalOvers: FieldRef<"MatchSummary", 'Int'>
    readonly manOfTheMatchPlayerName: FieldRef<"MatchSummary", 'String'>
    readonly manOfTheMatchUserId: FieldRef<"MatchSummary", 'String'>
    readonly manOfTheMatchStats: FieldRef<"MatchSummary", 'Json'>
    readonly firstInningsBatsmen: FieldRef<"MatchSummary", 'Json'>
    readonly firstInningsBowlers: FieldRef<"MatchSummary", 'Json'>
    readonly secondInningsBatsmen: FieldRef<"MatchSummary", 'Json'>
    readonly secondInningsBowlers: FieldRef<"MatchSummary", 'Json'>
    readonly createdAt: FieldRef<"MatchSummary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MatchSummary findUnique
   */
  export type MatchSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * Filter, which MatchSummary to fetch.
     */
    where: MatchSummaryWhereUniqueInput
  }

  /**
   * MatchSummary findUniqueOrThrow
   */
  export type MatchSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * Filter, which MatchSummary to fetch.
     */
    where: MatchSummaryWhereUniqueInput
  }

  /**
   * MatchSummary findFirst
   */
  export type MatchSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * Filter, which MatchSummary to fetch.
     */
    where?: MatchSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSummaries to fetch.
     */
    orderBy?: MatchSummaryOrderByWithRelationInput | MatchSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchSummaries.
     */
    cursor?: MatchSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchSummaries.
     */
    distinct?: MatchSummaryScalarFieldEnum | MatchSummaryScalarFieldEnum[]
  }

  /**
   * MatchSummary findFirstOrThrow
   */
  export type MatchSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * Filter, which MatchSummary to fetch.
     */
    where?: MatchSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSummaries to fetch.
     */
    orderBy?: MatchSummaryOrderByWithRelationInput | MatchSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchSummaries.
     */
    cursor?: MatchSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchSummaries.
     */
    distinct?: MatchSummaryScalarFieldEnum | MatchSummaryScalarFieldEnum[]
  }

  /**
   * MatchSummary findMany
   */
  export type MatchSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * Filter, which MatchSummaries to fetch.
     */
    where?: MatchSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchSummaries to fetch.
     */
    orderBy?: MatchSummaryOrderByWithRelationInput | MatchSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchSummaries.
     */
    cursor?: MatchSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchSummaries.
     */
    skip?: number
    distinct?: MatchSummaryScalarFieldEnum | MatchSummaryScalarFieldEnum[]
  }

  /**
   * MatchSummary create
   */
  export type MatchSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchSummary.
     */
    data: XOR<MatchSummaryCreateInput, MatchSummaryUncheckedCreateInput>
  }

  /**
   * MatchSummary createMany
   */
  export type MatchSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchSummaries.
     */
    data: MatchSummaryCreateManyInput | MatchSummaryCreateManyInput[]
  }

  /**
   * MatchSummary update
   */
  export type MatchSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchSummary.
     */
    data: XOR<MatchSummaryUpdateInput, MatchSummaryUncheckedUpdateInput>
    /**
     * Choose, which MatchSummary to update.
     */
    where: MatchSummaryWhereUniqueInput
  }

  /**
   * MatchSummary updateMany
   */
  export type MatchSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchSummaries.
     */
    data: XOR<MatchSummaryUpdateManyMutationInput, MatchSummaryUncheckedUpdateManyInput>
    /**
     * Filter which MatchSummaries to update
     */
    where?: MatchSummaryWhereInput
    /**
     * Limit how many MatchSummaries to update.
     */
    limit?: number
  }

  /**
   * MatchSummary upsert
   */
  export type MatchSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchSummary to update in case it exists.
     */
    where: MatchSummaryWhereUniqueInput
    /**
     * In case the MatchSummary found by the `where` argument doesn't exist, create a new MatchSummary with this data.
     */
    create: XOR<MatchSummaryCreateInput, MatchSummaryUncheckedCreateInput>
    /**
     * In case the MatchSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchSummaryUpdateInput, MatchSummaryUncheckedUpdateInput>
  }

  /**
   * MatchSummary delete
   */
  export type MatchSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
    /**
     * Filter which MatchSummary to delete.
     */
    where: MatchSummaryWhereUniqueInput
  }

  /**
   * MatchSummary deleteMany
   */
  export type MatchSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchSummaries to delete
     */
    where?: MatchSummaryWhereInput
    /**
     * Limit how many MatchSummaries to delete.
     */
    limit?: number
  }

  /**
   * MatchSummary findRaw
   */
  export type MatchSummaryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MatchSummary aggregateRaw
   */
  export type MatchSummaryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MatchSummary.homeTeam
   */
  export type MatchSummary$homeTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * MatchSummary.awayTeam
   */
  export type MatchSummary$awayTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * MatchSummary.manOfTheMatchUser
   */
  export type MatchSummary$manOfTheMatchUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MatchSummary.playerHistory
   */
  export type MatchSummary$playerHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    where?: PlayerMatchHistoryWhereInput
    orderBy?: PlayerMatchHistoryOrderByWithRelationInput | PlayerMatchHistoryOrderByWithRelationInput[]
    cursor?: PlayerMatchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerMatchHistoryScalarFieldEnum | PlayerMatchHistoryScalarFieldEnum[]
  }

  /**
   * MatchSummary without action
   */
  export type MatchSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchSummary
     */
    select?: MatchSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchSummary
     */
    omit?: MatchSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchSummaryInclude<ExtArgs> | null
  }


  /**
   * Model PlayerMatchHistory
   */

  export type AggregatePlayerMatchHistory = {
    _count: PlayerMatchHistoryCountAggregateOutputType | null
    _avg: PlayerMatchHistoryAvgAggregateOutputType | null
    _sum: PlayerMatchHistorySumAggregateOutputType | null
    _min: PlayerMatchHistoryMinAggregateOutputType | null
    _max: PlayerMatchHistoryMaxAggregateOutputType | null
  }

  export type PlayerMatchHistoryAvgAggregateOutputType = {
    runsScored: number | null
    ballsFaced: number | null
    wicketsTaken: number | null
    oversBowled: number | null
  }

  export type PlayerMatchHistorySumAggregateOutputType = {
    runsScored: number | null
    ballsFaced: number | null
    wicketsTaken: number | null
    oversBowled: number | null
  }

  export type PlayerMatchHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    matchSummaryId: string | null
    teamName: string | null
    teamId: string | null
    playerName: string | null
    runsScored: number | null
    ballsFaced: number | null
    wicketsTaken: number | null
    oversBowled: number | null
    isManOfTheMatch: boolean | null
    createdAt: Date | null
  }

  export type PlayerMatchHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    matchSummaryId: string | null
    teamName: string | null
    teamId: string | null
    playerName: string | null
    runsScored: number | null
    ballsFaced: number | null
    wicketsTaken: number | null
    oversBowled: number | null
    isManOfTheMatch: boolean | null
    createdAt: Date | null
  }

  export type PlayerMatchHistoryCountAggregateOutputType = {
    id: number
    userId: number
    matchSummaryId: number
    teamName: number
    teamId: number
    playerName: number
    runsScored: number
    ballsFaced: number
    wicketsTaken: number
    oversBowled: number
    isManOfTheMatch: number
    createdAt: number
    _all: number
  }


  export type PlayerMatchHistoryAvgAggregateInputType = {
    runsScored?: true
    ballsFaced?: true
    wicketsTaken?: true
    oversBowled?: true
  }

  export type PlayerMatchHistorySumAggregateInputType = {
    runsScored?: true
    ballsFaced?: true
    wicketsTaken?: true
    oversBowled?: true
  }

  export type PlayerMatchHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    matchSummaryId?: true
    teamName?: true
    teamId?: true
    playerName?: true
    runsScored?: true
    ballsFaced?: true
    wicketsTaken?: true
    oversBowled?: true
    isManOfTheMatch?: true
    createdAt?: true
  }

  export type PlayerMatchHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    matchSummaryId?: true
    teamName?: true
    teamId?: true
    playerName?: true
    runsScored?: true
    ballsFaced?: true
    wicketsTaken?: true
    oversBowled?: true
    isManOfTheMatch?: true
    createdAt?: true
  }

  export type PlayerMatchHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    matchSummaryId?: true
    teamName?: true
    teamId?: true
    playerName?: true
    runsScored?: true
    ballsFaced?: true
    wicketsTaken?: true
    oversBowled?: true
    isManOfTheMatch?: true
    createdAt?: true
    _all?: true
  }

  export type PlayerMatchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMatchHistory to aggregate.
     */
    where?: PlayerMatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMatchHistories to fetch.
     */
    orderBy?: PlayerMatchHistoryOrderByWithRelationInput | PlayerMatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerMatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMatchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerMatchHistories
    **/
    _count?: true | PlayerMatchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerMatchHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerMatchHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMatchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMatchHistoryMaxAggregateInputType
  }

  export type GetPlayerMatchHistoryAggregateType<T extends PlayerMatchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerMatchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerMatchHistory[P]>
      : GetScalarType<T[P], AggregatePlayerMatchHistory[P]>
  }




  export type PlayerMatchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMatchHistoryWhereInput
    orderBy?: PlayerMatchHistoryOrderByWithAggregationInput | PlayerMatchHistoryOrderByWithAggregationInput[]
    by: PlayerMatchHistoryScalarFieldEnum[] | PlayerMatchHistoryScalarFieldEnum
    having?: PlayerMatchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerMatchHistoryCountAggregateInputType | true
    _avg?: PlayerMatchHistoryAvgAggregateInputType
    _sum?: PlayerMatchHistorySumAggregateInputType
    _min?: PlayerMatchHistoryMinAggregateInputType
    _max?: PlayerMatchHistoryMaxAggregateInputType
  }

  export type PlayerMatchHistoryGroupByOutputType = {
    id: string
    userId: string
    matchSummaryId: string
    teamName: string
    teamId: string | null
    playerName: string
    runsScored: number
    ballsFaced: number
    wicketsTaken: number
    oversBowled: number
    isManOfTheMatch: boolean
    createdAt: Date
    _count: PlayerMatchHistoryCountAggregateOutputType | null
    _avg: PlayerMatchHistoryAvgAggregateOutputType | null
    _sum: PlayerMatchHistorySumAggregateOutputType | null
    _min: PlayerMatchHistoryMinAggregateOutputType | null
    _max: PlayerMatchHistoryMaxAggregateOutputType | null
  }

  type GetPlayerMatchHistoryGroupByPayload<T extends PlayerMatchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerMatchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerMatchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerMatchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerMatchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PlayerMatchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matchSummaryId?: boolean
    teamName?: boolean
    teamId?: boolean
    playerName?: boolean
    runsScored?: boolean
    ballsFaced?: boolean
    wicketsTaken?: boolean
    oversBowled?: boolean
    isManOfTheMatch?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    matchSummary?: boolean | MatchSummaryDefaultArgs<ExtArgs>
    team?: boolean | PlayerMatchHistory$teamArgs<ExtArgs>
  }, ExtArgs["result"]["playerMatchHistory"]>



  export type PlayerMatchHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    matchSummaryId?: boolean
    teamName?: boolean
    teamId?: boolean
    playerName?: boolean
    runsScored?: boolean
    ballsFaced?: boolean
    wicketsTaken?: boolean
    oversBowled?: boolean
    isManOfTheMatch?: boolean
    createdAt?: boolean
  }

  export type PlayerMatchHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "matchSummaryId" | "teamName" | "teamId" | "playerName" | "runsScored" | "ballsFaced" | "wicketsTaken" | "oversBowled" | "isManOfTheMatch" | "createdAt", ExtArgs["result"]["playerMatchHistory"]>
  export type PlayerMatchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    matchSummary?: boolean | MatchSummaryDefaultArgs<ExtArgs>
    team?: boolean | PlayerMatchHistory$teamArgs<ExtArgs>
  }

  export type $PlayerMatchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerMatchHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      matchSummary: Prisma.$MatchSummaryPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      matchSummaryId: string
      teamName: string
      teamId: string | null
      playerName: string
      runsScored: number
      ballsFaced: number
      wicketsTaken: number
      oversBowled: number
      isManOfTheMatch: boolean
      createdAt: Date
    }, ExtArgs["result"]["playerMatchHistory"]>
    composites: {}
  }

  type PlayerMatchHistoryGetPayload<S extends boolean | null | undefined | PlayerMatchHistoryDefaultArgs> = $Result.GetResult<Prisma.$PlayerMatchHistoryPayload, S>

  type PlayerMatchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerMatchHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerMatchHistoryCountAggregateInputType | true
    }

  export interface PlayerMatchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerMatchHistory'], meta: { name: 'PlayerMatchHistory' } }
    /**
     * Find zero or one PlayerMatchHistory that matches the filter.
     * @param {PlayerMatchHistoryFindUniqueArgs} args - Arguments to find a PlayerMatchHistory
     * @example
     * // Get one PlayerMatchHistory
     * const playerMatchHistory = await prisma.playerMatchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerMatchHistoryFindUniqueArgs>(args: SelectSubset<T, PlayerMatchHistoryFindUniqueArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlayerMatchHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerMatchHistoryFindUniqueOrThrowArgs} args - Arguments to find a PlayerMatchHistory
     * @example
     * // Get one PlayerMatchHistory
     * const playerMatchHistory = await prisma.playerMatchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerMatchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerMatchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerMatchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMatchHistoryFindFirstArgs} args - Arguments to find a PlayerMatchHistory
     * @example
     * // Get one PlayerMatchHistory
     * const playerMatchHistory = await prisma.playerMatchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerMatchHistoryFindFirstArgs>(args?: SelectSubset<T, PlayerMatchHistoryFindFirstArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlayerMatchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMatchHistoryFindFirstOrThrowArgs} args - Arguments to find a PlayerMatchHistory
     * @example
     * // Get one PlayerMatchHistory
     * const playerMatchHistory = await prisma.playerMatchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerMatchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerMatchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerMatchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMatchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerMatchHistories
     * const playerMatchHistories = await prisma.playerMatchHistory.findMany()
     * 
     * // Get first 10 PlayerMatchHistories
     * const playerMatchHistories = await prisma.playerMatchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerMatchHistoryWithIdOnly = await prisma.playerMatchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerMatchHistoryFindManyArgs>(args?: SelectSubset<T, PlayerMatchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlayerMatchHistory.
     * @param {PlayerMatchHistoryCreateArgs} args - Arguments to create a PlayerMatchHistory.
     * @example
     * // Create one PlayerMatchHistory
     * const PlayerMatchHistory = await prisma.playerMatchHistory.create({
     *   data: {
     *     // ... data to create a PlayerMatchHistory
     *   }
     * })
     * 
     */
    create<T extends PlayerMatchHistoryCreateArgs>(args: SelectSubset<T, PlayerMatchHistoryCreateArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlayerMatchHistories.
     * @param {PlayerMatchHistoryCreateManyArgs} args - Arguments to create many PlayerMatchHistories.
     * @example
     * // Create many PlayerMatchHistories
     * const playerMatchHistory = await prisma.playerMatchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerMatchHistoryCreateManyArgs>(args?: SelectSubset<T, PlayerMatchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlayerMatchHistory.
     * @param {PlayerMatchHistoryDeleteArgs} args - Arguments to delete one PlayerMatchHistory.
     * @example
     * // Delete one PlayerMatchHistory
     * const PlayerMatchHistory = await prisma.playerMatchHistory.delete({
     *   where: {
     *     // ... filter to delete one PlayerMatchHistory
     *   }
     * })
     * 
     */
    delete<T extends PlayerMatchHistoryDeleteArgs>(args: SelectSubset<T, PlayerMatchHistoryDeleteArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlayerMatchHistory.
     * @param {PlayerMatchHistoryUpdateArgs} args - Arguments to update one PlayerMatchHistory.
     * @example
     * // Update one PlayerMatchHistory
     * const playerMatchHistory = await prisma.playerMatchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerMatchHistoryUpdateArgs>(args: SelectSubset<T, PlayerMatchHistoryUpdateArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlayerMatchHistories.
     * @param {PlayerMatchHistoryDeleteManyArgs} args - Arguments to filter PlayerMatchHistories to delete.
     * @example
     * // Delete a few PlayerMatchHistories
     * const { count } = await prisma.playerMatchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerMatchHistoryDeleteManyArgs>(args?: SelectSubset<T, PlayerMatchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerMatchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMatchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerMatchHistories
     * const playerMatchHistory = await prisma.playerMatchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerMatchHistoryUpdateManyArgs>(args: SelectSubset<T, PlayerMatchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerMatchHistory.
     * @param {PlayerMatchHistoryUpsertArgs} args - Arguments to update or create a PlayerMatchHistory.
     * @example
     * // Update or create a PlayerMatchHistory
     * const playerMatchHistory = await prisma.playerMatchHistory.upsert({
     *   create: {
     *     // ... data to create a PlayerMatchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerMatchHistory we want to update
     *   }
     * })
     */
    upsert<T extends PlayerMatchHistoryUpsertArgs>(args: SelectSubset<T, PlayerMatchHistoryUpsertArgs<ExtArgs>>): Prisma__PlayerMatchHistoryClient<$Result.GetResult<Prisma.$PlayerMatchHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlayerMatchHistories that matches the filter.
     * @param {PlayerMatchHistoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const playerMatchHistory = await prisma.playerMatchHistory.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PlayerMatchHistoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PlayerMatchHistory.
     * @param {PlayerMatchHistoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const playerMatchHistory = await prisma.playerMatchHistory.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PlayerMatchHistoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PlayerMatchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMatchHistoryCountArgs} args - Arguments to filter PlayerMatchHistories to count.
     * @example
     * // Count the number of PlayerMatchHistories
     * const count = await prisma.playerMatchHistory.count({
     *   where: {
     *     // ... the filter for the PlayerMatchHistories we want to count
     *   }
     * })
    **/
    count<T extends PlayerMatchHistoryCountArgs>(
      args?: Subset<T, PlayerMatchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerMatchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerMatchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMatchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerMatchHistoryAggregateArgs>(args: Subset<T, PlayerMatchHistoryAggregateArgs>): Prisma.PrismaPromise<GetPlayerMatchHistoryAggregateType<T>>

    /**
     * Group by PlayerMatchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMatchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerMatchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerMatchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PlayerMatchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerMatchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerMatchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerMatchHistory model
   */
  readonly fields: PlayerMatchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerMatchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerMatchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    matchSummary<T extends MatchSummaryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchSummaryDefaultArgs<ExtArgs>>): Prisma__MatchSummaryClient<$Result.GetResult<Prisma.$MatchSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends PlayerMatchHistory$teamArgs<ExtArgs> = {}>(args?: Subset<T, PlayerMatchHistory$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerMatchHistory model
   */
  interface PlayerMatchHistoryFieldRefs {
    readonly id: FieldRef<"PlayerMatchHistory", 'String'>
    readonly userId: FieldRef<"PlayerMatchHistory", 'String'>
    readonly matchSummaryId: FieldRef<"PlayerMatchHistory", 'String'>
    readonly teamName: FieldRef<"PlayerMatchHistory", 'String'>
    readonly teamId: FieldRef<"PlayerMatchHistory", 'String'>
    readonly playerName: FieldRef<"PlayerMatchHistory", 'String'>
    readonly runsScored: FieldRef<"PlayerMatchHistory", 'Int'>
    readonly ballsFaced: FieldRef<"PlayerMatchHistory", 'Int'>
    readonly wicketsTaken: FieldRef<"PlayerMatchHistory", 'Int'>
    readonly oversBowled: FieldRef<"PlayerMatchHistory", 'Float'>
    readonly isManOfTheMatch: FieldRef<"PlayerMatchHistory", 'Boolean'>
    readonly createdAt: FieldRef<"PlayerMatchHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlayerMatchHistory findUnique
   */
  export type PlayerMatchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMatchHistory to fetch.
     */
    where: PlayerMatchHistoryWhereUniqueInput
  }

  /**
   * PlayerMatchHistory findUniqueOrThrow
   */
  export type PlayerMatchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMatchHistory to fetch.
     */
    where: PlayerMatchHistoryWhereUniqueInput
  }

  /**
   * PlayerMatchHistory findFirst
   */
  export type PlayerMatchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMatchHistory to fetch.
     */
    where?: PlayerMatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMatchHistories to fetch.
     */
    orderBy?: PlayerMatchHistoryOrderByWithRelationInput | PlayerMatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMatchHistories.
     */
    cursor?: PlayerMatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMatchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMatchHistories.
     */
    distinct?: PlayerMatchHistoryScalarFieldEnum | PlayerMatchHistoryScalarFieldEnum[]
  }

  /**
   * PlayerMatchHistory findFirstOrThrow
   */
  export type PlayerMatchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMatchHistory to fetch.
     */
    where?: PlayerMatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMatchHistories to fetch.
     */
    orderBy?: PlayerMatchHistoryOrderByWithRelationInput | PlayerMatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMatchHistories.
     */
    cursor?: PlayerMatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMatchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMatchHistories.
     */
    distinct?: PlayerMatchHistoryScalarFieldEnum | PlayerMatchHistoryScalarFieldEnum[]
  }

  /**
   * PlayerMatchHistory findMany
   */
  export type PlayerMatchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMatchHistories to fetch.
     */
    where?: PlayerMatchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMatchHistories to fetch.
     */
    orderBy?: PlayerMatchHistoryOrderByWithRelationInput | PlayerMatchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerMatchHistories.
     */
    cursor?: PlayerMatchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMatchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMatchHistories.
     */
    skip?: number
    distinct?: PlayerMatchHistoryScalarFieldEnum | PlayerMatchHistoryScalarFieldEnum[]
  }

  /**
   * PlayerMatchHistory create
   */
  export type PlayerMatchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerMatchHistory.
     */
    data: XOR<PlayerMatchHistoryCreateInput, PlayerMatchHistoryUncheckedCreateInput>
  }

  /**
   * PlayerMatchHistory createMany
   */
  export type PlayerMatchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerMatchHistories.
     */
    data: PlayerMatchHistoryCreateManyInput | PlayerMatchHistoryCreateManyInput[]
  }

  /**
   * PlayerMatchHistory update
   */
  export type PlayerMatchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerMatchHistory.
     */
    data: XOR<PlayerMatchHistoryUpdateInput, PlayerMatchHistoryUncheckedUpdateInput>
    /**
     * Choose, which PlayerMatchHistory to update.
     */
    where: PlayerMatchHistoryWhereUniqueInput
  }

  /**
   * PlayerMatchHistory updateMany
   */
  export type PlayerMatchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerMatchHistories.
     */
    data: XOR<PlayerMatchHistoryUpdateManyMutationInput, PlayerMatchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PlayerMatchHistories to update
     */
    where?: PlayerMatchHistoryWhereInput
    /**
     * Limit how many PlayerMatchHistories to update.
     */
    limit?: number
  }

  /**
   * PlayerMatchHistory upsert
   */
  export type PlayerMatchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerMatchHistory to update in case it exists.
     */
    where: PlayerMatchHistoryWhereUniqueInput
    /**
     * In case the PlayerMatchHistory found by the `where` argument doesn't exist, create a new PlayerMatchHistory with this data.
     */
    create: XOR<PlayerMatchHistoryCreateInput, PlayerMatchHistoryUncheckedCreateInput>
    /**
     * In case the PlayerMatchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerMatchHistoryUpdateInput, PlayerMatchHistoryUncheckedUpdateInput>
  }

  /**
   * PlayerMatchHistory delete
   */
  export type PlayerMatchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
    /**
     * Filter which PlayerMatchHistory to delete.
     */
    where: PlayerMatchHistoryWhereUniqueInput
  }

  /**
   * PlayerMatchHistory deleteMany
   */
  export type PlayerMatchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMatchHistories to delete
     */
    where?: PlayerMatchHistoryWhereInput
    /**
     * Limit how many PlayerMatchHistories to delete.
     */
    limit?: number
  }

  /**
   * PlayerMatchHistory findRaw
   */
  export type PlayerMatchHistoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlayerMatchHistory aggregateRaw
   */
  export type PlayerMatchHistoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PlayerMatchHistory.team
   */
  export type PlayerMatchHistory$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * PlayerMatchHistory without action
   */
  export type PlayerMatchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMatchHistory
     */
    select?: PlayerMatchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlayerMatchHistory
     */
    omit?: PlayerMatchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMatchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Fixture
   */

  export type AggregateFixture = {
    _count: FixtureCountAggregateOutputType | null
    _avg: FixtureAvgAggregateOutputType | null
    _sum: FixtureSumAggregateOutputType | null
    _min: FixtureMinAggregateOutputType | null
    _max: FixtureMaxAggregateOutputType | null
  }

  export type FixtureAvgAggregateOutputType = {
    overs: number | null
  }

  export type FixtureSumAggregateOutputType = {
    overs: number | null
  }

  export type FixtureMinAggregateOutputType = {
    id: string | null
    userId: string | null
    teamAId: string | null
    teamAName: string | null
    teamALogo: string | null
    teamBId: string | null
    teamBName: string | null
    teamBLogo: string | null
    overs: number | null
    venue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixtureMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    teamAId: string | null
    teamAName: string | null
    teamALogo: string | null
    teamBId: string | null
    teamBName: string | null
    teamBLogo: string | null
    overs: number | null
    venue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FixtureCountAggregateOutputType = {
    id: number
    userId: number
    teamAId: number
    teamAName: number
    teamALogo: number
    teamAPlayers: number
    teamBId: number
    teamBName: number
    teamBLogo: number
    teamBPlayers: number
    overs: number
    venue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FixtureAvgAggregateInputType = {
    overs?: true
  }

  export type FixtureSumAggregateInputType = {
    overs?: true
  }

  export type FixtureMinAggregateInputType = {
    id?: true
    userId?: true
    teamAId?: true
    teamAName?: true
    teamALogo?: true
    teamBId?: true
    teamBName?: true
    teamBLogo?: true
    overs?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixtureMaxAggregateInputType = {
    id?: true
    userId?: true
    teamAId?: true
    teamAName?: true
    teamALogo?: true
    teamBId?: true
    teamBName?: true
    teamBLogo?: true
    overs?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FixtureCountAggregateInputType = {
    id?: true
    userId?: true
    teamAId?: true
    teamAName?: true
    teamALogo?: true
    teamAPlayers?: true
    teamBId?: true
    teamBName?: true
    teamBLogo?: true
    teamBPlayers?: true
    overs?: true
    venue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FixtureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fixture to aggregate.
     */
    where?: FixtureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fixtures to fetch.
     */
    orderBy?: FixtureOrderByWithRelationInput | FixtureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FixtureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fixtures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fixtures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fixtures
    **/
    _count?: true | FixtureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FixtureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FixtureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FixtureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FixtureMaxAggregateInputType
  }

  export type GetFixtureAggregateType<T extends FixtureAggregateArgs> = {
        [P in keyof T & keyof AggregateFixture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFixture[P]>
      : GetScalarType<T[P], AggregateFixture[P]>
  }




  export type FixtureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FixtureWhereInput
    orderBy?: FixtureOrderByWithAggregationInput | FixtureOrderByWithAggregationInput[]
    by: FixtureScalarFieldEnum[] | FixtureScalarFieldEnum
    having?: FixtureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FixtureCountAggregateInputType | true
    _avg?: FixtureAvgAggregateInputType
    _sum?: FixtureSumAggregateInputType
    _min?: FixtureMinAggregateInputType
    _max?: FixtureMaxAggregateInputType
  }

  export type FixtureGroupByOutputType = {
    id: string
    userId: string
    teamAId: string | null
    teamAName: string
    teamALogo: string | null
    teamAPlayers: JsonValue
    teamBId: string | null
    teamBName: string
    teamBLogo: string | null
    teamBPlayers: JsonValue
    overs: number
    venue: string | null
    createdAt: Date
    updatedAt: Date
    _count: FixtureCountAggregateOutputType | null
    _avg: FixtureAvgAggregateOutputType | null
    _sum: FixtureSumAggregateOutputType | null
    _min: FixtureMinAggregateOutputType | null
    _max: FixtureMaxAggregateOutputType | null
  }

  type GetFixtureGroupByPayload<T extends FixtureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FixtureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FixtureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FixtureGroupByOutputType[P]>
            : GetScalarType<T[P], FixtureGroupByOutputType[P]>
        }
      >
    >


  export type FixtureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    teamAId?: boolean
    teamAName?: boolean
    teamALogo?: boolean
    teamAPlayers?: boolean
    teamBId?: boolean
    teamBName?: boolean
    teamBLogo?: boolean
    teamBPlayers?: boolean
    overs?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fixture"]>



  export type FixtureSelectScalar = {
    id?: boolean
    userId?: boolean
    teamAId?: boolean
    teamAName?: boolean
    teamALogo?: boolean
    teamAPlayers?: boolean
    teamBId?: boolean
    teamBName?: boolean
    teamBLogo?: boolean
    teamBPlayers?: boolean
    overs?: boolean
    venue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FixtureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "teamAId" | "teamAName" | "teamALogo" | "teamAPlayers" | "teamBId" | "teamBName" | "teamBLogo" | "teamBPlayers" | "overs" | "venue" | "createdAt" | "updatedAt", ExtArgs["result"]["fixture"]>
  export type FixtureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FixturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fixture"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      teamAId: string | null
      teamAName: string
      teamALogo: string | null
      teamAPlayers: Prisma.JsonValue
      teamBId: string | null
      teamBName: string
      teamBLogo: string | null
      teamBPlayers: Prisma.JsonValue
      overs: number
      venue: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fixture"]>
    composites: {}
  }

  type FixtureGetPayload<S extends boolean | null | undefined | FixtureDefaultArgs> = $Result.GetResult<Prisma.$FixturePayload, S>

  type FixtureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FixtureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FixtureCountAggregateInputType | true
    }

  export interface FixtureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fixture'], meta: { name: 'Fixture' } }
    /**
     * Find zero or one Fixture that matches the filter.
     * @param {FixtureFindUniqueArgs} args - Arguments to find a Fixture
     * @example
     * // Get one Fixture
     * const fixture = await prisma.fixture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FixtureFindUniqueArgs>(args: SelectSubset<T, FixtureFindUniqueArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fixture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FixtureFindUniqueOrThrowArgs} args - Arguments to find a Fixture
     * @example
     * // Get one Fixture
     * const fixture = await prisma.fixture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FixtureFindUniqueOrThrowArgs>(args: SelectSubset<T, FixtureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fixture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixtureFindFirstArgs} args - Arguments to find a Fixture
     * @example
     * // Get one Fixture
     * const fixture = await prisma.fixture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FixtureFindFirstArgs>(args?: SelectSubset<T, FixtureFindFirstArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fixture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixtureFindFirstOrThrowArgs} args - Arguments to find a Fixture
     * @example
     * // Get one Fixture
     * const fixture = await prisma.fixture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FixtureFindFirstOrThrowArgs>(args?: SelectSubset<T, FixtureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fixtures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixtureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fixtures
     * const fixtures = await prisma.fixture.findMany()
     * 
     * // Get first 10 Fixtures
     * const fixtures = await prisma.fixture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fixtureWithIdOnly = await prisma.fixture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FixtureFindManyArgs>(args?: SelectSubset<T, FixtureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fixture.
     * @param {FixtureCreateArgs} args - Arguments to create a Fixture.
     * @example
     * // Create one Fixture
     * const Fixture = await prisma.fixture.create({
     *   data: {
     *     // ... data to create a Fixture
     *   }
     * })
     * 
     */
    create<T extends FixtureCreateArgs>(args: SelectSubset<T, FixtureCreateArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fixtures.
     * @param {FixtureCreateManyArgs} args - Arguments to create many Fixtures.
     * @example
     * // Create many Fixtures
     * const fixture = await prisma.fixture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FixtureCreateManyArgs>(args?: SelectSubset<T, FixtureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fixture.
     * @param {FixtureDeleteArgs} args - Arguments to delete one Fixture.
     * @example
     * // Delete one Fixture
     * const Fixture = await prisma.fixture.delete({
     *   where: {
     *     // ... filter to delete one Fixture
     *   }
     * })
     * 
     */
    delete<T extends FixtureDeleteArgs>(args: SelectSubset<T, FixtureDeleteArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fixture.
     * @param {FixtureUpdateArgs} args - Arguments to update one Fixture.
     * @example
     * // Update one Fixture
     * const fixture = await prisma.fixture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FixtureUpdateArgs>(args: SelectSubset<T, FixtureUpdateArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fixtures.
     * @param {FixtureDeleteManyArgs} args - Arguments to filter Fixtures to delete.
     * @example
     * // Delete a few Fixtures
     * const { count } = await prisma.fixture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FixtureDeleteManyArgs>(args?: SelectSubset<T, FixtureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fixtures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixtureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fixtures
     * const fixture = await prisma.fixture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FixtureUpdateManyArgs>(args: SelectSubset<T, FixtureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fixture.
     * @param {FixtureUpsertArgs} args - Arguments to update or create a Fixture.
     * @example
     * // Update or create a Fixture
     * const fixture = await prisma.fixture.upsert({
     *   create: {
     *     // ... data to create a Fixture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fixture we want to update
     *   }
     * })
     */
    upsert<T extends FixtureUpsertArgs>(args: SelectSubset<T, FixtureUpsertArgs<ExtArgs>>): Prisma__FixtureClient<$Result.GetResult<Prisma.$FixturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fixtures that matches the filter.
     * @param {FixtureFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fixture = await prisma.fixture.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FixtureFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Fixture.
     * @param {FixtureAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fixture = await prisma.fixture.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FixtureAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Fixtures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixtureCountArgs} args - Arguments to filter Fixtures to count.
     * @example
     * // Count the number of Fixtures
     * const count = await prisma.fixture.count({
     *   where: {
     *     // ... the filter for the Fixtures we want to count
     *   }
     * })
    **/
    count<T extends FixtureCountArgs>(
      args?: Subset<T, FixtureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FixtureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fixture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixtureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FixtureAggregateArgs>(args: Subset<T, FixtureAggregateArgs>): Prisma.PrismaPromise<GetFixtureAggregateType<T>>

    /**
     * Group by Fixture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FixtureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FixtureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FixtureGroupByArgs['orderBy'] }
        : { orderBy?: FixtureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FixtureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFixtureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fixture model
   */
  readonly fields: FixtureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fixture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FixtureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fixture model
   */
  interface FixtureFieldRefs {
    readonly id: FieldRef<"Fixture", 'String'>
    readonly userId: FieldRef<"Fixture", 'String'>
    readonly teamAId: FieldRef<"Fixture", 'String'>
    readonly teamAName: FieldRef<"Fixture", 'String'>
    readonly teamALogo: FieldRef<"Fixture", 'String'>
    readonly teamAPlayers: FieldRef<"Fixture", 'Json'>
    readonly teamBId: FieldRef<"Fixture", 'String'>
    readonly teamBName: FieldRef<"Fixture", 'String'>
    readonly teamBLogo: FieldRef<"Fixture", 'String'>
    readonly teamBPlayers: FieldRef<"Fixture", 'Json'>
    readonly overs: FieldRef<"Fixture", 'Int'>
    readonly venue: FieldRef<"Fixture", 'String'>
    readonly createdAt: FieldRef<"Fixture", 'DateTime'>
    readonly updatedAt: FieldRef<"Fixture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fixture findUnique
   */
  export type FixtureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * Filter, which Fixture to fetch.
     */
    where: FixtureWhereUniqueInput
  }

  /**
   * Fixture findUniqueOrThrow
   */
  export type FixtureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * Filter, which Fixture to fetch.
     */
    where: FixtureWhereUniqueInput
  }

  /**
   * Fixture findFirst
   */
  export type FixtureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * Filter, which Fixture to fetch.
     */
    where?: FixtureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fixtures to fetch.
     */
    orderBy?: FixtureOrderByWithRelationInput | FixtureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fixtures.
     */
    cursor?: FixtureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fixtures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fixtures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fixtures.
     */
    distinct?: FixtureScalarFieldEnum | FixtureScalarFieldEnum[]
  }

  /**
   * Fixture findFirstOrThrow
   */
  export type FixtureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * Filter, which Fixture to fetch.
     */
    where?: FixtureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fixtures to fetch.
     */
    orderBy?: FixtureOrderByWithRelationInput | FixtureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fixtures.
     */
    cursor?: FixtureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fixtures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fixtures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fixtures.
     */
    distinct?: FixtureScalarFieldEnum | FixtureScalarFieldEnum[]
  }

  /**
   * Fixture findMany
   */
  export type FixtureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * Filter, which Fixtures to fetch.
     */
    where?: FixtureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fixtures to fetch.
     */
    orderBy?: FixtureOrderByWithRelationInput | FixtureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fixtures.
     */
    cursor?: FixtureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fixtures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fixtures.
     */
    skip?: number
    distinct?: FixtureScalarFieldEnum | FixtureScalarFieldEnum[]
  }

  /**
   * Fixture create
   */
  export type FixtureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * The data needed to create a Fixture.
     */
    data: XOR<FixtureCreateInput, FixtureUncheckedCreateInput>
  }

  /**
   * Fixture createMany
   */
  export type FixtureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fixtures.
     */
    data: FixtureCreateManyInput | FixtureCreateManyInput[]
  }

  /**
   * Fixture update
   */
  export type FixtureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * The data needed to update a Fixture.
     */
    data: XOR<FixtureUpdateInput, FixtureUncheckedUpdateInput>
    /**
     * Choose, which Fixture to update.
     */
    where: FixtureWhereUniqueInput
  }

  /**
   * Fixture updateMany
   */
  export type FixtureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fixtures.
     */
    data: XOR<FixtureUpdateManyMutationInput, FixtureUncheckedUpdateManyInput>
    /**
     * Filter which Fixtures to update
     */
    where?: FixtureWhereInput
    /**
     * Limit how many Fixtures to update.
     */
    limit?: number
  }

  /**
   * Fixture upsert
   */
  export type FixtureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * The filter to search for the Fixture to update in case it exists.
     */
    where: FixtureWhereUniqueInput
    /**
     * In case the Fixture found by the `where` argument doesn't exist, create a new Fixture with this data.
     */
    create: XOR<FixtureCreateInput, FixtureUncheckedCreateInput>
    /**
     * In case the Fixture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FixtureUpdateInput, FixtureUncheckedUpdateInput>
  }

  /**
   * Fixture delete
   */
  export type FixtureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
    /**
     * Filter which Fixture to delete.
     */
    where: FixtureWhereUniqueInput
  }

  /**
   * Fixture deleteMany
   */
  export type FixtureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fixtures to delete
     */
    where?: FixtureWhereInput
    /**
     * Limit how many Fixtures to delete.
     */
    limit?: number
  }

  /**
   * Fixture findRaw
   */
  export type FixtureFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Fixture aggregateRaw
   */
  export type FixtureAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Fixture without action
   */
  export type FixtureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fixture
     */
    select?: FixtureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fixture
     */
    omit?: FixtureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FixtureInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    profileName: 'profileName',
    description: 'description',
    profilePictureUrl: 'profilePictureUrl',
    role: 'role',
    battingHand: 'battingHand',
    bowlingStyle: 'bowlingStyle',
    profileComplete: 'profileComplete',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CareerStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    matchesPlayed: 'matchesPlayed',
    totalRuns: 'totalRuns',
    ballsFaced: 'ballsFaced',
    strikeRate: 'strikeRate',
    highestScore: 'highestScore',
    timesOut: 'timesOut',
    oversBowled: 'oversBowled',
    runsConceded: 'runsConceded',
    wicketsTaken: 'wicketsTaken',
    economy: 'economy',
    bestBowlingWickets: 'bestBowlingWickets',
    bestBowlingRuns: 'bestBowlingRuns',
    catchesTaken: 'catchesTaken',
    runOuts: 'runOuts',
    manOfTheMatchAwards: 'manOfTheMatchAwards',
    updatedAt: 'updatedAt'
  };

  export type CareerStatsScalarFieldEnum = (typeof CareerStatsScalarFieldEnum)[keyof typeof CareerStatsScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    teamCode: 'teamCode',
    name: 'name',
    description: 'description',
    logoUrl: 'logoUrl',
    createdById: 'createdById',
    captainId: 'captainId',
    viceCaptainId: 'viceCaptainId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    joinedAt: 'joinedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const GuestPlayerScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    name: 'name',
    addedByUserId: 'addedByUserId',
    linkedUserId: 'linkedUserId',
    createdAt: 'createdAt',
    matchesPlayed: 'matchesPlayed',
    totalRuns: 'totalRuns',
    ballsFaced: 'ballsFaced',
    fours: 'fours',
    sixes: 'sixes',
    wicketsTaken: 'wicketsTaken',
    runsConceded: 'runsConceded',
    oversBowled: 'oversBowled',
    catchesTaken: 'catchesTaken',
    runOuts: 'runOuts'
  };

  export type GuestPlayerScalarFieldEnum = (typeof GuestPlayerScalarFieldEnum)[keyof typeof GuestPlayerScalarFieldEnum]


  export const TeamInvitationScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    invitedBy: 'invitedBy',
    invitedUser: 'invitedUser',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type TeamInvitationScalarFieldEnum = (typeof TeamInvitationScalarFieldEnum)[keyof typeof TeamInvitationScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    opponent: 'opponent',
    matchDate: 'matchDate',
    runsScored: 'runsScored',
    ballsFaced: 'ballsFaced',
    wasDismissed: 'wasDismissed',
    oversBowled: 'oversBowled',
    runsConceded: 'runsConceded',
    wicketsTaken: 'wicketsTaken',
    catchesTaken: 'catchesTaken',
    runOuts: 'runOuts',
    isManOfTheMatch: 'isManOfTheMatch',
    createdAt: 'createdAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const TeamMatchScalarFieldEnum: {
    id: 'id',
    homeTeamId: 'homeTeamId',
    awayTeamId: 'awayTeamId',
    matchDate: 'matchDate',
    venue: 'venue',
    status: 'status',
    result: 'result',
    homeTeamRuns: 'homeTeamRuns',
    homeTeamWickets: 'homeTeamWickets',
    homeTeamOvers: 'homeTeamOvers',
    awayTeamRuns: 'awayTeamRuns',
    awayTeamWickets: 'awayTeamWickets',
    awayTeamOvers: 'awayTeamOvers',
    createdAt: 'createdAt'
  };

  export type TeamMatchScalarFieldEnum = (typeof TeamMatchScalarFieldEnum)[keyof typeof TeamMatchScalarFieldEnum]


  export const TeamMatchPlayerScalarFieldEnum: {
    id: 'id',
    teamMatchId: 'teamMatchId',
    userId: 'userId',
    teamId: 'teamId',
    runsScored: 'runsScored',
    ballsFaced: 'ballsFaced',
    wasDismissed: 'wasDismissed',
    oversBowled: 'oversBowled',
    runsConceded: 'runsConceded',
    wicketsTaken: 'wicketsTaken',
    catchesTaken: 'catchesTaken'
  };

  export type TeamMatchPlayerScalarFieldEnum = (typeof TeamMatchPlayerScalarFieldEnum)[keyof typeof TeamMatchPlayerScalarFieldEnum]


  export const TeamStatisticsScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    matchesPlayed: 'matchesPlayed',
    matchesWon: 'matchesWon',
    matchesLost: 'matchesLost',
    matchesDrawn: 'matchesDrawn',
    winRatio: 'winRatio',
    topRunScorerId: 'topRunScorerId',
    topRunScorerRuns: 'topRunScorerRuns',
    topWicketTakerId: 'topWicketTakerId',
    topWicketTakerWickets: 'topWicketTakerWickets',
    bestStrikeRatePlayerId: 'bestStrikeRatePlayerId',
    bestStrikeRate: 'bestStrikeRate',
    bestEconomyPlayerId: 'bestEconomyPlayerId',
    bestEconomy: 'bestEconomy',
    mostManOfTheMatchPlayerId: 'mostManOfTheMatchPlayerId',
    mostManOfTheMatchAwards: 'mostManOfTheMatchAwards',
    updatedAt: 'updatedAt'
  };

  export type TeamStatisticsScalarFieldEnum = (typeof TeamStatisticsScalarFieldEnum)[keyof typeof TeamStatisticsScalarFieldEnum]


  export const LocalMatchScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    matchName: 'matchName',
    venue: 'venue',
    matchDate: 'matchDate',
    overs: 'overs',
    myTeamName: 'myTeamName',
    myTeamId: 'myTeamId',
    opponentTeamName: 'opponentTeamName',
    opponentTeamId: 'opponentTeamId',
    myTeamPlayers: 'myTeamPlayers',
    opponentTeamPlayers: 'opponentTeamPlayers',
    allowSpectators: 'allowSpectators',
    isRoomMatch: 'isRoomMatch',
    roomPassword: 'roomPassword',
    status: 'status',
    currentInnings: 'currentInnings',
    currentOver: 'currentOver',
    currentBall: 'currentBall',
    myTeamScore: 'myTeamScore',
    myTeamWickets: 'myTeamWickets',
    myTeamOvers: 'myTeamOvers',
    opponentTeamScore: 'opponentTeamScore',
    opponentTeamWickets: 'opponentTeamWickets',
    opponentTeamOvers: 'opponentTeamOvers',
    fullState: 'fullState',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocalMatchScalarFieldEnum = (typeof LocalMatchScalarFieldEnum)[keyof typeof LocalMatchScalarFieldEnum]


  export const MatchSpectatorScalarFieldEnum: {
    id: 'id',
    localMatchId: 'localMatchId',
    userId: 'userId',
    addedBy: 'addedBy',
    addedAt: 'addedAt',
    notified: 'notified'
  };

  export type MatchSpectatorScalarFieldEnum = (typeof MatchSpectatorScalarFieldEnum)[keyof typeof MatchSpectatorScalarFieldEnum]


  export const OverHistoryScalarFieldEnum: {
    id: 'id',
    localMatchId: 'localMatchId',
    overNumber: 'overNumber',
    innings: 'innings',
    balls: 'balls',
    totalRuns: 'totalRuns',
    wickets: 'wickets',
    createdAt: 'createdAt'
  };

  export type OverHistoryScalarFieldEnum = (typeof OverHistoryScalarFieldEnum)[keyof typeof OverHistoryScalarFieldEnum]


  export const MatchSummaryScalarFieldEnum: {
    id: 'id',
    matchDate: 'matchDate',
    venue: 'venue',
    homeTeamName: 'homeTeamName',
    homeTeamId: 'homeTeamId',
    awayTeamName: 'awayTeamName',
    awayTeamId: 'awayTeamId',
    result: 'result',
    winningTeam: 'winningTeam',
    firstInningsTeam: 'firstInningsTeam',
    firstInningsRuns: 'firstInningsRuns',
    firstInningsWickets: 'firstInningsWickets',
    firstInningsOvers: 'firstInningsOvers',
    secondInningsTeam: 'secondInningsTeam',
    secondInningsRuns: 'secondInningsRuns',
    secondInningsWickets: 'secondInningsWickets',
    secondInningsOvers: 'secondInningsOvers',
    target: 'target',
    totalOvers: 'totalOvers',
    manOfTheMatchPlayerName: 'manOfTheMatchPlayerName',
    manOfTheMatchUserId: 'manOfTheMatchUserId',
    manOfTheMatchStats: 'manOfTheMatchStats',
    firstInningsBatsmen: 'firstInningsBatsmen',
    firstInningsBowlers: 'firstInningsBowlers',
    secondInningsBatsmen: 'secondInningsBatsmen',
    secondInningsBowlers: 'secondInningsBowlers',
    createdAt: 'createdAt'
  };

  export type MatchSummaryScalarFieldEnum = (typeof MatchSummaryScalarFieldEnum)[keyof typeof MatchSummaryScalarFieldEnum]


  export const PlayerMatchHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    matchSummaryId: 'matchSummaryId',
    teamName: 'teamName',
    teamId: 'teamId',
    playerName: 'playerName',
    runsScored: 'runsScored',
    ballsFaced: 'ballsFaced',
    wicketsTaken: 'wicketsTaken',
    oversBowled: 'oversBowled',
    isManOfTheMatch: 'isManOfTheMatch',
    createdAt: 'createdAt'
  };

  export type PlayerMatchHistoryScalarFieldEnum = (typeof PlayerMatchHistoryScalarFieldEnum)[keyof typeof PlayerMatchHistoryScalarFieldEnum]


  export const FixtureScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    teamAId: 'teamAId',
    teamAName: 'teamAName',
    teamALogo: 'teamALogo',
    teamAPlayers: 'teamAPlayers',
    teamBId: 'teamBId',
    teamBName: 'teamBName',
    teamBLogo: 'teamBLogo',
    teamBPlayers: 'teamBPlayers',
    overs: 'overs',
    venue: 'venue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FixtureScalarFieldEnum = (typeof FixtureScalarFieldEnum)[keyof typeof FixtureScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'BattingHand'
   */
  export type EnumBattingHandFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattingHand'>
    


  /**
   * Reference to a field of type 'BattingHand[]'
   */
  export type ListEnumBattingHandFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BattingHand[]'>
    


  /**
   * Reference to a field of type 'BowlingStyle'
   */
  export type EnumBowlingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BowlingStyle'>
    


  /**
   * Reference to a field of type 'BowlingStyle[]'
   */
  export type ListEnumBowlingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BowlingStyle[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'MatchResult'
   */
  export type EnumMatchResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchResult'>
    


  /**
   * Reference to a field of type 'MatchResult[]'
   */
  export type ListEnumMatchResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchResult[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'LocalMatchStatus'
   */
  export type EnumLocalMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocalMatchStatus'>
    


  /**
   * Reference to a field of type 'LocalMatchStatus[]'
   */
  export type ListEnumLocalMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocalMatchStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    profileName?: StringNullableFilter<"User"> | string | null
    description?: StringNullableFilter<"User"> | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    battingHand?: EnumBattingHandNullableFilter<"User"> | $Enums.BattingHand | null
    bowlingStyle?: EnumBowlingStyleNullableFilter<"User"> | $Enums.BowlingStyle | null
    profileComplete?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    careerStats?: XOR<CareerStatsNullableScalarRelationFilter, CareerStatsWhereInput> | null
    createdTeams?: TeamListRelationFilter
    captainOfTeams?: TeamListRelationFilter
    viceCaptainOfTeams?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    sentInvitations?: TeamInvitationListRelationFilter
    receivedInvitations?: TeamInvitationListRelationFilter
    guestPlayersAdded?: GuestPlayerListRelationFilter
    guestPlayersLinked?: GuestPlayerListRelationFilter
    matches?: MatchListRelationFilter
    teamMatchStats?: TeamMatchPlayerListRelationFilter
    topRunScorerFor?: TeamStatisticsListRelationFilter
    topWicketTakerFor?: TeamStatisticsListRelationFilter
    bestStrikeRateFor?: TeamStatisticsListRelationFilter
    bestEconomyFor?: TeamStatisticsListRelationFilter
    mostManOfTheMatchFor?: TeamStatisticsListRelationFilter
    createdLocalMatches?: LocalMatchListRelationFilter
    spectatorOf?: MatchSpectatorListRelationFilter
    addedSpectators?: MatchSpectatorListRelationFilter
    matchSummariesAsManOfTheMatch?: MatchSummaryListRelationFilter
    playerMatchHistory?: PlayerMatchHistoryListRelationFilter
    fixtures?: FixtureListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profileName?: SortOrder
    description?: SortOrder
    profilePictureUrl?: SortOrder
    role?: SortOrder
    battingHand?: SortOrder
    bowlingStyle?: SortOrder
    profileComplete?: SortOrder
    createdAt?: SortOrder
    careerStats?: CareerStatsOrderByWithRelationInput
    createdTeams?: TeamOrderByRelationAggregateInput
    captainOfTeams?: TeamOrderByRelationAggregateInput
    viceCaptainOfTeams?: TeamOrderByRelationAggregateInput
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    sentInvitations?: TeamInvitationOrderByRelationAggregateInput
    receivedInvitations?: TeamInvitationOrderByRelationAggregateInput
    guestPlayersAdded?: GuestPlayerOrderByRelationAggregateInput
    guestPlayersLinked?: GuestPlayerOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
    teamMatchStats?: TeamMatchPlayerOrderByRelationAggregateInput
    topRunScorerFor?: TeamStatisticsOrderByRelationAggregateInput
    topWicketTakerFor?: TeamStatisticsOrderByRelationAggregateInput
    bestStrikeRateFor?: TeamStatisticsOrderByRelationAggregateInput
    bestEconomyFor?: TeamStatisticsOrderByRelationAggregateInput
    mostManOfTheMatchFor?: TeamStatisticsOrderByRelationAggregateInput
    createdLocalMatches?: LocalMatchOrderByRelationAggregateInput
    spectatorOf?: MatchSpectatorOrderByRelationAggregateInput
    addedSpectators?: MatchSpectatorOrderByRelationAggregateInput
    matchSummariesAsManOfTheMatch?: MatchSummaryOrderByRelationAggregateInput
    playerMatchHistory?: PlayerMatchHistoryOrderByRelationAggregateInput
    fixtures?: FixtureOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    profileName?: StringNullableFilter<"User"> | string | null
    description?: StringNullableFilter<"User"> | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    battingHand?: EnumBattingHandNullableFilter<"User"> | $Enums.BattingHand | null
    bowlingStyle?: EnumBowlingStyleNullableFilter<"User"> | $Enums.BowlingStyle | null
    profileComplete?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    careerStats?: XOR<CareerStatsNullableScalarRelationFilter, CareerStatsWhereInput> | null
    createdTeams?: TeamListRelationFilter
    captainOfTeams?: TeamListRelationFilter
    viceCaptainOfTeams?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    sentInvitations?: TeamInvitationListRelationFilter
    receivedInvitations?: TeamInvitationListRelationFilter
    guestPlayersAdded?: GuestPlayerListRelationFilter
    guestPlayersLinked?: GuestPlayerListRelationFilter
    matches?: MatchListRelationFilter
    teamMatchStats?: TeamMatchPlayerListRelationFilter
    topRunScorerFor?: TeamStatisticsListRelationFilter
    topWicketTakerFor?: TeamStatisticsListRelationFilter
    bestStrikeRateFor?: TeamStatisticsListRelationFilter
    bestEconomyFor?: TeamStatisticsListRelationFilter
    mostManOfTheMatchFor?: TeamStatisticsListRelationFilter
    createdLocalMatches?: LocalMatchListRelationFilter
    spectatorOf?: MatchSpectatorListRelationFilter
    addedSpectators?: MatchSpectatorListRelationFilter
    matchSummariesAsManOfTheMatch?: MatchSummaryListRelationFilter
    playerMatchHistory?: PlayerMatchHistoryListRelationFilter
    fixtures?: FixtureListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profileName?: SortOrder
    description?: SortOrder
    profilePictureUrl?: SortOrder
    role?: SortOrder
    battingHand?: SortOrder
    bowlingStyle?: SortOrder
    profileComplete?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileName?: StringNullableWithAggregatesFilter<"User"> | string | null
    description?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePictureUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleNullableWithAggregatesFilter<"User"> | $Enums.Role | null
    battingHand?: EnumBattingHandNullableWithAggregatesFilter<"User"> | $Enums.BattingHand | null
    bowlingStyle?: EnumBowlingStyleNullableWithAggregatesFilter<"User"> | $Enums.BowlingStyle | null
    profileComplete?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CareerStatsWhereInput = {
    AND?: CareerStatsWhereInput | CareerStatsWhereInput[]
    OR?: CareerStatsWhereInput[]
    NOT?: CareerStatsWhereInput | CareerStatsWhereInput[]
    id?: StringFilter<"CareerStats"> | string
    userId?: StringFilter<"CareerStats"> | string
    matchesPlayed?: IntFilter<"CareerStats"> | number
    totalRuns?: IntFilter<"CareerStats"> | number
    ballsFaced?: IntFilter<"CareerStats"> | number
    strikeRate?: FloatFilter<"CareerStats"> | number
    highestScore?: IntFilter<"CareerStats"> | number
    timesOut?: IntFilter<"CareerStats"> | number
    oversBowled?: FloatFilter<"CareerStats"> | number
    runsConceded?: IntFilter<"CareerStats"> | number
    wicketsTaken?: IntFilter<"CareerStats"> | number
    economy?: FloatFilter<"CareerStats"> | number
    bestBowlingWickets?: IntFilter<"CareerStats"> | number
    bestBowlingRuns?: IntFilter<"CareerStats"> | number
    catchesTaken?: IntFilter<"CareerStats"> | number
    runOuts?: IntFilter<"CareerStats"> | number
    manOfTheMatchAwards?: IntFilter<"CareerStats"> | number
    updatedAt?: DateTimeFilter<"CareerStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CareerStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    strikeRate?: SortOrder
    highestScore?: SortOrder
    timesOut?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    economy?: SortOrder
    bestBowlingWickets?: SortOrder
    bestBowlingRuns?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    manOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CareerStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: CareerStatsWhereInput | CareerStatsWhereInput[]
    OR?: CareerStatsWhereInput[]
    NOT?: CareerStatsWhereInput | CareerStatsWhereInput[]
    matchesPlayed?: IntFilter<"CareerStats"> | number
    totalRuns?: IntFilter<"CareerStats"> | number
    ballsFaced?: IntFilter<"CareerStats"> | number
    strikeRate?: FloatFilter<"CareerStats"> | number
    highestScore?: IntFilter<"CareerStats"> | number
    timesOut?: IntFilter<"CareerStats"> | number
    oversBowled?: FloatFilter<"CareerStats"> | number
    runsConceded?: IntFilter<"CareerStats"> | number
    wicketsTaken?: IntFilter<"CareerStats"> | number
    economy?: FloatFilter<"CareerStats"> | number
    bestBowlingWickets?: IntFilter<"CareerStats"> | number
    bestBowlingRuns?: IntFilter<"CareerStats"> | number
    catchesTaken?: IntFilter<"CareerStats"> | number
    runOuts?: IntFilter<"CareerStats"> | number
    manOfTheMatchAwards?: IntFilter<"CareerStats"> | number
    updatedAt?: DateTimeFilter<"CareerStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type CareerStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    strikeRate?: SortOrder
    highestScore?: SortOrder
    timesOut?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    economy?: SortOrder
    bestBowlingWickets?: SortOrder
    bestBowlingRuns?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    manOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
    _count?: CareerStatsCountOrderByAggregateInput
    _avg?: CareerStatsAvgOrderByAggregateInput
    _max?: CareerStatsMaxOrderByAggregateInput
    _min?: CareerStatsMinOrderByAggregateInput
    _sum?: CareerStatsSumOrderByAggregateInput
  }

  export type CareerStatsScalarWhereWithAggregatesInput = {
    AND?: CareerStatsScalarWhereWithAggregatesInput | CareerStatsScalarWhereWithAggregatesInput[]
    OR?: CareerStatsScalarWhereWithAggregatesInput[]
    NOT?: CareerStatsScalarWhereWithAggregatesInput | CareerStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CareerStats"> | string
    userId?: StringWithAggregatesFilter<"CareerStats"> | string
    matchesPlayed?: IntWithAggregatesFilter<"CareerStats"> | number
    totalRuns?: IntWithAggregatesFilter<"CareerStats"> | number
    ballsFaced?: IntWithAggregatesFilter<"CareerStats"> | number
    strikeRate?: FloatWithAggregatesFilter<"CareerStats"> | number
    highestScore?: IntWithAggregatesFilter<"CareerStats"> | number
    timesOut?: IntWithAggregatesFilter<"CareerStats"> | number
    oversBowled?: FloatWithAggregatesFilter<"CareerStats"> | number
    runsConceded?: IntWithAggregatesFilter<"CareerStats"> | number
    wicketsTaken?: IntWithAggregatesFilter<"CareerStats"> | number
    economy?: FloatWithAggregatesFilter<"CareerStats"> | number
    bestBowlingWickets?: IntWithAggregatesFilter<"CareerStats"> | number
    bestBowlingRuns?: IntWithAggregatesFilter<"CareerStats"> | number
    catchesTaken?: IntWithAggregatesFilter<"CareerStats"> | number
    runOuts?: IntWithAggregatesFilter<"CareerStats"> | number
    manOfTheMatchAwards?: IntWithAggregatesFilter<"CareerStats"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CareerStats"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    teamCode?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    logoUrl?: StringNullableFilter<"Team"> | string | null
    createdById?: StringFilter<"Team"> | string
    captainId?: StringNullableFilter<"Team"> | string | null
    viceCaptainId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    captain?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    viceCaptain?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: TeamMemberListRelationFilter
    guestPlayers?: GuestPlayerListRelationFilter
    invitations?: TeamInvitationListRelationFilter
    homeMatches?: TeamMatchListRelationFilter
    awayMatches?: TeamMatchListRelationFilter
    teamStats?: XOR<TeamStatisticsNullableScalarRelationFilter, TeamStatisticsWhereInput> | null
    teamMatchStats?: TeamMatchPlayerListRelationFilter
    localMatchesAsMyTeam?: LocalMatchListRelationFilter
    localMatchesAsOpponent?: LocalMatchListRelationFilter
    matchSummariesAsHome?: MatchSummaryListRelationFilter
    matchSummariesAsAway?: MatchSummaryListRelationFilter
    playerMatchHistory?: PlayerMatchHistoryListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    teamCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    createdById?: SortOrder
    captainId?: SortOrder
    viceCaptainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    captain?: UserOrderByWithRelationInput
    viceCaptain?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
    guestPlayers?: GuestPlayerOrderByRelationAggregateInput
    invitations?: TeamInvitationOrderByRelationAggregateInput
    homeMatches?: TeamMatchOrderByRelationAggregateInput
    awayMatches?: TeamMatchOrderByRelationAggregateInput
    teamStats?: TeamStatisticsOrderByWithRelationInput
    teamMatchStats?: TeamMatchPlayerOrderByRelationAggregateInput
    localMatchesAsMyTeam?: LocalMatchOrderByRelationAggregateInput
    localMatchesAsOpponent?: LocalMatchOrderByRelationAggregateInput
    matchSummariesAsHome?: MatchSummaryOrderByRelationAggregateInput
    matchSummariesAsAway?: MatchSummaryOrderByRelationAggregateInput
    playerMatchHistory?: PlayerMatchHistoryOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamCode?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    logoUrl?: StringNullableFilter<"Team"> | string | null
    createdById?: StringFilter<"Team"> | string
    captainId?: StringNullableFilter<"Team"> | string | null
    viceCaptainId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    captain?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    viceCaptain?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: TeamMemberListRelationFilter
    guestPlayers?: GuestPlayerListRelationFilter
    invitations?: TeamInvitationListRelationFilter
    homeMatches?: TeamMatchListRelationFilter
    awayMatches?: TeamMatchListRelationFilter
    teamStats?: XOR<TeamStatisticsNullableScalarRelationFilter, TeamStatisticsWhereInput> | null
    teamMatchStats?: TeamMatchPlayerListRelationFilter
    localMatchesAsMyTeam?: LocalMatchListRelationFilter
    localMatchesAsOpponent?: LocalMatchListRelationFilter
    matchSummariesAsHome?: MatchSummaryListRelationFilter
    matchSummariesAsAway?: MatchSummaryListRelationFilter
    playerMatchHistory?: PlayerMatchHistoryListRelationFilter
  }, "id" | "teamCode">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    teamCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    createdById?: SortOrder
    captainId?: SortOrder
    viceCaptainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    teamCode?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdById?: StringWithAggregatesFilter<"Team"> | string
    captainId?: StringNullableWithAggregatesFilter<"Team"> | string | null
    viceCaptainId?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type GuestPlayerWhereInput = {
    AND?: GuestPlayerWhereInput | GuestPlayerWhereInput[]
    OR?: GuestPlayerWhereInput[]
    NOT?: GuestPlayerWhereInput | GuestPlayerWhereInput[]
    id?: StringFilter<"GuestPlayer"> | string
    teamId?: StringFilter<"GuestPlayer"> | string
    name?: StringFilter<"GuestPlayer"> | string
    addedByUserId?: StringFilter<"GuestPlayer"> | string
    linkedUserId?: StringNullableFilter<"GuestPlayer"> | string | null
    createdAt?: DateTimeFilter<"GuestPlayer"> | Date | string
    matchesPlayed?: IntFilter<"GuestPlayer"> | number
    totalRuns?: IntFilter<"GuestPlayer"> | number
    ballsFaced?: IntFilter<"GuestPlayer"> | number
    fours?: IntFilter<"GuestPlayer"> | number
    sixes?: IntFilter<"GuestPlayer"> | number
    wicketsTaken?: IntFilter<"GuestPlayer"> | number
    runsConceded?: IntFilter<"GuestPlayer"> | number
    oversBowled?: FloatFilter<"GuestPlayer"> | number
    catchesTaken?: IntFilter<"GuestPlayer"> | number
    runOuts?: IntFilter<"GuestPlayer"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    linkedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type GuestPlayerOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    addedByUserId?: SortOrder
    linkedUserId?: SortOrder
    createdAt?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    fours?: SortOrder
    sixes?: SortOrder
    wicketsTaken?: SortOrder
    runsConceded?: SortOrder
    oversBowled?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    team?: TeamOrderByWithRelationInput
    addedBy?: UserOrderByWithRelationInput
    linkedUser?: UserOrderByWithRelationInput
  }

  export type GuestPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GuestPlayerWhereInput | GuestPlayerWhereInput[]
    OR?: GuestPlayerWhereInput[]
    NOT?: GuestPlayerWhereInput | GuestPlayerWhereInput[]
    teamId?: StringFilter<"GuestPlayer"> | string
    name?: StringFilter<"GuestPlayer"> | string
    addedByUserId?: StringFilter<"GuestPlayer"> | string
    linkedUserId?: StringNullableFilter<"GuestPlayer"> | string | null
    createdAt?: DateTimeFilter<"GuestPlayer"> | Date | string
    matchesPlayed?: IntFilter<"GuestPlayer"> | number
    totalRuns?: IntFilter<"GuestPlayer"> | number
    ballsFaced?: IntFilter<"GuestPlayer"> | number
    fours?: IntFilter<"GuestPlayer"> | number
    sixes?: IntFilter<"GuestPlayer"> | number
    wicketsTaken?: IntFilter<"GuestPlayer"> | number
    runsConceded?: IntFilter<"GuestPlayer"> | number
    oversBowled?: FloatFilter<"GuestPlayer"> | number
    catchesTaken?: IntFilter<"GuestPlayer"> | number
    runOuts?: IntFilter<"GuestPlayer"> | number
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    linkedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type GuestPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    addedByUserId?: SortOrder
    linkedUserId?: SortOrder
    createdAt?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    fours?: SortOrder
    sixes?: SortOrder
    wicketsTaken?: SortOrder
    runsConceded?: SortOrder
    oversBowled?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    _count?: GuestPlayerCountOrderByAggregateInput
    _avg?: GuestPlayerAvgOrderByAggregateInput
    _max?: GuestPlayerMaxOrderByAggregateInput
    _min?: GuestPlayerMinOrderByAggregateInput
    _sum?: GuestPlayerSumOrderByAggregateInput
  }

  export type GuestPlayerScalarWhereWithAggregatesInput = {
    AND?: GuestPlayerScalarWhereWithAggregatesInput | GuestPlayerScalarWhereWithAggregatesInput[]
    OR?: GuestPlayerScalarWhereWithAggregatesInput[]
    NOT?: GuestPlayerScalarWhereWithAggregatesInput | GuestPlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GuestPlayer"> | string
    teamId?: StringWithAggregatesFilter<"GuestPlayer"> | string
    name?: StringWithAggregatesFilter<"GuestPlayer"> | string
    addedByUserId?: StringWithAggregatesFilter<"GuestPlayer"> | string
    linkedUserId?: StringNullableWithAggregatesFilter<"GuestPlayer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GuestPlayer"> | Date | string
    matchesPlayed?: IntWithAggregatesFilter<"GuestPlayer"> | number
    totalRuns?: IntWithAggregatesFilter<"GuestPlayer"> | number
    ballsFaced?: IntWithAggregatesFilter<"GuestPlayer"> | number
    fours?: IntWithAggregatesFilter<"GuestPlayer"> | number
    sixes?: IntWithAggregatesFilter<"GuestPlayer"> | number
    wicketsTaken?: IntWithAggregatesFilter<"GuestPlayer"> | number
    runsConceded?: IntWithAggregatesFilter<"GuestPlayer"> | number
    oversBowled?: FloatWithAggregatesFilter<"GuestPlayer"> | number
    catchesTaken?: IntWithAggregatesFilter<"GuestPlayer"> | number
    runOuts?: IntWithAggregatesFilter<"GuestPlayer"> | number
  }

  export type TeamInvitationWhereInput = {
    AND?: TeamInvitationWhereInput | TeamInvitationWhereInput[]
    OR?: TeamInvitationWhereInput[]
    NOT?: TeamInvitationWhereInput | TeamInvitationWhereInput[]
    id?: StringFilter<"TeamInvitation"> | string
    teamId?: StringFilter<"TeamInvitation"> | string
    invitedBy?: StringFilter<"TeamInvitation"> | string
    invitedUser?: StringFilter<"TeamInvitation"> | string
    status?: EnumInvitationStatusFilter<"TeamInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"TeamInvitation"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invited?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamInvitationOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    invitedBy?: SortOrder
    invitedUser?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
    invited?: UserOrderByWithRelationInput
  }

  export type TeamInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamInvitationWhereInput | TeamInvitationWhereInput[]
    OR?: TeamInvitationWhereInput[]
    NOT?: TeamInvitationWhereInput | TeamInvitationWhereInput[]
    teamId?: StringFilter<"TeamInvitation"> | string
    invitedBy?: StringFilter<"TeamInvitation"> | string
    invitedUser?: StringFilter<"TeamInvitation"> | string
    status?: EnumInvitationStatusFilter<"TeamInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"TeamInvitation"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    inviter?: XOR<UserScalarRelationFilter, UserWhereInput>
    invited?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TeamInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    invitedBy?: SortOrder
    invitedUser?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: TeamInvitationCountOrderByAggregateInput
    _max?: TeamInvitationMaxOrderByAggregateInput
    _min?: TeamInvitationMinOrderByAggregateInput
  }

  export type TeamInvitationScalarWhereWithAggregatesInput = {
    AND?: TeamInvitationScalarWhereWithAggregatesInput | TeamInvitationScalarWhereWithAggregatesInput[]
    OR?: TeamInvitationScalarWhereWithAggregatesInput[]
    NOT?: TeamInvitationScalarWhereWithAggregatesInput | TeamInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamInvitation"> | string
    teamId?: StringWithAggregatesFilter<"TeamInvitation"> | string
    invitedBy?: StringWithAggregatesFilter<"TeamInvitation"> | string
    invitedUser?: StringWithAggregatesFilter<"TeamInvitation"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"TeamInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeWithAggregatesFilter<"TeamInvitation"> | Date | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: StringFilter<"Match"> | string
    userId?: StringFilter<"Match"> | string
    opponent?: StringFilter<"Match"> | string
    matchDate?: DateTimeFilter<"Match"> | Date | string
    runsScored?: IntFilter<"Match"> | number
    ballsFaced?: IntFilter<"Match"> | number
    wasDismissed?: BoolFilter<"Match"> | boolean
    oversBowled?: FloatFilter<"Match"> | number
    runsConceded?: IntFilter<"Match"> | number
    wicketsTaken?: IntFilter<"Match"> | number
    catchesTaken?: IntFilter<"Match"> | number
    runOuts?: IntFilter<"Match"> | number
    isManOfTheMatch?: BoolFilter<"Match"> | boolean
    createdAt?: DateTimeFilter<"Match"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    opponent?: SortOrder
    matchDate?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    userId?: StringFilter<"Match"> | string
    opponent?: StringFilter<"Match"> | string
    matchDate?: DateTimeFilter<"Match"> | Date | string
    runsScored?: IntFilter<"Match"> | number
    ballsFaced?: IntFilter<"Match"> | number
    wasDismissed?: BoolFilter<"Match"> | boolean
    oversBowled?: FloatFilter<"Match"> | number
    runsConceded?: IntFilter<"Match"> | number
    wicketsTaken?: IntFilter<"Match"> | number
    catchesTaken?: IntFilter<"Match"> | number
    runOuts?: IntFilter<"Match"> | number
    isManOfTheMatch?: BoolFilter<"Match"> | boolean
    createdAt?: DateTimeFilter<"Match"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    opponent?: SortOrder
    matchDate?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Match"> | string
    userId?: StringWithAggregatesFilter<"Match"> | string
    opponent?: StringWithAggregatesFilter<"Match"> | string
    matchDate?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    runsScored?: IntWithAggregatesFilter<"Match"> | number
    ballsFaced?: IntWithAggregatesFilter<"Match"> | number
    wasDismissed?: BoolWithAggregatesFilter<"Match"> | boolean
    oversBowled?: FloatWithAggregatesFilter<"Match"> | number
    runsConceded?: IntWithAggregatesFilter<"Match"> | number
    wicketsTaken?: IntWithAggregatesFilter<"Match"> | number
    catchesTaken?: IntWithAggregatesFilter<"Match"> | number
    runOuts?: IntWithAggregatesFilter<"Match"> | number
    isManOfTheMatch?: BoolWithAggregatesFilter<"Match"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type TeamMatchWhereInput = {
    AND?: TeamMatchWhereInput | TeamMatchWhereInput[]
    OR?: TeamMatchWhereInput[]
    NOT?: TeamMatchWhereInput | TeamMatchWhereInput[]
    id?: StringFilter<"TeamMatch"> | string
    homeTeamId?: StringFilter<"TeamMatch"> | string
    awayTeamId?: StringFilter<"TeamMatch"> | string
    matchDate?: DateTimeFilter<"TeamMatch"> | Date | string
    venue?: StringFilter<"TeamMatch"> | string
    status?: EnumMatchStatusFilter<"TeamMatch"> | $Enums.MatchStatus
    result?: EnumMatchResultNullableFilter<"TeamMatch"> | $Enums.MatchResult | null
    homeTeamRuns?: IntFilter<"TeamMatch"> | number
    homeTeamWickets?: IntFilter<"TeamMatch"> | number
    homeTeamOvers?: FloatFilter<"TeamMatch"> | number
    awayTeamRuns?: IntFilter<"TeamMatch"> | number
    awayTeamWickets?: IntFilter<"TeamMatch"> | number
    awayTeamOvers?: FloatFilter<"TeamMatch"> | number
    createdAt?: DateTimeFilter<"TeamMatch"> | Date | string
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    playerStats?: TeamMatchPlayerListRelationFilter
  }

  export type TeamMatchOrderByWithRelationInput = {
    id?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    result?: SortOrder
    homeTeamRuns?: SortOrder
    homeTeamWickets?: SortOrder
    homeTeamOvers?: SortOrder
    awayTeamRuns?: SortOrder
    awayTeamWickets?: SortOrder
    awayTeamOvers?: SortOrder
    createdAt?: SortOrder
    homeTeam?: TeamOrderByWithRelationInput
    awayTeam?: TeamOrderByWithRelationInput
    playerStats?: TeamMatchPlayerOrderByRelationAggregateInput
  }

  export type TeamMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamMatchWhereInput | TeamMatchWhereInput[]
    OR?: TeamMatchWhereInput[]
    NOT?: TeamMatchWhereInput | TeamMatchWhereInput[]
    homeTeamId?: StringFilter<"TeamMatch"> | string
    awayTeamId?: StringFilter<"TeamMatch"> | string
    matchDate?: DateTimeFilter<"TeamMatch"> | Date | string
    venue?: StringFilter<"TeamMatch"> | string
    status?: EnumMatchStatusFilter<"TeamMatch"> | $Enums.MatchStatus
    result?: EnumMatchResultNullableFilter<"TeamMatch"> | $Enums.MatchResult | null
    homeTeamRuns?: IntFilter<"TeamMatch"> | number
    homeTeamWickets?: IntFilter<"TeamMatch"> | number
    homeTeamOvers?: FloatFilter<"TeamMatch"> | number
    awayTeamRuns?: IntFilter<"TeamMatch"> | number
    awayTeamWickets?: IntFilter<"TeamMatch"> | number
    awayTeamOvers?: FloatFilter<"TeamMatch"> | number
    createdAt?: DateTimeFilter<"TeamMatch"> | Date | string
    homeTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    awayTeam?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    playerStats?: TeamMatchPlayerListRelationFilter
  }, "id">

  export type TeamMatchOrderByWithAggregationInput = {
    id?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    result?: SortOrder
    homeTeamRuns?: SortOrder
    homeTeamWickets?: SortOrder
    homeTeamOvers?: SortOrder
    awayTeamRuns?: SortOrder
    awayTeamWickets?: SortOrder
    awayTeamOvers?: SortOrder
    createdAt?: SortOrder
    _count?: TeamMatchCountOrderByAggregateInput
    _avg?: TeamMatchAvgOrderByAggregateInput
    _max?: TeamMatchMaxOrderByAggregateInput
    _min?: TeamMatchMinOrderByAggregateInput
    _sum?: TeamMatchSumOrderByAggregateInput
  }

  export type TeamMatchScalarWhereWithAggregatesInput = {
    AND?: TeamMatchScalarWhereWithAggregatesInput | TeamMatchScalarWhereWithAggregatesInput[]
    OR?: TeamMatchScalarWhereWithAggregatesInput[]
    NOT?: TeamMatchScalarWhereWithAggregatesInput | TeamMatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMatch"> | string
    homeTeamId?: StringWithAggregatesFilter<"TeamMatch"> | string
    awayTeamId?: StringWithAggregatesFilter<"TeamMatch"> | string
    matchDate?: DateTimeWithAggregatesFilter<"TeamMatch"> | Date | string
    venue?: StringWithAggregatesFilter<"TeamMatch"> | string
    status?: EnumMatchStatusWithAggregatesFilter<"TeamMatch"> | $Enums.MatchStatus
    result?: EnumMatchResultNullableWithAggregatesFilter<"TeamMatch"> | $Enums.MatchResult | null
    homeTeamRuns?: IntWithAggregatesFilter<"TeamMatch"> | number
    homeTeamWickets?: IntWithAggregatesFilter<"TeamMatch"> | number
    homeTeamOvers?: FloatWithAggregatesFilter<"TeamMatch"> | number
    awayTeamRuns?: IntWithAggregatesFilter<"TeamMatch"> | number
    awayTeamWickets?: IntWithAggregatesFilter<"TeamMatch"> | number
    awayTeamOvers?: FloatWithAggregatesFilter<"TeamMatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TeamMatch"> | Date | string
  }

  export type TeamMatchPlayerWhereInput = {
    AND?: TeamMatchPlayerWhereInput | TeamMatchPlayerWhereInput[]
    OR?: TeamMatchPlayerWhereInput[]
    NOT?: TeamMatchPlayerWhereInput | TeamMatchPlayerWhereInput[]
    id?: StringFilter<"TeamMatchPlayer"> | string
    teamMatchId?: StringFilter<"TeamMatchPlayer"> | string
    userId?: StringFilter<"TeamMatchPlayer"> | string
    teamId?: StringFilter<"TeamMatchPlayer"> | string
    runsScored?: IntFilter<"TeamMatchPlayer"> | number
    ballsFaced?: IntFilter<"TeamMatchPlayer"> | number
    wasDismissed?: BoolFilter<"TeamMatchPlayer"> | boolean
    oversBowled?: FloatFilter<"TeamMatchPlayer"> | number
    runsConceded?: IntFilter<"TeamMatchPlayer"> | number
    wicketsTaken?: IntFilter<"TeamMatchPlayer"> | number
    catchesTaken?: IntFilter<"TeamMatchPlayer"> | number
    teamMatch?: XOR<TeamMatchScalarRelationFilter, TeamMatchWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type TeamMatchPlayerOrderByWithRelationInput = {
    id?: SortOrder
    teamMatchId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    teamMatch?: TeamMatchOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type TeamMatchPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamMatchId_userId?: TeamMatchPlayerTeamMatchIdUserIdCompoundUniqueInput
    AND?: TeamMatchPlayerWhereInput | TeamMatchPlayerWhereInput[]
    OR?: TeamMatchPlayerWhereInput[]
    NOT?: TeamMatchPlayerWhereInput | TeamMatchPlayerWhereInput[]
    teamMatchId?: StringFilter<"TeamMatchPlayer"> | string
    userId?: StringFilter<"TeamMatchPlayer"> | string
    teamId?: StringFilter<"TeamMatchPlayer"> | string
    runsScored?: IntFilter<"TeamMatchPlayer"> | number
    ballsFaced?: IntFilter<"TeamMatchPlayer"> | number
    wasDismissed?: BoolFilter<"TeamMatchPlayer"> | boolean
    oversBowled?: FloatFilter<"TeamMatchPlayer"> | number
    runsConceded?: IntFilter<"TeamMatchPlayer"> | number
    wicketsTaken?: IntFilter<"TeamMatchPlayer"> | number
    catchesTaken?: IntFilter<"TeamMatchPlayer"> | number
    teamMatch?: XOR<TeamMatchScalarRelationFilter, TeamMatchWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "teamMatchId_userId">

  export type TeamMatchPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    teamMatchId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    _count?: TeamMatchPlayerCountOrderByAggregateInput
    _avg?: TeamMatchPlayerAvgOrderByAggregateInput
    _max?: TeamMatchPlayerMaxOrderByAggregateInput
    _min?: TeamMatchPlayerMinOrderByAggregateInput
    _sum?: TeamMatchPlayerSumOrderByAggregateInput
  }

  export type TeamMatchPlayerScalarWhereWithAggregatesInput = {
    AND?: TeamMatchPlayerScalarWhereWithAggregatesInput | TeamMatchPlayerScalarWhereWithAggregatesInput[]
    OR?: TeamMatchPlayerScalarWhereWithAggregatesInput[]
    NOT?: TeamMatchPlayerScalarWhereWithAggregatesInput | TeamMatchPlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMatchPlayer"> | string
    teamMatchId?: StringWithAggregatesFilter<"TeamMatchPlayer"> | string
    userId?: StringWithAggregatesFilter<"TeamMatchPlayer"> | string
    teamId?: StringWithAggregatesFilter<"TeamMatchPlayer"> | string
    runsScored?: IntWithAggregatesFilter<"TeamMatchPlayer"> | number
    ballsFaced?: IntWithAggregatesFilter<"TeamMatchPlayer"> | number
    wasDismissed?: BoolWithAggregatesFilter<"TeamMatchPlayer"> | boolean
    oversBowled?: FloatWithAggregatesFilter<"TeamMatchPlayer"> | number
    runsConceded?: IntWithAggregatesFilter<"TeamMatchPlayer"> | number
    wicketsTaken?: IntWithAggregatesFilter<"TeamMatchPlayer"> | number
    catchesTaken?: IntWithAggregatesFilter<"TeamMatchPlayer"> | number
  }

  export type TeamStatisticsWhereInput = {
    AND?: TeamStatisticsWhereInput | TeamStatisticsWhereInput[]
    OR?: TeamStatisticsWhereInput[]
    NOT?: TeamStatisticsWhereInput | TeamStatisticsWhereInput[]
    id?: StringFilter<"TeamStatistics"> | string
    teamId?: StringFilter<"TeamStatistics"> | string
    matchesPlayed?: IntFilter<"TeamStatistics"> | number
    matchesWon?: IntFilter<"TeamStatistics"> | number
    matchesLost?: IntFilter<"TeamStatistics"> | number
    matchesDrawn?: IntFilter<"TeamStatistics"> | number
    winRatio?: FloatFilter<"TeamStatistics"> | number
    topRunScorerId?: StringNullableFilter<"TeamStatistics"> | string | null
    topRunScorerRuns?: IntFilter<"TeamStatistics"> | number
    topWicketTakerId?: StringNullableFilter<"TeamStatistics"> | string | null
    topWicketTakerWickets?: IntFilter<"TeamStatistics"> | number
    bestStrikeRatePlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    bestStrikeRate?: FloatFilter<"TeamStatistics"> | number
    bestEconomyPlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    bestEconomy?: FloatFilter<"TeamStatistics"> | number
    mostManOfTheMatchPlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    mostManOfTheMatchAwards?: IntFilter<"TeamStatistics"> | number
    updatedAt?: DateTimeFilter<"TeamStatistics"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    topRunScorer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    topWicketTaker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bestStrikeRatePlayer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bestEconomyPlayer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mostManOfTheMatchPlayer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TeamStatisticsOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    matchesPlayed?: SortOrder
    matchesWon?: SortOrder
    matchesLost?: SortOrder
    matchesDrawn?: SortOrder
    winRatio?: SortOrder
    topRunScorerId?: SortOrder
    topRunScorerRuns?: SortOrder
    topWicketTakerId?: SortOrder
    topWicketTakerWickets?: SortOrder
    bestStrikeRatePlayerId?: SortOrder
    bestStrikeRate?: SortOrder
    bestEconomyPlayerId?: SortOrder
    bestEconomy?: SortOrder
    mostManOfTheMatchPlayerId?: SortOrder
    mostManOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    topRunScorer?: UserOrderByWithRelationInput
    topWicketTaker?: UserOrderByWithRelationInput
    bestStrikeRatePlayer?: UserOrderByWithRelationInput
    bestEconomyPlayer?: UserOrderByWithRelationInput
    mostManOfTheMatchPlayer?: UserOrderByWithRelationInput
  }

  export type TeamStatisticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId?: string
    AND?: TeamStatisticsWhereInput | TeamStatisticsWhereInput[]
    OR?: TeamStatisticsWhereInput[]
    NOT?: TeamStatisticsWhereInput | TeamStatisticsWhereInput[]
    matchesPlayed?: IntFilter<"TeamStatistics"> | number
    matchesWon?: IntFilter<"TeamStatistics"> | number
    matchesLost?: IntFilter<"TeamStatistics"> | number
    matchesDrawn?: IntFilter<"TeamStatistics"> | number
    winRatio?: FloatFilter<"TeamStatistics"> | number
    topRunScorerId?: StringNullableFilter<"TeamStatistics"> | string | null
    topRunScorerRuns?: IntFilter<"TeamStatistics"> | number
    topWicketTakerId?: StringNullableFilter<"TeamStatistics"> | string | null
    topWicketTakerWickets?: IntFilter<"TeamStatistics"> | number
    bestStrikeRatePlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    bestStrikeRate?: FloatFilter<"TeamStatistics"> | number
    bestEconomyPlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    bestEconomy?: FloatFilter<"TeamStatistics"> | number
    mostManOfTheMatchPlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    mostManOfTheMatchAwards?: IntFilter<"TeamStatistics"> | number
    updatedAt?: DateTimeFilter<"TeamStatistics"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    topRunScorer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    topWicketTaker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bestStrikeRatePlayer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    bestEconomyPlayer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    mostManOfTheMatchPlayer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "teamId">

  export type TeamStatisticsOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    matchesPlayed?: SortOrder
    matchesWon?: SortOrder
    matchesLost?: SortOrder
    matchesDrawn?: SortOrder
    winRatio?: SortOrder
    topRunScorerId?: SortOrder
    topRunScorerRuns?: SortOrder
    topWicketTakerId?: SortOrder
    topWicketTakerWickets?: SortOrder
    bestStrikeRatePlayerId?: SortOrder
    bestStrikeRate?: SortOrder
    bestEconomyPlayerId?: SortOrder
    bestEconomy?: SortOrder
    mostManOfTheMatchPlayerId?: SortOrder
    mostManOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamStatisticsCountOrderByAggregateInput
    _avg?: TeamStatisticsAvgOrderByAggregateInput
    _max?: TeamStatisticsMaxOrderByAggregateInput
    _min?: TeamStatisticsMinOrderByAggregateInput
    _sum?: TeamStatisticsSumOrderByAggregateInput
  }

  export type TeamStatisticsScalarWhereWithAggregatesInput = {
    AND?: TeamStatisticsScalarWhereWithAggregatesInput | TeamStatisticsScalarWhereWithAggregatesInput[]
    OR?: TeamStatisticsScalarWhereWithAggregatesInput[]
    NOT?: TeamStatisticsScalarWhereWithAggregatesInput | TeamStatisticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamStatistics"> | string
    teamId?: StringWithAggregatesFilter<"TeamStatistics"> | string
    matchesPlayed?: IntWithAggregatesFilter<"TeamStatistics"> | number
    matchesWon?: IntWithAggregatesFilter<"TeamStatistics"> | number
    matchesLost?: IntWithAggregatesFilter<"TeamStatistics"> | number
    matchesDrawn?: IntWithAggregatesFilter<"TeamStatistics"> | number
    winRatio?: FloatWithAggregatesFilter<"TeamStatistics"> | number
    topRunScorerId?: StringNullableWithAggregatesFilter<"TeamStatistics"> | string | null
    topRunScorerRuns?: IntWithAggregatesFilter<"TeamStatistics"> | number
    topWicketTakerId?: StringNullableWithAggregatesFilter<"TeamStatistics"> | string | null
    topWicketTakerWickets?: IntWithAggregatesFilter<"TeamStatistics"> | number
    bestStrikeRatePlayerId?: StringNullableWithAggregatesFilter<"TeamStatistics"> | string | null
    bestStrikeRate?: FloatWithAggregatesFilter<"TeamStatistics"> | number
    bestEconomyPlayerId?: StringNullableWithAggregatesFilter<"TeamStatistics"> | string | null
    bestEconomy?: FloatWithAggregatesFilter<"TeamStatistics"> | number
    mostManOfTheMatchPlayerId?: StringNullableWithAggregatesFilter<"TeamStatistics"> | string | null
    mostManOfTheMatchAwards?: IntWithAggregatesFilter<"TeamStatistics"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"TeamStatistics"> | Date | string
  }

  export type LocalMatchWhereInput = {
    AND?: LocalMatchWhereInput | LocalMatchWhereInput[]
    OR?: LocalMatchWhereInput[]
    NOT?: LocalMatchWhereInput | LocalMatchWhereInput[]
    id?: StringFilter<"LocalMatch"> | string
    creatorId?: StringFilter<"LocalMatch"> | string
    matchName?: StringFilter<"LocalMatch"> | string
    venue?: StringFilter<"LocalMatch"> | string
    matchDate?: DateTimeFilter<"LocalMatch"> | Date | string
    overs?: IntFilter<"LocalMatch"> | number
    myTeamName?: StringNullableFilter<"LocalMatch"> | string | null
    myTeamId?: StringNullableFilter<"LocalMatch"> | string | null
    opponentTeamName?: StringNullableFilter<"LocalMatch"> | string | null
    opponentTeamId?: StringNullableFilter<"LocalMatch"> | string | null
    myTeamPlayers?: JsonFilter<"LocalMatch">
    opponentTeamPlayers?: JsonFilter<"LocalMatch">
    allowSpectators?: BoolFilter<"LocalMatch"> | boolean
    isRoomMatch?: BoolFilter<"LocalMatch"> | boolean
    roomPassword?: StringNullableFilter<"LocalMatch"> | string | null
    status?: EnumLocalMatchStatusFilter<"LocalMatch"> | $Enums.LocalMatchStatus
    currentInnings?: IntFilter<"LocalMatch"> | number
    currentOver?: IntFilter<"LocalMatch"> | number
    currentBall?: IntFilter<"LocalMatch"> | number
    myTeamScore?: IntFilter<"LocalMatch"> | number
    myTeamWickets?: IntFilter<"LocalMatch"> | number
    myTeamOvers?: FloatFilter<"LocalMatch"> | number
    opponentTeamScore?: IntFilter<"LocalMatch"> | number
    opponentTeamWickets?: IntFilter<"LocalMatch"> | number
    opponentTeamOvers?: FloatFilter<"LocalMatch"> | number
    fullState?: JsonNullableFilter<"LocalMatch">
    createdAt?: DateTimeFilter<"LocalMatch"> | Date | string
    updatedAt?: DateTimeFilter<"LocalMatch"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    myTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    opponentTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    spectators?: MatchSpectatorListRelationFilter
    overHistory?: OverHistoryListRelationFilter
  }

  export type LocalMatchOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    matchName?: SortOrder
    venue?: SortOrder
    matchDate?: SortOrder
    overs?: SortOrder
    myTeamName?: SortOrder
    myTeamId?: SortOrder
    opponentTeamName?: SortOrder
    opponentTeamId?: SortOrder
    myTeamPlayers?: SortOrder
    opponentTeamPlayers?: SortOrder
    allowSpectators?: SortOrder
    isRoomMatch?: SortOrder
    roomPassword?: SortOrder
    status?: SortOrder
    currentInnings?: SortOrder
    currentOver?: SortOrder
    currentBall?: SortOrder
    myTeamScore?: SortOrder
    myTeamWickets?: SortOrder
    myTeamOvers?: SortOrder
    opponentTeamScore?: SortOrder
    opponentTeamWickets?: SortOrder
    opponentTeamOvers?: SortOrder
    fullState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    myTeam?: TeamOrderByWithRelationInput
    opponentTeam?: TeamOrderByWithRelationInput
    spectators?: MatchSpectatorOrderByRelationAggregateInput
    overHistory?: OverHistoryOrderByRelationAggregateInput
  }

  export type LocalMatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocalMatchWhereInput | LocalMatchWhereInput[]
    OR?: LocalMatchWhereInput[]
    NOT?: LocalMatchWhereInput | LocalMatchWhereInput[]
    creatorId?: StringFilter<"LocalMatch"> | string
    matchName?: StringFilter<"LocalMatch"> | string
    venue?: StringFilter<"LocalMatch"> | string
    matchDate?: DateTimeFilter<"LocalMatch"> | Date | string
    overs?: IntFilter<"LocalMatch"> | number
    myTeamName?: StringNullableFilter<"LocalMatch"> | string | null
    myTeamId?: StringNullableFilter<"LocalMatch"> | string | null
    opponentTeamName?: StringNullableFilter<"LocalMatch"> | string | null
    opponentTeamId?: StringNullableFilter<"LocalMatch"> | string | null
    myTeamPlayers?: JsonFilter<"LocalMatch">
    opponentTeamPlayers?: JsonFilter<"LocalMatch">
    allowSpectators?: BoolFilter<"LocalMatch"> | boolean
    isRoomMatch?: BoolFilter<"LocalMatch"> | boolean
    roomPassword?: StringNullableFilter<"LocalMatch"> | string | null
    status?: EnumLocalMatchStatusFilter<"LocalMatch"> | $Enums.LocalMatchStatus
    currentInnings?: IntFilter<"LocalMatch"> | number
    currentOver?: IntFilter<"LocalMatch"> | number
    currentBall?: IntFilter<"LocalMatch"> | number
    myTeamScore?: IntFilter<"LocalMatch"> | number
    myTeamWickets?: IntFilter<"LocalMatch"> | number
    myTeamOvers?: FloatFilter<"LocalMatch"> | number
    opponentTeamScore?: IntFilter<"LocalMatch"> | number
    opponentTeamWickets?: IntFilter<"LocalMatch"> | number
    opponentTeamOvers?: FloatFilter<"LocalMatch"> | number
    fullState?: JsonNullableFilter<"LocalMatch">
    createdAt?: DateTimeFilter<"LocalMatch"> | Date | string
    updatedAt?: DateTimeFilter<"LocalMatch"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    myTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    opponentTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    spectators?: MatchSpectatorListRelationFilter
    overHistory?: OverHistoryListRelationFilter
  }, "id">

  export type LocalMatchOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    matchName?: SortOrder
    venue?: SortOrder
    matchDate?: SortOrder
    overs?: SortOrder
    myTeamName?: SortOrder
    myTeamId?: SortOrder
    opponentTeamName?: SortOrder
    opponentTeamId?: SortOrder
    myTeamPlayers?: SortOrder
    opponentTeamPlayers?: SortOrder
    allowSpectators?: SortOrder
    isRoomMatch?: SortOrder
    roomPassword?: SortOrder
    status?: SortOrder
    currentInnings?: SortOrder
    currentOver?: SortOrder
    currentBall?: SortOrder
    myTeamScore?: SortOrder
    myTeamWickets?: SortOrder
    myTeamOvers?: SortOrder
    opponentTeamScore?: SortOrder
    opponentTeamWickets?: SortOrder
    opponentTeamOvers?: SortOrder
    fullState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocalMatchCountOrderByAggregateInput
    _avg?: LocalMatchAvgOrderByAggregateInput
    _max?: LocalMatchMaxOrderByAggregateInput
    _min?: LocalMatchMinOrderByAggregateInput
    _sum?: LocalMatchSumOrderByAggregateInput
  }

  export type LocalMatchScalarWhereWithAggregatesInput = {
    AND?: LocalMatchScalarWhereWithAggregatesInput | LocalMatchScalarWhereWithAggregatesInput[]
    OR?: LocalMatchScalarWhereWithAggregatesInput[]
    NOT?: LocalMatchScalarWhereWithAggregatesInput | LocalMatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocalMatch"> | string
    creatorId?: StringWithAggregatesFilter<"LocalMatch"> | string
    matchName?: StringWithAggregatesFilter<"LocalMatch"> | string
    venue?: StringWithAggregatesFilter<"LocalMatch"> | string
    matchDate?: DateTimeWithAggregatesFilter<"LocalMatch"> | Date | string
    overs?: IntWithAggregatesFilter<"LocalMatch"> | number
    myTeamName?: StringNullableWithAggregatesFilter<"LocalMatch"> | string | null
    myTeamId?: StringNullableWithAggregatesFilter<"LocalMatch"> | string | null
    opponentTeamName?: StringNullableWithAggregatesFilter<"LocalMatch"> | string | null
    opponentTeamId?: StringNullableWithAggregatesFilter<"LocalMatch"> | string | null
    myTeamPlayers?: JsonWithAggregatesFilter<"LocalMatch">
    opponentTeamPlayers?: JsonWithAggregatesFilter<"LocalMatch">
    allowSpectators?: BoolWithAggregatesFilter<"LocalMatch"> | boolean
    isRoomMatch?: BoolWithAggregatesFilter<"LocalMatch"> | boolean
    roomPassword?: StringNullableWithAggregatesFilter<"LocalMatch"> | string | null
    status?: EnumLocalMatchStatusWithAggregatesFilter<"LocalMatch"> | $Enums.LocalMatchStatus
    currentInnings?: IntWithAggregatesFilter<"LocalMatch"> | number
    currentOver?: IntWithAggregatesFilter<"LocalMatch"> | number
    currentBall?: IntWithAggregatesFilter<"LocalMatch"> | number
    myTeamScore?: IntWithAggregatesFilter<"LocalMatch"> | number
    myTeamWickets?: IntWithAggregatesFilter<"LocalMatch"> | number
    myTeamOvers?: FloatWithAggregatesFilter<"LocalMatch"> | number
    opponentTeamScore?: IntWithAggregatesFilter<"LocalMatch"> | number
    opponentTeamWickets?: IntWithAggregatesFilter<"LocalMatch"> | number
    opponentTeamOvers?: FloatWithAggregatesFilter<"LocalMatch"> | number
    fullState?: JsonNullableWithAggregatesFilter<"LocalMatch">
    createdAt?: DateTimeWithAggregatesFilter<"LocalMatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocalMatch"> | Date | string
  }

  export type MatchSpectatorWhereInput = {
    AND?: MatchSpectatorWhereInput | MatchSpectatorWhereInput[]
    OR?: MatchSpectatorWhereInput[]
    NOT?: MatchSpectatorWhereInput | MatchSpectatorWhereInput[]
    id?: StringFilter<"MatchSpectator"> | string
    localMatchId?: StringFilter<"MatchSpectator"> | string
    userId?: StringFilter<"MatchSpectator"> | string
    addedBy?: StringFilter<"MatchSpectator"> | string
    addedAt?: DateTimeFilter<"MatchSpectator"> | Date | string
    notified?: BoolFilter<"MatchSpectator"> | boolean
    localMatch?: XOR<LocalMatchScalarRelationFilter, LocalMatchWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    addedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MatchSpectatorOrderByWithRelationInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    userId?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    notified?: SortOrder
    localMatch?: LocalMatchOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    addedByUser?: UserOrderByWithRelationInput
  }

  export type MatchSpectatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    localMatchId_userId?: MatchSpectatorLocalMatchIdUserIdCompoundUniqueInput
    AND?: MatchSpectatorWhereInput | MatchSpectatorWhereInput[]
    OR?: MatchSpectatorWhereInput[]
    NOT?: MatchSpectatorWhereInput | MatchSpectatorWhereInput[]
    localMatchId?: StringFilter<"MatchSpectator"> | string
    userId?: StringFilter<"MatchSpectator"> | string
    addedBy?: StringFilter<"MatchSpectator"> | string
    addedAt?: DateTimeFilter<"MatchSpectator"> | Date | string
    notified?: BoolFilter<"MatchSpectator"> | boolean
    localMatch?: XOR<LocalMatchScalarRelationFilter, LocalMatchWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    addedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "localMatchId_userId">

  export type MatchSpectatorOrderByWithAggregationInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    userId?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    notified?: SortOrder
    _count?: MatchSpectatorCountOrderByAggregateInput
    _max?: MatchSpectatorMaxOrderByAggregateInput
    _min?: MatchSpectatorMinOrderByAggregateInput
  }

  export type MatchSpectatorScalarWhereWithAggregatesInput = {
    AND?: MatchSpectatorScalarWhereWithAggregatesInput | MatchSpectatorScalarWhereWithAggregatesInput[]
    OR?: MatchSpectatorScalarWhereWithAggregatesInput[]
    NOT?: MatchSpectatorScalarWhereWithAggregatesInput | MatchSpectatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchSpectator"> | string
    localMatchId?: StringWithAggregatesFilter<"MatchSpectator"> | string
    userId?: StringWithAggregatesFilter<"MatchSpectator"> | string
    addedBy?: StringWithAggregatesFilter<"MatchSpectator"> | string
    addedAt?: DateTimeWithAggregatesFilter<"MatchSpectator"> | Date | string
    notified?: BoolWithAggregatesFilter<"MatchSpectator"> | boolean
  }

  export type OverHistoryWhereInput = {
    AND?: OverHistoryWhereInput | OverHistoryWhereInput[]
    OR?: OverHistoryWhereInput[]
    NOT?: OverHistoryWhereInput | OverHistoryWhereInput[]
    id?: StringFilter<"OverHistory"> | string
    localMatchId?: StringFilter<"OverHistory"> | string
    overNumber?: IntFilter<"OverHistory"> | number
    innings?: IntFilter<"OverHistory"> | number
    balls?: JsonFilter<"OverHistory">
    totalRuns?: IntFilter<"OverHistory"> | number
    wickets?: IntFilter<"OverHistory"> | number
    createdAt?: DateTimeFilter<"OverHistory"> | Date | string
    localMatch?: XOR<LocalMatchScalarRelationFilter, LocalMatchWhereInput>
  }

  export type OverHistoryOrderByWithRelationInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    overNumber?: SortOrder
    innings?: SortOrder
    balls?: SortOrder
    totalRuns?: SortOrder
    wickets?: SortOrder
    createdAt?: SortOrder
    localMatch?: LocalMatchOrderByWithRelationInput
  }

  export type OverHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OverHistoryWhereInput | OverHistoryWhereInput[]
    OR?: OverHistoryWhereInput[]
    NOT?: OverHistoryWhereInput | OverHistoryWhereInput[]
    localMatchId?: StringFilter<"OverHistory"> | string
    overNumber?: IntFilter<"OverHistory"> | number
    innings?: IntFilter<"OverHistory"> | number
    balls?: JsonFilter<"OverHistory">
    totalRuns?: IntFilter<"OverHistory"> | number
    wickets?: IntFilter<"OverHistory"> | number
    createdAt?: DateTimeFilter<"OverHistory"> | Date | string
    localMatch?: XOR<LocalMatchScalarRelationFilter, LocalMatchWhereInput>
  }, "id">

  export type OverHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    overNumber?: SortOrder
    innings?: SortOrder
    balls?: SortOrder
    totalRuns?: SortOrder
    wickets?: SortOrder
    createdAt?: SortOrder
    _count?: OverHistoryCountOrderByAggregateInput
    _avg?: OverHistoryAvgOrderByAggregateInput
    _max?: OverHistoryMaxOrderByAggregateInput
    _min?: OverHistoryMinOrderByAggregateInput
    _sum?: OverHistorySumOrderByAggregateInput
  }

  export type OverHistoryScalarWhereWithAggregatesInput = {
    AND?: OverHistoryScalarWhereWithAggregatesInput | OverHistoryScalarWhereWithAggregatesInput[]
    OR?: OverHistoryScalarWhereWithAggregatesInput[]
    NOT?: OverHistoryScalarWhereWithAggregatesInput | OverHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OverHistory"> | string
    localMatchId?: StringWithAggregatesFilter<"OverHistory"> | string
    overNumber?: IntWithAggregatesFilter<"OverHistory"> | number
    innings?: IntWithAggregatesFilter<"OverHistory"> | number
    balls?: JsonWithAggregatesFilter<"OverHistory">
    totalRuns?: IntWithAggregatesFilter<"OverHistory"> | number
    wickets?: IntWithAggregatesFilter<"OverHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OverHistory"> | Date | string
  }

  export type MatchSummaryWhereInput = {
    AND?: MatchSummaryWhereInput | MatchSummaryWhereInput[]
    OR?: MatchSummaryWhereInput[]
    NOT?: MatchSummaryWhereInput | MatchSummaryWhereInput[]
    id?: StringFilter<"MatchSummary"> | string
    matchDate?: DateTimeFilter<"MatchSummary"> | Date | string
    venue?: StringFilter<"MatchSummary"> | string
    homeTeamName?: StringFilter<"MatchSummary"> | string
    homeTeamId?: StringNullableFilter<"MatchSummary"> | string | null
    awayTeamName?: StringFilter<"MatchSummary"> | string
    awayTeamId?: StringNullableFilter<"MatchSummary"> | string | null
    result?: EnumMatchResultFilter<"MatchSummary"> | $Enums.MatchResult
    winningTeam?: StringFilter<"MatchSummary"> | string
    firstInningsTeam?: StringFilter<"MatchSummary"> | string
    firstInningsRuns?: IntFilter<"MatchSummary"> | number
    firstInningsWickets?: IntFilter<"MatchSummary"> | number
    firstInningsOvers?: FloatFilter<"MatchSummary"> | number
    secondInningsTeam?: StringFilter<"MatchSummary"> | string
    secondInningsRuns?: IntFilter<"MatchSummary"> | number
    secondInningsWickets?: IntFilter<"MatchSummary"> | number
    secondInningsOvers?: FloatFilter<"MatchSummary"> | number
    target?: IntNullableFilter<"MatchSummary"> | number | null
    totalOvers?: IntFilter<"MatchSummary"> | number
    manOfTheMatchPlayerName?: StringNullableFilter<"MatchSummary"> | string | null
    manOfTheMatchUserId?: StringNullableFilter<"MatchSummary"> | string | null
    manOfTheMatchStats?: JsonNullableFilter<"MatchSummary">
    firstInningsBatsmen?: JsonFilter<"MatchSummary">
    firstInningsBowlers?: JsonFilter<"MatchSummary">
    secondInningsBatsmen?: JsonFilter<"MatchSummary">
    secondInningsBowlers?: JsonFilter<"MatchSummary">
    createdAt?: DateTimeFilter<"MatchSummary"> | Date | string
    homeTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    awayTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    manOfTheMatchUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    playerHistory?: PlayerMatchHistoryListRelationFilter
  }

  export type MatchSummaryOrderByWithRelationInput = {
    id?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    homeTeamName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamName?: SortOrder
    awayTeamId?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    firstInningsTeam?: SortOrder
    firstInningsRuns?: SortOrder
    firstInningsWickets?: SortOrder
    firstInningsOvers?: SortOrder
    secondInningsTeam?: SortOrder
    secondInningsRuns?: SortOrder
    secondInningsWickets?: SortOrder
    secondInningsOvers?: SortOrder
    target?: SortOrder
    totalOvers?: SortOrder
    manOfTheMatchPlayerName?: SortOrder
    manOfTheMatchUserId?: SortOrder
    manOfTheMatchStats?: SortOrder
    firstInningsBatsmen?: SortOrder
    firstInningsBowlers?: SortOrder
    secondInningsBatsmen?: SortOrder
    secondInningsBowlers?: SortOrder
    createdAt?: SortOrder
    homeTeam?: TeamOrderByWithRelationInput
    awayTeam?: TeamOrderByWithRelationInput
    manOfTheMatchUser?: UserOrderByWithRelationInput
    playerHistory?: PlayerMatchHistoryOrderByRelationAggregateInput
  }

  export type MatchSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchSummaryWhereInput | MatchSummaryWhereInput[]
    OR?: MatchSummaryWhereInput[]
    NOT?: MatchSummaryWhereInput | MatchSummaryWhereInput[]
    matchDate?: DateTimeFilter<"MatchSummary"> | Date | string
    venue?: StringFilter<"MatchSummary"> | string
    homeTeamName?: StringFilter<"MatchSummary"> | string
    homeTeamId?: StringNullableFilter<"MatchSummary"> | string | null
    awayTeamName?: StringFilter<"MatchSummary"> | string
    awayTeamId?: StringNullableFilter<"MatchSummary"> | string | null
    result?: EnumMatchResultFilter<"MatchSummary"> | $Enums.MatchResult
    winningTeam?: StringFilter<"MatchSummary"> | string
    firstInningsTeam?: StringFilter<"MatchSummary"> | string
    firstInningsRuns?: IntFilter<"MatchSummary"> | number
    firstInningsWickets?: IntFilter<"MatchSummary"> | number
    firstInningsOvers?: FloatFilter<"MatchSummary"> | number
    secondInningsTeam?: StringFilter<"MatchSummary"> | string
    secondInningsRuns?: IntFilter<"MatchSummary"> | number
    secondInningsWickets?: IntFilter<"MatchSummary"> | number
    secondInningsOvers?: FloatFilter<"MatchSummary"> | number
    target?: IntNullableFilter<"MatchSummary"> | number | null
    totalOvers?: IntFilter<"MatchSummary"> | number
    manOfTheMatchPlayerName?: StringNullableFilter<"MatchSummary"> | string | null
    manOfTheMatchUserId?: StringNullableFilter<"MatchSummary"> | string | null
    manOfTheMatchStats?: JsonNullableFilter<"MatchSummary">
    firstInningsBatsmen?: JsonFilter<"MatchSummary">
    firstInningsBowlers?: JsonFilter<"MatchSummary">
    secondInningsBatsmen?: JsonFilter<"MatchSummary">
    secondInningsBowlers?: JsonFilter<"MatchSummary">
    createdAt?: DateTimeFilter<"MatchSummary"> | Date | string
    homeTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    awayTeam?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    manOfTheMatchUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    playerHistory?: PlayerMatchHistoryListRelationFilter
  }, "id">

  export type MatchSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    homeTeamName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamName?: SortOrder
    awayTeamId?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    firstInningsTeam?: SortOrder
    firstInningsRuns?: SortOrder
    firstInningsWickets?: SortOrder
    firstInningsOvers?: SortOrder
    secondInningsTeam?: SortOrder
    secondInningsRuns?: SortOrder
    secondInningsWickets?: SortOrder
    secondInningsOvers?: SortOrder
    target?: SortOrder
    totalOvers?: SortOrder
    manOfTheMatchPlayerName?: SortOrder
    manOfTheMatchUserId?: SortOrder
    manOfTheMatchStats?: SortOrder
    firstInningsBatsmen?: SortOrder
    firstInningsBowlers?: SortOrder
    secondInningsBatsmen?: SortOrder
    secondInningsBowlers?: SortOrder
    createdAt?: SortOrder
    _count?: MatchSummaryCountOrderByAggregateInput
    _avg?: MatchSummaryAvgOrderByAggregateInput
    _max?: MatchSummaryMaxOrderByAggregateInput
    _min?: MatchSummaryMinOrderByAggregateInput
    _sum?: MatchSummarySumOrderByAggregateInput
  }

  export type MatchSummaryScalarWhereWithAggregatesInput = {
    AND?: MatchSummaryScalarWhereWithAggregatesInput | MatchSummaryScalarWhereWithAggregatesInput[]
    OR?: MatchSummaryScalarWhereWithAggregatesInput[]
    NOT?: MatchSummaryScalarWhereWithAggregatesInput | MatchSummaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MatchSummary"> | string
    matchDate?: DateTimeWithAggregatesFilter<"MatchSummary"> | Date | string
    venue?: StringWithAggregatesFilter<"MatchSummary"> | string
    homeTeamName?: StringWithAggregatesFilter<"MatchSummary"> | string
    homeTeamId?: StringNullableWithAggregatesFilter<"MatchSummary"> | string | null
    awayTeamName?: StringWithAggregatesFilter<"MatchSummary"> | string
    awayTeamId?: StringNullableWithAggregatesFilter<"MatchSummary"> | string | null
    result?: EnumMatchResultWithAggregatesFilter<"MatchSummary"> | $Enums.MatchResult
    winningTeam?: StringWithAggregatesFilter<"MatchSummary"> | string
    firstInningsTeam?: StringWithAggregatesFilter<"MatchSummary"> | string
    firstInningsRuns?: IntWithAggregatesFilter<"MatchSummary"> | number
    firstInningsWickets?: IntWithAggregatesFilter<"MatchSummary"> | number
    firstInningsOvers?: FloatWithAggregatesFilter<"MatchSummary"> | number
    secondInningsTeam?: StringWithAggregatesFilter<"MatchSummary"> | string
    secondInningsRuns?: IntWithAggregatesFilter<"MatchSummary"> | number
    secondInningsWickets?: IntWithAggregatesFilter<"MatchSummary"> | number
    secondInningsOvers?: FloatWithAggregatesFilter<"MatchSummary"> | number
    target?: IntNullableWithAggregatesFilter<"MatchSummary"> | number | null
    totalOvers?: IntWithAggregatesFilter<"MatchSummary"> | number
    manOfTheMatchPlayerName?: StringNullableWithAggregatesFilter<"MatchSummary"> | string | null
    manOfTheMatchUserId?: StringNullableWithAggregatesFilter<"MatchSummary"> | string | null
    manOfTheMatchStats?: JsonNullableWithAggregatesFilter<"MatchSummary">
    firstInningsBatsmen?: JsonWithAggregatesFilter<"MatchSummary">
    firstInningsBowlers?: JsonWithAggregatesFilter<"MatchSummary">
    secondInningsBatsmen?: JsonWithAggregatesFilter<"MatchSummary">
    secondInningsBowlers?: JsonWithAggregatesFilter<"MatchSummary">
    createdAt?: DateTimeWithAggregatesFilter<"MatchSummary"> | Date | string
  }

  export type PlayerMatchHistoryWhereInput = {
    AND?: PlayerMatchHistoryWhereInput | PlayerMatchHistoryWhereInput[]
    OR?: PlayerMatchHistoryWhereInput[]
    NOT?: PlayerMatchHistoryWhereInput | PlayerMatchHistoryWhereInput[]
    id?: StringFilter<"PlayerMatchHistory"> | string
    userId?: StringFilter<"PlayerMatchHistory"> | string
    matchSummaryId?: StringFilter<"PlayerMatchHistory"> | string
    teamName?: StringFilter<"PlayerMatchHistory"> | string
    teamId?: StringNullableFilter<"PlayerMatchHistory"> | string | null
    playerName?: StringFilter<"PlayerMatchHistory"> | string
    runsScored?: IntFilter<"PlayerMatchHistory"> | number
    ballsFaced?: IntFilter<"PlayerMatchHistory"> | number
    wicketsTaken?: IntFilter<"PlayerMatchHistory"> | number
    oversBowled?: FloatFilter<"PlayerMatchHistory"> | number
    isManOfTheMatch?: BoolFilter<"PlayerMatchHistory"> | boolean
    createdAt?: DateTimeFilter<"PlayerMatchHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    matchSummary?: XOR<MatchSummaryScalarRelationFilter, MatchSummaryWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }

  export type PlayerMatchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchSummaryId?: SortOrder
    teamName?: SortOrder
    teamId?: SortOrder
    playerName?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wicketsTaken?: SortOrder
    oversBowled?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    matchSummary?: MatchSummaryOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type PlayerMatchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_matchSummaryId?: PlayerMatchHistoryUserIdMatchSummaryIdCompoundUniqueInput
    AND?: PlayerMatchHistoryWhereInput | PlayerMatchHistoryWhereInput[]
    OR?: PlayerMatchHistoryWhereInput[]
    NOT?: PlayerMatchHistoryWhereInput | PlayerMatchHistoryWhereInput[]
    userId?: StringFilter<"PlayerMatchHistory"> | string
    matchSummaryId?: StringFilter<"PlayerMatchHistory"> | string
    teamName?: StringFilter<"PlayerMatchHistory"> | string
    teamId?: StringNullableFilter<"PlayerMatchHistory"> | string | null
    playerName?: StringFilter<"PlayerMatchHistory"> | string
    runsScored?: IntFilter<"PlayerMatchHistory"> | number
    ballsFaced?: IntFilter<"PlayerMatchHistory"> | number
    wicketsTaken?: IntFilter<"PlayerMatchHistory"> | number
    oversBowled?: FloatFilter<"PlayerMatchHistory"> | number
    isManOfTheMatch?: BoolFilter<"PlayerMatchHistory"> | boolean
    createdAt?: DateTimeFilter<"PlayerMatchHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    matchSummary?: XOR<MatchSummaryScalarRelationFilter, MatchSummaryWhereInput>
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
  }, "id" | "userId_matchSummaryId">

  export type PlayerMatchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    matchSummaryId?: SortOrder
    teamName?: SortOrder
    teamId?: SortOrder
    playerName?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wicketsTaken?: SortOrder
    oversBowled?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
    _count?: PlayerMatchHistoryCountOrderByAggregateInput
    _avg?: PlayerMatchHistoryAvgOrderByAggregateInput
    _max?: PlayerMatchHistoryMaxOrderByAggregateInput
    _min?: PlayerMatchHistoryMinOrderByAggregateInput
    _sum?: PlayerMatchHistorySumOrderByAggregateInput
  }

  export type PlayerMatchHistoryScalarWhereWithAggregatesInput = {
    AND?: PlayerMatchHistoryScalarWhereWithAggregatesInput | PlayerMatchHistoryScalarWhereWithAggregatesInput[]
    OR?: PlayerMatchHistoryScalarWhereWithAggregatesInput[]
    NOT?: PlayerMatchHistoryScalarWhereWithAggregatesInput | PlayerMatchHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerMatchHistory"> | string
    userId?: StringWithAggregatesFilter<"PlayerMatchHistory"> | string
    matchSummaryId?: StringWithAggregatesFilter<"PlayerMatchHistory"> | string
    teamName?: StringWithAggregatesFilter<"PlayerMatchHistory"> | string
    teamId?: StringNullableWithAggregatesFilter<"PlayerMatchHistory"> | string | null
    playerName?: StringWithAggregatesFilter<"PlayerMatchHistory"> | string
    runsScored?: IntWithAggregatesFilter<"PlayerMatchHistory"> | number
    ballsFaced?: IntWithAggregatesFilter<"PlayerMatchHistory"> | number
    wicketsTaken?: IntWithAggregatesFilter<"PlayerMatchHistory"> | number
    oversBowled?: FloatWithAggregatesFilter<"PlayerMatchHistory"> | number
    isManOfTheMatch?: BoolWithAggregatesFilter<"PlayerMatchHistory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlayerMatchHistory"> | Date | string
  }

  export type FixtureWhereInput = {
    AND?: FixtureWhereInput | FixtureWhereInput[]
    OR?: FixtureWhereInput[]
    NOT?: FixtureWhereInput | FixtureWhereInput[]
    id?: StringFilter<"Fixture"> | string
    userId?: StringFilter<"Fixture"> | string
    teamAId?: StringNullableFilter<"Fixture"> | string | null
    teamAName?: StringFilter<"Fixture"> | string
    teamALogo?: StringNullableFilter<"Fixture"> | string | null
    teamAPlayers?: JsonFilter<"Fixture">
    teamBId?: StringNullableFilter<"Fixture"> | string | null
    teamBName?: StringFilter<"Fixture"> | string
    teamBLogo?: StringNullableFilter<"Fixture"> | string | null
    teamBPlayers?: JsonFilter<"Fixture">
    overs?: IntFilter<"Fixture"> | number
    venue?: StringNullableFilter<"Fixture"> | string | null
    createdAt?: DateTimeFilter<"Fixture"> | Date | string
    updatedAt?: DateTimeFilter<"Fixture"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FixtureOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamAId?: SortOrder
    teamAName?: SortOrder
    teamALogo?: SortOrder
    teamAPlayers?: SortOrder
    teamBId?: SortOrder
    teamBName?: SortOrder
    teamBLogo?: SortOrder
    teamBPlayers?: SortOrder
    overs?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FixtureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FixtureWhereInput | FixtureWhereInput[]
    OR?: FixtureWhereInput[]
    NOT?: FixtureWhereInput | FixtureWhereInput[]
    userId?: StringFilter<"Fixture"> | string
    teamAId?: StringNullableFilter<"Fixture"> | string | null
    teamAName?: StringFilter<"Fixture"> | string
    teamALogo?: StringNullableFilter<"Fixture"> | string | null
    teamAPlayers?: JsonFilter<"Fixture">
    teamBId?: StringNullableFilter<"Fixture"> | string | null
    teamBName?: StringFilter<"Fixture"> | string
    teamBLogo?: StringNullableFilter<"Fixture"> | string | null
    teamBPlayers?: JsonFilter<"Fixture">
    overs?: IntFilter<"Fixture"> | number
    venue?: StringNullableFilter<"Fixture"> | string | null
    createdAt?: DateTimeFilter<"Fixture"> | Date | string
    updatedAt?: DateTimeFilter<"Fixture"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FixtureOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    teamAId?: SortOrder
    teamAName?: SortOrder
    teamALogo?: SortOrder
    teamAPlayers?: SortOrder
    teamBId?: SortOrder
    teamBName?: SortOrder
    teamBLogo?: SortOrder
    teamBPlayers?: SortOrder
    overs?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FixtureCountOrderByAggregateInput
    _avg?: FixtureAvgOrderByAggregateInput
    _max?: FixtureMaxOrderByAggregateInput
    _min?: FixtureMinOrderByAggregateInput
    _sum?: FixtureSumOrderByAggregateInput
  }

  export type FixtureScalarWhereWithAggregatesInput = {
    AND?: FixtureScalarWhereWithAggregatesInput | FixtureScalarWhereWithAggregatesInput[]
    OR?: FixtureScalarWhereWithAggregatesInput[]
    NOT?: FixtureScalarWhereWithAggregatesInput | FixtureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fixture"> | string
    userId?: StringWithAggregatesFilter<"Fixture"> | string
    teamAId?: StringNullableWithAggregatesFilter<"Fixture"> | string | null
    teamAName?: StringWithAggregatesFilter<"Fixture"> | string
    teamALogo?: StringNullableWithAggregatesFilter<"Fixture"> | string | null
    teamAPlayers?: JsonWithAggregatesFilter<"Fixture">
    teamBId?: StringNullableWithAggregatesFilter<"Fixture"> | string | null
    teamBName?: StringWithAggregatesFilter<"Fixture"> | string
    teamBLogo?: StringNullableWithAggregatesFilter<"Fixture"> | string | null
    teamBPlayers?: JsonWithAggregatesFilter<"Fixture">
    overs?: IntWithAggregatesFilter<"Fixture"> | number
    venue?: StringNullableWithAggregatesFilter<"Fixture"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Fixture"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fixture"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerStatsCreateInput = {
    id?: string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    strikeRate?: number
    highestScore?: number
    timesOut?: number
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    economy?: number
    bestBowlingWickets?: number
    bestBowlingRuns?: number
    catchesTaken?: number
    runOuts?: number
    manOfTheMatchAwards?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCareerStatsInput
  }

  export type CareerStatsUncheckedCreateInput = {
    id?: string
    userId: string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    strikeRate?: number
    highestScore?: number
    timesOut?: number
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    economy?: number
    bestBowlingWickets?: number
    bestBowlingRuns?: number
    catchesTaken?: number
    runOuts?: number
    manOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type CareerStatsUpdateInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    strikeRate?: FloatFieldUpdateOperationsInput | number
    highestScore?: IntFieldUpdateOperationsInput | number
    timesOut?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    economy?: FloatFieldUpdateOperationsInput | number
    bestBowlingWickets?: IntFieldUpdateOperationsInput | number
    bestBowlingRuns?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    manOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCareerStatsNestedInput
  }

  export type CareerStatsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    strikeRate?: FloatFieldUpdateOperationsInput | number
    highestScore?: IntFieldUpdateOperationsInput | number
    timesOut?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    economy?: FloatFieldUpdateOperationsInput | number
    bestBowlingWickets?: IntFieldUpdateOperationsInput | number
    bestBowlingRuns?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    manOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerStatsCreateManyInput = {
    id?: string
    userId: string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    strikeRate?: number
    highestScore?: number
    timesOut?: number
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    economy?: number
    bestBowlingWickets?: number
    bestBowlingRuns?: number
    catchesTaken?: number
    runOuts?: number
    manOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type CareerStatsUpdateManyMutationInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    strikeRate?: FloatFieldUpdateOperationsInput | number
    highestScore?: IntFieldUpdateOperationsInput | number
    timesOut?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    economy?: FloatFieldUpdateOperationsInput | number
    bestBowlingWickets?: IntFieldUpdateOperationsInput | number
    bestBowlingRuns?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    manOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerStatsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    strikeRate?: FloatFieldUpdateOperationsInput | number
    highestScore?: IntFieldUpdateOperationsInput | number
    timesOut?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    economy?: FloatFieldUpdateOperationsInput | number
    bestBowlingWickets?: IntFieldUpdateOperationsInput | number
    bestBowlingRuns?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    manOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestPlayerCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
    team: TeamCreateNestedOneWithoutGuestPlayersInput
    addedBy: UserCreateNestedOneWithoutGuestPlayersAddedInput
    linkedUser?: UserCreateNestedOneWithoutGuestPlayersLinkedInput
  }

  export type GuestPlayerUncheckedCreateInput = {
    id?: string
    teamId: string
    name: string
    addedByUserId: string
    linkedUserId?: string | null
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type GuestPlayerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    team?: TeamUpdateOneRequiredWithoutGuestPlayersNestedInput
    addedBy?: UserUpdateOneRequiredWithoutGuestPlayersAddedNestedInput
    linkedUser?: UserUpdateOneWithoutGuestPlayersLinkedNestedInput
  }

  export type GuestPlayerUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    linkedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type GuestPlayerCreateManyInput = {
    id?: string
    teamId: string
    name: string
    addedByUserId: string
    linkedUserId?: string | null
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type GuestPlayerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type GuestPlayerUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    linkedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type TeamInvitationCreateInput = {
    id?: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
    invited: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type TeamInvitationUncheckedCreateInput = {
    id?: string
    teamId: string
    invitedBy: string
    invitedUser: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type TeamInvitationUpdateInput = {
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    invited?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type TeamInvitationUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUser?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationCreateManyInput = {
    id?: string
    teamId: string
    invitedBy: string
    invitedUser: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type TeamInvitationUpdateManyMutationInput = {
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUser?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateInput = {
    id?: string
    opponent: string
    matchDate: Date | string
    runsScored: number
    ballsFaced: number
    wasDismissed?: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMatchesInput
  }

  export type MatchUncheckedCreateInput = {
    id?: string
    userId: string
    opponent: string
    matchDate: Date | string
    runsScored: number
    ballsFaced: number
    wasDismissed?: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type MatchUpdateInput = {
    opponent?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMatchesNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    opponent?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchCreateManyInput = {
    id?: string
    userId: string
    opponent: string
    matchDate: Date | string
    runsScored: number
    ballsFaced: number
    wasDismissed?: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    opponent?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    opponent?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchCreateInput = {
    id?: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
    homeTeam: TeamCreateNestedOneWithoutHomeMatchesInput
    awayTeam: TeamCreateNestedOneWithoutAwayMatchesInput
    playerStats?: TeamMatchPlayerCreateNestedManyWithoutTeamMatchInput
  }

  export type TeamMatchUncheckedCreateInput = {
    id?: string
    homeTeamId: string
    awayTeamId: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
    playerStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamMatchInput
  }

  export type TeamMatchUpdateInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneRequiredWithoutHomeMatchesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayMatchesNestedInput
    playerStats?: TeamMatchPlayerUpdateManyWithoutTeamMatchNestedInput
  }

  export type TeamMatchUncheckedUpdateInput = {
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamMatchNestedInput
  }

  export type TeamMatchCreateManyInput = {
    id?: string
    homeTeamId: string
    awayTeamId: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
  }

  export type TeamMatchUpdateManyMutationInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchUncheckedUpdateManyInput = {
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchPlayerCreateInput = {
    id?: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
    teamMatch: TeamMatchCreateNestedOneWithoutPlayerStatsInput
    user: UserCreateNestedOneWithoutTeamMatchStatsInput
    team: TeamCreateNestedOneWithoutTeamMatchStatsInput
  }

  export type TeamMatchPlayerUncheckedCreateInput = {
    id?: string
    teamMatchId: string
    userId: string
    teamId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type TeamMatchPlayerUpdateInput = {
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    teamMatch?: TeamMatchUpdateOneRequiredWithoutPlayerStatsNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMatchStatsNestedInput
    team?: TeamUpdateOneRequiredWithoutTeamMatchStatsNestedInput
  }

  export type TeamMatchPlayerUncheckedUpdateInput = {
    teamMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMatchPlayerCreateManyInput = {
    id?: string
    teamMatchId: string
    userId: string
    teamId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type TeamMatchPlayerUpdateManyMutationInput = {
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMatchPlayerUncheckedUpdateManyInput = {
    teamMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type TeamStatisticsCreateInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamStatsInput
    topRunScorer?: UserCreateNestedOneWithoutTopRunScorerForInput
    topWicketTaker?: UserCreateNestedOneWithoutTopWicketTakerForInput
    bestStrikeRatePlayer?: UserCreateNestedOneWithoutBestStrikeRateForInput
    bestEconomyPlayer?: UserCreateNestedOneWithoutBestEconomyForInput
    mostManOfTheMatchPlayer?: UserCreateNestedOneWithoutMostManOfTheMatchForInput
  }

  export type TeamStatisticsUncheckedCreateInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsUpdateInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
    topRunScorer?: UserUpdateOneWithoutTopRunScorerForNestedInput
    topWicketTaker?: UserUpdateOneWithoutTopWicketTakerForNestedInput
    bestStrikeRatePlayer?: UserUpdateOneWithoutBestStrikeRateForNestedInput
    bestEconomyPlayer?: UserUpdateOneWithoutBestEconomyForNestedInput
    mostManOfTheMatchPlayer?: UserUpdateOneWithoutMostManOfTheMatchForNestedInput
  }

  export type TeamStatisticsUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsCreateManyInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsUpdateManyMutationInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalMatchCreateInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedLocalMatchesInput
    myTeam?: TeamCreateNestedOneWithoutLocalMatchesAsMyTeamInput
    opponentTeam?: TeamCreateNestedOneWithoutLocalMatchesAsOpponentInput
    spectators?: MatchSpectatorCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchUncheckedCreateInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    spectators?: MatchSpectatorUncheckedCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryUncheckedCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchUpdateInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedLocalMatchesNestedInput
    myTeam?: TeamUpdateOneWithoutLocalMatchesAsMyTeamNestedInput
    opponentTeam?: TeamUpdateOneWithoutLocalMatchesAsOpponentNestedInput
    spectators?: MatchSpectatorUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spectators?: MatchSpectatorUncheckedUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUncheckedUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchCreateManyInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalMatchUpdateManyMutationInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalMatchUncheckedUpdateManyInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchSpectatorCreateInput = {
    id?: string
    addedAt?: Date | string
    notified?: boolean
    localMatch: LocalMatchCreateNestedOneWithoutSpectatorsInput
    user: UserCreateNestedOneWithoutSpectatorOfInput
    addedByUser: UserCreateNestedOneWithoutAddedSpectatorsInput
  }

  export type MatchSpectatorUncheckedCreateInput = {
    id?: string
    localMatchId: string
    userId: string
    addedBy: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type MatchSpectatorUpdateInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
    localMatch?: LocalMatchUpdateOneRequiredWithoutSpectatorsNestedInput
    user?: UserUpdateOneRequiredWithoutSpectatorOfNestedInput
    addedByUser?: UserUpdateOneRequiredWithoutAddedSpectatorsNestedInput
  }

  export type MatchSpectatorUncheckedUpdateInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedBy?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchSpectatorCreateManyInput = {
    id?: string
    localMatchId: string
    userId: string
    addedBy: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type MatchSpectatorUpdateManyMutationInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchSpectatorUncheckedUpdateManyInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedBy?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OverHistoryCreateInput = {
    id?: string
    overNumber: number
    innings: number
    balls: InputJsonValue
    totalRuns?: number
    wickets?: number
    createdAt?: Date | string
    localMatch: LocalMatchCreateNestedOneWithoutOverHistoryInput
  }

  export type OverHistoryUncheckedCreateInput = {
    id?: string
    localMatchId: string
    overNumber: number
    innings: number
    balls: InputJsonValue
    totalRuns?: number
    wickets?: number
    createdAt?: Date | string
  }

  export type OverHistoryUpdateInput = {
    overNumber?: IntFieldUpdateOperationsInput | number
    innings?: IntFieldUpdateOperationsInput | number
    balls?: InputJsonValue | InputJsonValue
    totalRuns?: IntFieldUpdateOperationsInput | number
    wickets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localMatch?: LocalMatchUpdateOneRequiredWithoutOverHistoryNestedInput
  }

  export type OverHistoryUncheckedUpdateInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    overNumber?: IntFieldUpdateOperationsInput | number
    innings?: IntFieldUpdateOperationsInput | number
    balls?: InputJsonValue | InputJsonValue
    totalRuns?: IntFieldUpdateOperationsInput | number
    wickets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OverHistoryCreateManyInput = {
    id?: string
    localMatchId: string
    overNumber: number
    innings: number
    balls: InputJsonValue
    totalRuns?: number
    wickets?: number
    createdAt?: Date | string
  }

  export type OverHistoryUpdateManyMutationInput = {
    overNumber?: IntFieldUpdateOperationsInput | number
    innings?: IntFieldUpdateOperationsInput | number
    balls?: InputJsonValue | InputJsonValue
    totalRuns?: IntFieldUpdateOperationsInput | number
    wickets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OverHistoryUncheckedUpdateManyInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    overNumber?: IntFieldUpdateOperationsInput | number
    innings?: IntFieldUpdateOperationsInput | number
    balls?: InputJsonValue | InputJsonValue
    totalRuns?: IntFieldUpdateOperationsInput | number
    wickets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchSummaryCreateInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    awayTeamName: string
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    homeTeam?: TeamCreateNestedOneWithoutMatchSummariesAsHomeInput
    awayTeam?: TeamCreateNestedOneWithoutMatchSummariesAsAwayInput
    manOfTheMatchUser?: UserCreateNestedOneWithoutMatchSummariesAsManOfTheMatchInput
    playerHistory?: PlayerMatchHistoryCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryUncheckedCreateInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    homeTeamId?: string | null
    awayTeamName: string
    awayTeamId?: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchUserId?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    playerHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryUpdateInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneWithoutMatchSummariesAsHomeNestedInput
    awayTeam?: TeamUpdateOneWithoutMatchSummariesAsAwayNestedInput
    manOfTheMatchUser?: UserUpdateOneWithoutMatchSummariesAsManOfTheMatchNestedInput
    playerHistory?: PlayerMatchHistoryUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryUncheckedUpdateInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    homeTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    awayTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchUserId?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryCreateManyInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    homeTeamId?: string | null
    awayTeamName: string
    awayTeamId?: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchUserId?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
  }

  export type MatchSummaryUpdateManyMutationInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchSummaryUncheckedUpdateManyInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    homeTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    awayTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchUserId?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryCreateInput = {
    id?: string
    teamName: string
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerMatchHistoryInput
    matchSummary: MatchSummaryCreateNestedOneWithoutPlayerHistoryInput
    team?: TeamCreateNestedOneWithoutPlayerMatchHistoryInput
  }

  export type PlayerMatchHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    matchSummaryId: string
    teamName: string
    teamId?: string | null
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryUpdateInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerMatchHistoryNestedInput
    matchSummary?: MatchSummaryUpdateOneRequiredWithoutPlayerHistoryNestedInput
    team?: TeamUpdateOneWithoutPlayerMatchHistoryNestedInput
  }

  export type PlayerMatchHistoryUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    matchSummaryId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryCreateManyInput = {
    id?: string
    userId: string
    matchSummaryId: string
    teamName: string
    teamId?: string | null
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryUpdateManyMutationInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    matchSummaryId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixtureCreateInput = {
    id?: string
    teamAId?: string | null
    teamAName: string
    teamALogo?: string | null
    teamAPlayers: InputJsonValue
    teamBId?: string | null
    teamBName: string
    teamBLogo?: string | null
    teamBPlayers: InputJsonValue
    overs?: number
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFixturesInput
  }

  export type FixtureUncheckedCreateInput = {
    id?: string
    userId: string
    teamAId?: string | null
    teamAName: string
    teamALogo?: string | null
    teamAPlayers: InputJsonValue
    teamBId?: string | null
    teamBName: string
    teamBLogo?: string | null
    teamBPlayers: InputJsonValue
    overs?: number
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixtureUpdateInput = {
    teamAId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAName?: StringFieldUpdateOperationsInput | string
    teamALogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamAPlayers?: InputJsonValue | InputJsonValue
    teamBId?: NullableStringFieldUpdateOperationsInput | string | null
    teamBName?: StringFieldUpdateOperationsInput | string
    teamBLogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamBPlayers?: InputJsonValue | InputJsonValue
    overs?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFixturesNestedInput
  }

  export type FixtureUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamAId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAName?: StringFieldUpdateOperationsInput | string
    teamALogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamAPlayers?: InputJsonValue | InputJsonValue
    teamBId?: NullableStringFieldUpdateOperationsInput | string | null
    teamBName?: StringFieldUpdateOperationsInput | string
    teamBLogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamBPlayers?: InputJsonValue | InputJsonValue
    overs?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixtureCreateManyInput = {
    id?: string
    userId: string
    teamAId?: string | null
    teamAName: string
    teamALogo?: string | null
    teamAPlayers: InputJsonValue
    teamBId?: string | null
    teamBName: string
    teamBLogo?: string | null
    teamBPlayers: InputJsonValue
    overs?: number
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixtureUpdateManyMutationInput = {
    teamAId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAName?: StringFieldUpdateOperationsInput | string
    teamALogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamAPlayers?: InputJsonValue | InputJsonValue
    teamBId?: NullableStringFieldUpdateOperationsInput | string | null
    teamBName?: StringFieldUpdateOperationsInput | string
    teamBLogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamBPlayers?: InputJsonValue | InputJsonValue
    overs?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixtureUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamAId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAName?: StringFieldUpdateOperationsInput | string
    teamALogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamAPlayers?: InputJsonValue | InputJsonValue
    teamBId?: NullableStringFieldUpdateOperationsInput | string | null
    teamBName?: StringFieldUpdateOperationsInput | string
    teamBLogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamBPlayers?: InputJsonValue | InputJsonValue
    overs?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
    isSet?: boolean
  }

  export type EnumBattingHandNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BattingHand | EnumBattingHandFieldRefInput<$PrismaModel> | null
    in?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBattingHandNullableFilter<$PrismaModel> | $Enums.BattingHand | null
    isSet?: boolean
  }

  export type EnumBowlingStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BowlingStyle | EnumBowlingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBowlingStyleNullableFilter<$PrismaModel> | $Enums.BowlingStyle | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CareerStatsNullableScalarRelationFilter = {
    is?: CareerStatsWhereInput | null
    isNot?: CareerStatsWhereInput | null
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type TeamInvitationListRelationFilter = {
    every?: TeamInvitationWhereInput
    some?: TeamInvitationWhereInput
    none?: TeamInvitationWhereInput
  }

  export type GuestPlayerListRelationFilter = {
    every?: GuestPlayerWhereInput
    some?: GuestPlayerWhereInput
    none?: GuestPlayerWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type TeamMatchPlayerListRelationFilter = {
    every?: TeamMatchPlayerWhereInput
    some?: TeamMatchPlayerWhereInput
    none?: TeamMatchPlayerWhereInput
  }

  export type TeamStatisticsListRelationFilter = {
    every?: TeamStatisticsWhereInput
    some?: TeamStatisticsWhereInput
    none?: TeamStatisticsWhereInput
  }

  export type LocalMatchListRelationFilter = {
    every?: LocalMatchWhereInput
    some?: LocalMatchWhereInput
    none?: LocalMatchWhereInput
  }

  export type MatchSpectatorListRelationFilter = {
    every?: MatchSpectatorWhereInput
    some?: MatchSpectatorWhereInput
    none?: MatchSpectatorWhereInput
  }

  export type MatchSummaryListRelationFilter = {
    every?: MatchSummaryWhereInput
    some?: MatchSummaryWhereInput
    none?: MatchSummaryWhereInput
  }

  export type PlayerMatchHistoryListRelationFilter = {
    every?: PlayerMatchHistoryWhereInput
    some?: PlayerMatchHistoryWhereInput
    none?: PlayerMatchHistoryWhereInput
  }

  export type FixtureListRelationFilter = {
    every?: FixtureWhereInput
    some?: FixtureWhereInput
    none?: FixtureWhereInput
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuestPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMatchPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamStatisticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchSpectatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerMatchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FixtureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profileName?: SortOrder
    description?: SortOrder
    profilePictureUrl?: SortOrder
    role?: SortOrder
    battingHand?: SortOrder
    bowlingStyle?: SortOrder
    profileComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profileName?: SortOrder
    description?: SortOrder
    profilePictureUrl?: SortOrder
    role?: SortOrder
    battingHand?: SortOrder
    bowlingStyle?: SortOrder
    profileComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    profileName?: SortOrder
    description?: SortOrder
    profilePictureUrl?: SortOrder
    role?: SortOrder
    battingHand?: SortOrder
    bowlingStyle?: SortOrder
    profileComplete?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumBattingHandNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattingHand | EnumBattingHandFieldRefInput<$PrismaModel> | null
    in?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBattingHandNullableWithAggregatesFilter<$PrismaModel> | $Enums.BattingHand | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBattingHandNullableFilter<$PrismaModel>
    _max?: NestedEnumBattingHandNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumBowlingStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BowlingStyle | EnumBowlingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBowlingStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.BowlingStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBowlingStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumBowlingStyleNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CareerStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    strikeRate?: SortOrder
    highestScore?: SortOrder
    timesOut?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    economy?: SortOrder
    bestBowlingWickets?: SortOrder
    bestBowlingRuns?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    manOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerStatsAvgOrderByAggregateInput = {
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    strikeRate?: SortOrder
    highestScore?: SortOrder
    timesOut?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    economy?: SortOrder
    bestBowlingWickets?: SortOrder
    bestBowlingRuns?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    manOfTheMatchAwards?: SortOrder
  }

  export type CareerStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    strikeRate?: SortOrder
    highestScore?: SortOrder
    timesOut?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    economy?: SortOrder
    bestBowlingWickets?: SortOrder
    bestBowlingRuns?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    manOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    strikeRate?: SortOrder
    highestScore?: SortOrder
    timesOut?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    economy?: SortOrder
    bestBowlingWickets?: SortOrder
    bestBowlingRuns?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    manOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
  }

  export type CareerStatsSumOrderByAggregateInput = {
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    strikeRate?: SortOrder
    highestScore?: SortOrder
    timesOut?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    economy?: SortOrder
    bestBowlingWickets?: SortOrder
    bestBowlingRuns?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    manOfTheMatchAwards?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TeamMatchListRelationFilter = {
    every?: TeamMatchWhereInput
    some?: TeamMatchWhereInput
    none?: TeamMatchWhereInput
  }

  export type TeamStatisticsNullableScalarRelationFilter = {
    is?: TeamStatisticsWhereInput | null
    isNot?: TeamStatisticsWhereInput | null
  }

  export type TeamMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    teamCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    createdById?: SortOrder
    captainId?: SortOrder
    viceCaptainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    teamCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    createdById?: SortOrder
    captainId?: SortOrder
    viceCaptainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    teamCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    createdById?: SortOrder
    captainId?: SortOrder
    viceCaptainId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    joinedAt?: SortOrder
  }

  export type GuestPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    addedByUserId?: SortOrder
    linkedUserId?: SortOrder
    createdAt?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    fours?: SortOrder
    sixes?: SortOrder
    wicketsTaken?: SortOrder
    runsConceded?: SortOrder
    oversBowled?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
  }

  export type GuestPlayerAvgOrderByAggregateInput = {
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    fours?: SortOrder
    sixes?: SortOrder
    wicketsTaken?: SortOrder
    runsConceded?: SortOrder
    oversBowled?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
  }

  export type GuestPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    addedByUserId?: SortOrder
    linkedUserId?: SortOrder
    createdAt?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    fours?: SortOrder
    sixes?: SortOrder
    wicketsTaken?: SortOrder
    runsConceded?: SortOrder
    oversBowled?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
  }

  export type GuestPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    addedByUserId?: SortOrder
    linkedUserId?: SortOrder
    createdAt?: SortOrder
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    fours?: SortOrder
    sixes?: SortOrder
    wicketsTaken?: SortOrder
    runsConceded?: SortOrder
    oversBowled?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
  }

  export type GuestPlayerSumOrderByAggregateInput = {
    matchesPlayed?: SortOrder
    totalRuns?: SortOrder
    ballsFaced?: SortOrder
    fours?: SortOrder
    sixes?: SortOrder
    wicketsTaken?: SortOrder
    runsConceded?: SortOrder
    oversBowled?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type TeamInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    invitedBy?: SortOrder
    invitedUser?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    invitedBy?: SortOrder
    invitedUser?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    invitedBy?: SortOrder
    invitedUser?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opponent?: SortOrder
    matchDate?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opponent?: SortOrder
    matchDate?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    opponent?: SortOrder
    matchDate?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
    runOuts?: SortOrder
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type EnumMatchResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMatchResultNullableFilter<$PrismaModel> | $Enums.MatchResult | null
    isSet?: boolean
  }

  export type TeamMatchCountOrderByAggregateInput = {
    id?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    result?: SortOrder
    homeTeamRuns?: SortOrder
    homeTeamWickets?: SortOrder
    homeTeamOvers?: SortOrder
    awayTeamRuns?: SortOrder
    awayTeamWickets?: SortOrder
    awayTeamOvers?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMatchAvgOrderByAggregateInput = {
    homeTeamRuns?: SortOrder
    homeTeamWickets?: SortOrder
    homeTeamOvers?: SortOrder
    awayTeamRuns?: SortOrder
    awayTeamWickets?: SortOrder
    awayTeamOvers?: SortOrder
  }

  export type TeamMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    result?: SortOrder
    homeTeamRuns?: SortOrder
    homeTeamWickets?: SortOrder
    homeTeamOvers?: SortOrder
    awayTeamRuns?: SortOrder
    awayTeamWickets?: SortOrder
    awayTeamOvers?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMatchMinOrderByAggregateInput = {
    id?: SortOrder
    homeTeamId?: SortOrder
    awayTeamId?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    status?: SortOrder
    result?: SortOrder
    homeTeamRuns?: SortOrder
    homeTeamWickets?: SortOrder
    homeTeamOvers?: SortOrder
    awayTeamRuns?: SortOrder
    awayTeamWickets?: SortOrder
    awayTeamOvers?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamMatchSumOrderByAggregateInput = {
    homeTeamRuns?: SortOrder
    homeTeamWickets?: SortOrder
    homeTeamOvers?: SortOrder
    awayTeamRuns?: SortOrder
    awayTeamWickets?: SortOrder
    awayTeamOvers?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type EnumMatchResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMatchResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.MatchResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMatchResultNullableFilter<$PrismaModel>
    _max?: NestedEnumMatchResultNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type TeamMatchScalarRelationFilter = {
    is?: TeamMatchWhereInput
    isNot?: TeamMatchWhereInput
  }

  export type TeamMatchPlayerTeamMatchIdUserIdCompoundUniqueInput = {
    teamMatchId: string
    userId: string
  }

  export type TeamMatchPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    teamMatchId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
  }

  export type TeamMatchPlayerAvgOrderByAggregateInput = {
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
  }

  export type TeamMatchPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    teamMatchId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
  }

  export type TeamMatchPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    teamMatchId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wasDismissed?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
  }

  export type TeamMatchPlayerSumOrderByAggregateInput = {
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    oversBowled?: SortOrder
    runsConceded?: SortOrder
    wicketsTaken?: SortOrder
    catchesTaken?: SortOrder
  }

  export type TeamStatisticsCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    matchesPlayed?: SortOrder
    matchesWon?: SortOrder
    matchesLost?: SortOrder
    matchesDrawn?: SortOrder
    winRatio?: SortOrder
    topRunScorerId?: SortOrder
    topRunScorerRuns?: SortOrder
    topWicketTakerId?: SortOrder
    topWicketTakerWickets?: SortOrder
    bestStrikeRatePlayerId?: SortOrder
    bestStrikeRate?: SortOrder
    bestEconomyPlayerId?: SortOrder
    bestEconomy?: SortOrder
    mostManOfTheMatchPlayerId?: SortOrder
    mostManOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamStatisticsAvgOrderByAggregateInput = {
    matchesPlayed?: SortOrder
    matchesWon?: SortOrder
    matchesLost?: SortOrder
    matchesDrawn?: SortOrder
    winRatio?: SortOrder
    topRunScorerRuns?: SortOrder
    topWicketTakerWickets?: SortOrder
    bestStrikeRate?: SortOrder
    bestEconomy?: SortOrder
    mostManOfTheMatchAwards?: SortOrder
  }

  export type TeamStatisticsMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    matchesPlayed?: SortOrder
    matchesWon?: SortOrder
    matchesLost?: SortOrder
    matchesDrawn?: SortOrder
    winRatio?: SortOrder
    topRunScorerId?: SortOrder
    topRunScorerRuns?: SortOrder
    topWicketTakerId?: SortOrder
    topWicketTakerWickets?: SortOrder
    bestStrikeRatePlayerId?: SortOrder
    bestStrikeRate?: SortOrder
    bestEconomyPlayerId?: SortOrder
    bestEconomy?: SortOrder
    mostManOfTheMatchPlayerId?: SortOrder
    mostManOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamStatisticsMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    matchesPlayed?: SortOrder
    matchesWon?: SortOrder
    matchesLost?: SortOrder
    matchesDrawn?: SortOrder
    winRatio?: SortOrder
    topRunScorerId?: SortOrder
    topRunScorerRuns?: SortOrder
    topWicketTakerId?: SortOrder
    topWicketTakerWickets?: SortOrder
    bestStrikeRatePlayerId?: SortOrder
    bestStrikeRate?: SortOrder
    bestEconomyPlayerId?: SortOrder
    bestEconomy?: SortOrder
    mostManOfTheMatchPlayerId?: SortOrder
    mostManOfTheMatchAwards?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamStatisticsSumOrderByAggregateInput = {
    matchesPlayed?: SortOrder
    matchesWon?: SortOrder
    matchesLost?: SortOrder
    matchesDrawn?: SortOrder
    winRatio?: SortOrder
    topRunScorerRuns?: SortOrder
    topWicketTakerWickets?: SortOrder
    bestStrikeRate?: SortOrder
    bestEconomy?: SortOrder
    mostManOfTheMatchAwards?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type EnumLocalMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LocalMatchStatus | EnumLocalMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLocalMatchStatusFilter<$PrismaModel> | $Enums.LocalMatchStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type OverHistoryListRelationFilter = {
    every?: OverHistoryWhereInput
    some?: OverHistoryWhereInput
    none?: OverHistoryWhereInput
  }

  export type OverHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocalMatchCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    matchName?: SortOrder
    venue?: SortOrder
    matchDate?: SortOrder
    overs?: SortOrder
    myTeamName?: SortOrder
    myTeamId?: SortOrder
    opponentTeamName?: SortOrder
    opponentTeamId?: SortOrder
    myTeamPlayers?: SortOrder
    opponentTeamPlayers?: SortOrder
    allowSpectators?: SortOrder
    isRoomMatch?: SortOrder
    roomPassword?: SortOrder
    status?: SortOrder
    currentInnings?: SortOrder
    currentOver?: SortOrder
    currentBall?: SortOrder
    myTeamScore?: SortOrder
    myTeamWickets?: SortOrder
    myTeamOvers?: SortOrder
    opponentTeamScore?: SortOrder
    opponentTeamWickets?: SortOrder
    opponentTeamOvers?: SortOrder
    fullState?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalMatchAvgOrderByAggregateInput = {
    overs?: SortOrder
    currentInnings?: SortOrder
    currentOver?: SortOrder
    currentBall?: SortOrder
    myTeamScore?: SortOrder
    myTeamWickets?: SortOrder
    myTeamOvers?: SortOrder
    opponentTeamScore?: SortOrder
    opponentTeamWickets?: SortOrder
    opponentTeamOvers?: SortOrder
  }

  export type LocalMatchMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    matchName?: SortOrder
    venue?: SortOrder
    matchDate?: SortOrder
    overs?: SortOrder
    myTeamName?: SortOrder
    myTeamId?: SortOrder
    opponentTeamName?: SortOrder
    opponentTeamId?: SortOrder
    allowSpectators?: SortOrder
    isRoomMatch?: SortOrder
    roomPassword?: SortOrder
    status?: SortOrder
    currentInnings?: SortOrder
    currentOver?: SortOrder
    currentBall?: SortOrder
    myTeamScore?: SortOrder
    myTeamWickets?: SortOrder
    myTeamOvers?: SortOrder
    opponentTeamScore?: SortOrder
    opponentTeamWickets?: SortOrder
    opponentTeamOvers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalMatchMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    matchName?: SortOrder
    venue?: SortOrder
    matchDate?: SortOrder
    overs?: SortOrder
    myTeamName?: SortOrder
    myTeamId?: SortOrder
    opponentTeamName?: SortOrder
    opponentTeamId?: SortOrder
    allowSpectators?: SortOrder
    isRoomMatch?: SortOrder
    roomPassword?: SortOrder
    status?: SortOrder
    currentInnings?: SortOrder
    currentOver?: SortOrder
    currentBall?: SortOrder
    myTeamScore?: SortOrder
    myTeamWickets?: SortOrder
    myTeamOvers?: SortOrder
    opponentTeamScore?: SortOrder
    opponentTeamWickets?: SortOrder
    opponentTeamOvers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalMatchSumOrderByAggregateInput = {
    overs?: SortOrder
    currentInnings?: SortOrder
    currentOver?: SortOrder
    currentBall?: SortOrder
    myTeamScore?: SortOrder
    myTeamWickets?: SortOrder
    myTeamOvers?: SortOrder
    opponentTeamScore?: SortOrder
    opponentTeamWickets?: SortOrder
    opponentTeamOvers?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumLocalMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocalMatchStatus | EnumLocalMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLocalMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.LocalMatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocalMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumLocalMatchStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type LocalMatchScalarRelationFilter = {
    is?: LocalMatchWhereInput
    isNot?: LocalMatchWhereInput
  }

  export type MatchSpectatorLocalMatchIdUserIdCompoundUniqueInput = {
    localMatchId: string
    userId: string
  }

  export type MatchSpectatorCountOrderByAggregateInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    userId?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    notified?: SortOrder
  }

  export type MatchSpectatorMaxOrderByAggregateInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    userId?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    notified?: SortOrder
  }

  export type MatchSpectatorMinOrderByAggregateInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    userId?: SortOrder
    addedBy?: SortOrder
    addedAt?: SortOrder
    notified?: SortOrder
  }

  export type OverHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    overNumber?: SortOrder
    innings?: SortOrder
    balls?: SortOrder
    totalRuns?: SortOrder
    wickets?: SortOrder
    createdAt?: SortOrder
  }

  export type OverHistoryAvgOrderByAggregateInput = {
    overNumber?: SortOrder
    innings?: SortOrder
    totalRuns?: SortOrder
    wickets?: SortOrder
  }

  export type OverHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    overNumber?: SortOrder
    innings?: SortOrder
    totalRuns?: SortOrder
    wickets?: SortOrder
    createdAt?: SortOrder
  }

  export type OverHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    localMatchId?: SortOrder
    overNumber?: SortOrder
    innings?: SortOrder
    totalRuns?: SortOrder
    wickets?: SortOrder
    createdAt?: SortOrder
  }

  export type OverHistorySumOrderByAggregateInput = {
    overNumber?: SortOrder
    innings?: SortOrder
    totalRuns?: SortOrder
    wickets?: SortOrder
  }

  export type EnumMatchResultFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel>
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchResultFilter<$PrismaModel> | $Enums.MatchResult
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type MatchSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    homeTeamName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamName?: SortOrder
    awayTeamId?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    firstInningsTeam?: SortOrder
    firstInningsRuns?: SortOrder
    firstInningsWickets?: SortOrder
    firstInningsOvers?: SortOrder
    secondInningsTeam?: SortOrder
    secondInningsRuns?: SortOrder
    secondInningsWickets?: SortOrder
    secondInningsOvers?: SortOrder
    target?: SortOrder
    totalOvers?: SortOrder
    manOfTheMatchPlayerName?: SortOrder
    manOfTheMatchUserId?: SortOrder
    manOfTheMatchStats?: SortOrder
    firstInningsBatsmen?: SortOrder
    firstInningsBowlers?: SortOrder
    secondInningsBatsmen?: SortOrder
    secondInningsBowlers?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchSummaryAvgOrderByAggregateInput = {
    firstInningsRuns?: SortOrder
    firstInningsWickets?: SortOrder
    firstInningsOvers?: SortOrder
    secondInningsRuns?: SortOrder
    secondInningsWickets?: SortOrder
    secondInningsOvers?: SortOrder
    target?: SortOrder
    totalOvers?: SortOrder
  }

  export type MatchSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    homeTeamName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamName?: SortOrder
    awayTeamId?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    firstInningsTeam?: SortOrder
    firstInningsRuns?: SortOrder
    firstInningsWickets?: SortOrder
    firstInningsOvers?: SortOrder
    secondInningsTeam?: SortOrder
    secondInningsRuns?: SortOrder
    secondInningsWickets?: SortOrder
    secondInningsOvers?: SortOrder
    target?: SortOrder
    totalOvers?: SortOrder
    manOfTheMatchPlayerName?: SortOrder
    manOfTheMatchUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    matchDate?: SortOrder
    venue?: SortOrder
    homeTeamName?: SortOrder
    homeTeamId?: SortOrder
    awayTeamName?: SortOrder
    awayTeamId?: SortOrder
    result?: SortOrder
    winningTeam?: SortOrder
    firstInningsTeam?: SortOrder
    firstInningsRuns?: SortOrder
    firstInningsWickets?: SortOrder
    firstInningsOvers?: SortOrder
    secondInningsTeam?: SortOrder
    secondInningsRuns?: SortOrder
    secondInningsWickets?: SortOrder
    secondInningsOvers?: SortOrder
    target?: SortOrder
    totalOvers?: SortOrder
    manOfTheMatchPlayerName?: SortOrder
    manOfTheMatchUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchSummarySumOrderByAggregateInput = {
    firstInningsRuns?: SortOrder
    firstInningsWickets?: SortOrder
    firstInningsOvers?: SortOrder
    secondInningsRuns?: SortOrder
    secondInningsWickets?: SortOrder
    secondInningsOvers?: SortOrder
    target?: SortOrder
    totalOvers?: SortOrder
  }

  export type EnumMatchResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel>
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchResultWithAggregatesFilter<$PrismaModel> | $Enums.MatchResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchResultFilter<$PrismaModel>
    _max?: NestedEnumMatchResultFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type MatchSummaryScalarRelationFilter = {
    is?: MatchSummaryWhereInput
    isNot?: MatchSummaryWhereInput
  }

  export type PlayerMatchHistoryUserIdMatchSummaryIdCompoundUniqueInput = {
    userId: string
    matchSummaryId: string
  }

  export type PlayerMatchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchSummaryId?: SortOrder
    teamName?: SortOrder
    teamId?: SortOrder
    playerName?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wicketsTaken?: SortOrder
    oversBowled?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerMatchHistoryAvgOrderByAggregateInput = {
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wicketsTaken?: SortOrder
    oversBowled?: SortOrder
  }

  export type PlayerMatchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchSummaryId?: SortOrder
    teamName?: SortOrder
    teamId?: SortOrder
    playerName?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wicketsTaken?: SortOrder
    oversBowled?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerMatchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matchSummaryId?: SortOrder
    teamName?: SortOrder
    teamId?: SortOrder
    playerName?: SortOrder
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wicketsTaken?: SortOrder
    oversBowled?: SortOrder
    isManOfTheMatch?: SortOrder
    createdAt?: SortOrder
  }

  export type PlayerMatchHistorySumOrderByAggregateInput = {
    runsScored?: SortOrder
    ballsFaced?: SortOrder
    wicketsTaken?: SortOrder
    oversBowled?: SortOrder
  }

  export type FixtureCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamAId?: SortOrder
    teamAName?: SortOrder
    teamALogo?: SortOrder
    teamAPlayers?: SortOrder
    teamBId?: SortOrder
    teamBName?: SortOrder
    teamBLogo?: SortOrder
    teamBPlayers?: SortOrder
    overs?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixtureAvgOrderByAggregateInput = {
    overs?: SortOrder
  }

  export type FixtureMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamAId?: SortOrder
    teamAName?: SortOrder
    teamALogo?: SortOrder
    teamBId?: SortOrder
    teamBName?: SortOrder
    teamBLogo?: SortOrder
    overs?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixtureMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    teamAId?: SortOrder
    teamAName?: SortOrder
    teamALogo?: SortOrder
    teamBId?: SortOrder
    teamBName?: SortOrder
    teamBLogo?: SortOrder
    overs?: SortOrder
    venue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FixtureSumOrderByAggregateInput = {
    overs?: SortOrder
  }

  export type CareerStatsCreateNestedOneWithoutUserInput = {
    create?: XOR<CareerStatsCreateWithoutUserInput, CareerStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CareerStatsCreateOrConnectWithoutUserInput
    connect?: CareerStatsWhereUniqueInput
  }

  export type TeamCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutCaptainInput = {
    create?: XOR<TeamCreateWithoutCaptainInput, TeamUncheckedCreateWithoutCaptainInput> | TeamCreateWithoutCaptainInput[] | TeamUncheckedCreateWithoutCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCaptainInput | TeamCreateOrConnectWithoutCaptainInput[]
    createMany?: TeamCreateManyCaptainInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutViceCaptainInput = {
    create?: XOR<TeamCreateWithoutViceCaptainInput, TeamUncheckedCreateWithoutViceCaptainInput> | TeamCreateWithoutViceCaptainInput[] | TeamUncheckedCreateWithoutViceCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutViceCaptainInput | TeamCreateOrConnectWithoutViceCaptainInput[]
    createMany?: TeamCreateManyViceCaptainInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamInvitationCreateNestedManyWithoutInviterInput = {
    create?: XOR<TeamInvitationCreateWithoutInviterInput, TeamInvitationUncheckedCreateWithoutInviterInput> | TeamInvitationCreateWithoutInviterInput[] | TeamInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInviterInput | TeamInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: TeamInvitationCreateManyInviterInputEnvelope
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
  }

  export type TeamInvitationCreateNestedManyWithoutInvitedInput = {
    create?: XOR<TeamInvitationCreateWithoutInvitedInput, TeamInvitationUncheckedCreateWithoutInvitedInput> | TeamInvitationCreateWithoutInvitedInput[] | TeamInvitationUncheckedCreateWithoutInvitedInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInvitedInput | TeamInvitationCreateOrConnectWithoutInvitedInput[]
    createMany?: TeamInvitationCreateManyInvitedInputEnvelope
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
  }

  export type GuestPlayerCreateNestedManyWithoutAddedByInput = {
    create?: XOR<GuestPlayerCreateWithoutAddedByInput, GuestPlayerUncheckedCreateWithoutAddedByInput> | GuestPlayerCreateWithoutAddedByInput[] | GuestPlayerUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutAddedByInput | GuestPlayerCreateOrConnectWithoutAddedByInput[]
    createMany?: GuestPlayerCreateManyAddedByInputEnvelope
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
  }

  export type GuestPlayerCreateNestedManyWithoutLinkedUserInput = {
    create?: XOR<GuestPlayerCreateWithoutLinkedUserInput, GuestPlayerUncheckedCreateWithoutLinkedUserInput> | GuestPlayerCreateWithoutLinkedUserInput[] | GuestPlayerUncheckedCreateWithoutLinkedUserInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutLinkedUserInput | GuestPlayerCreateOrConnectWithoutLinkedUserInput[]
    createMany?: GuestPlayerCreateManyLinkedUserInputEnvelope
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchCreateWithoutUserInput, MatchUncheckedCreateWithoutUserInput> | MatchCreateWithoutUserInput[] | MatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserInput | MatchCreateOrConnectWithoutUserInput[]
    createMany?: MatchCreateManyUserInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type TeamMatchPlayerCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutUserInput, TeamMatchPlayerUncheckedCreateWithoutUserInput> | TeamMatchPlayerCreateWithoutUserInput[] | TeamMatchPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutUserInput | TeamMatchPlayerCreateOrConnectWithoutUserInput[]
    createMany?: TeamMatchPlayerCreateManyUserInputEnvelope
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
  }

  export type TeamStatisticsCreateNestedManyWithoutTopRunScorerInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopRunScorerInput, TeamStatisticsUncheckedCreateWithoutTopRunScorerInput> | TeamStatisticsCreateWithoutTopRunScorerInput[] | TeamStatisticsUncheckedCreateWithoutTopRunScorerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopRunScorerInput | TeamStatisticsCreateOrConnectWithoutTopRunScorerInput[]
    createMany?: TeamStatisticsCreateManyTopRunScorerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopWicketTakerInput, TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput> | TeamStatisticsCreateWithoutTopWicketTakerInput[] | TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput | TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput[]
    createMany?: TeamStatisticsCreateManyTopWicketTakerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput> | TeamStatisticsCreateWithoutBestStrikeRatePlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput | TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput[]
    createMany?: TeamStatisticsCreateManyBestStrikeRatePlayerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput> | TeamStatisticsCreateWithoutBestEconomyPlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput | TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput[]
    createMany?: TeamStatisticsCreateManyBestEconomyPlayerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput = {
    create?: XOR<TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput> | TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput[] | TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput | TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput[]
    createMany?: TeamStatisticsCreateManyMostManOfTheMatchPlayerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type LocalMatchCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LocalMatchCreateWithoutCreatorInput, LocalMatchUncheckedCreateWithoutCreatorInput> | LocalMatchCreateWithoutCreatorInput[] | LocalMatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutCreatorInput | LocalMatchCreateOrConnectWithoutCreatorInput[]
    createMany?: LocalMatchCreateManyCreatorInputEnvelope
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
  }

  export type MatchSpectatorCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchSpectatorCreateWithoutUserInput, MatchSpectatorUncheckedCreateWithoutUserInput> | MatchSpectatorCreateWithoutUserInput[] | MatchSpectatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutUserInput | MatchSpectatorCreateOrConnectWithoutUserInput[]
    createMany?: MatchSpectatorCreateManyUserInputEnvelope
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
  }

  export type MatchSpectatorCreateNestedManyWithoutAddedByUserInput = {
    create?: XOR<MatchSpectatorCreateWithoutAddedByUserInput, MatchSpectatorUncheckedCreateWithoutAddedByUserInput> | MatchSpectatorCreateWithoutAddedByUserInput[] | MatchSpectatorUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutAddedByUserInput | MatchSpectatorCreateOrConnectWithoutAddedByUserInput[]
    createMany?: MatchSpectatorCreateManyAddedByUserInputEnvelope
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
  }

  export type MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput = {
    create?: XOR<MatchSummaryCreateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput> | MatchSummaryCreateWithoutManOfTheMatchUserInput[] | MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput | MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput[]
    createMany?: MatchSummaryCreateManyManOfTheMatchUserInputEnvelope
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
  }

  export type PlayerMatchHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutUserInput, PlayerMatchHistoryUncheckedCreateWithoutUserInput> | PlayerMatchHistoryCreateWithoutUserInput[] | PlayerMatchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutUserInput | PlayerMatchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PlayerMatchHistoryCreateManyUserInputEnvelope
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
  }

  export type FixtureCreateNestedManyWithoutUserInput = {
    create?: XOR<FixtureCreateWithoutUserInput, FixtureUncheckedCreateWithoutUserInput> | FixtureCreateWithoutUserInput[] | FixtureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixtureCreateOrConnectWithoutUserInput | FixtureCreateOrConnectWithoutUserInput[]
    createMany?: FixtureCreateManyUserInputEnvelope
    connect?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
  }

  export type CareerStatsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<CareerStatsCreateWithoutUserInput, CareerStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CareerStatsCreateOrConnectWithoutUserInput
    connect?: CareerStatsWhereUniqueInput
  }

  export type TeamUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutCaptainInput = {
    create?: XOR<TeamCreateWithoutCaptainInput, TeamUncheckedCreateWithoutCaptainInput> | TeamCreateWithoutCaptainInput[] | TeamUncheckedCreateWithoutCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCaptainInput | TeamCreateOrConnectWithoutCaptainInput[]
    createMany?: TeamCreateManyCaptainInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutViceCaptainInput = {
    create?: XOR<TeamCreateWithoutViceCaptainInput, TeamUncheckedCreateWithoutViceCaptainInput> | TeamCreateWithoutViceCaptainInput[] | TeamUncheckedCreateWithoutViceCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutViceCaptainInput | TeamCreateOrConnectWithoutViceCaptainInput[]
    createMany?: TeamCreateManyViceCaptainInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamInvitationUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<TeamInvitationCreateWithoutInviterInput, TeamInvitationUncheckedCreateWithoutInviterInput> | TeamInvitationCreateWithoutInviterInput[] | TeamInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInviterInput | TeamInvitationCreateOrConnectWithoutInviterInput[]
    createMany?: TeamInvitationCreateManyInviterInputEnvelope
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
  }

  export type TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput = {
    create?: XOR<TeamInvitationCreateWithoutInvitedInput, TeamInvitationUncheckedCreateWithoutInvitedInput> | TeamInvitationCreateWithoutInvitedInput[] | TeamInvitationUncheckedCreateWithoutInvitedInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInvitedInput | TeamInvitationCreateOrConnectWithoutInvitedInput[]
    createMany?: TeamInvitationCreateManyInvitedInputEnvelope
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
  }

  export type GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<GuestPlayerCreateWithoutAddedByInput, GuestPlayerUncheckedCreateWithoutAddedByInput> | GuestPlayerCreateWithoutAddedByInput[] | GuestPlayerUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutAddedByInput | GuestPlayerCreateOrConnectWithoutAddedByInput[]
    createMany?: GuestPlayerCreateManyAddedByInputEnvelope
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
  }

  export type GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput = {
    create?: XOR<GuestPlayerCreateWithoutLinkedUserInput, GuestPlayerUncheckedCreateWithoutLinkedUserInput> | GuestPlayerCreateWithoutLinkedUserInput[] | GuestPlayerUncheckedCreateWithoutLinkedUserInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutLinkedUserInput | GuestPlayerCreateOrConnectWithoutLinkedUserInput[]
    createMany?: GuestPlayerCreateManyLinkedUserInputEnvelope
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchCreateWithoutUserInput, MatchUncheckedCreateWithoutUserInput> | MatchCreateWithoutUserInput[] | MatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserInput | MatchCreateOrConnectWithoutUserInput[]
    createMany?: MatchCreateManyUserInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutUserInput, TeamMatchPlayerUncheckedCreateWithoutUserInput> | TeamMatchPlayerCreateWithoutUserInput[] | TeamMatchPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutUserInput | TeamMatchPlayerCreateOrConnectWithoutUserInput[]
    createMany?: TeamMatchPlayerCreateManyUserInputEnvelope
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
  }

  export type TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopRunScorerInput, TeamStatisticsUncheckedCreateWithoutTopRunScorerInput> | TeamStatisticsCreateWithoutTopRunScorerInput[] | TeamStatisticsUncheckedCreateWithoutTopRunScorerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopRunScorerInput | TeamStatisticsCreateOrConnectWithoutTopRunScorerInput[]
    createMany?: TeamStatisticsCreateManyTopRunScorerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopWicketTakerInput, TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput> | TeamStatisticsCreateWithoutTopWicketTakerInput[] | TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput | TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput[]
    createMany?: TeamStatisticsCreateManyTopWicketTakerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput> | TeamStatisticsCreateWithoutBestStrikeRatePlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput | TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput[]
    createMany?: TeamStatisticsCreateManyBestStrikeRatePlayerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput> | TeamStatisticsCreateWithoutBestEconomyPlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput | TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput[]
    createMany?: TeamStatisticsCreateManyBestEconomyPlayerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput = {
    create?: XOR<TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput> | TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput[] | TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput | TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput[]
    createMany?: TeamStatisticsCreateManyMostManOfTheMatchPlayerInputEnvelope
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
  }

  export type LocalMatchUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LocalMatchCreateWithoutCreatorInput, LocalMatchUncheckedCreateWithoutCreatorInput> | LocalMatchCreateWithoutCreatorInput[] | LocalMatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutCreatorInput | LocalMatchCreateOrConnectWithoutCreatorInput[]
    createMany?: LocalMatchCreateManyCreatorInputEnvelope
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
  }

  export type MatchSpectatorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MatchSpectatorCreateWithoutUserInput, MatchSpectatorUncheckedCreateWithoutUserInput> | MatchSpectatorCreateWithoutUserInput[] | MatchSpectatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutUserInput | MatchSpectatorCreateOrConnectWithoutUserInput[]
    createMany?: MatchSpectatorCreateManyUserInputEnvelope
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
  }

  export type MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput = {
    create?: XOR<MatchSpectatorCreateWithoutAddedByUserInput, MatchSpectatorUncheckedCreateWithoutAddedByUserInput> | MatchSpectatorCreateWithoutAddedByUserInput[] | MatchSpectatorUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutAddedByUserInput | MatchSpectatorCreateOrConnectWithoutAddedByUserInput[]
    createMany?: MatchSpectatorCreateManyAddedByUserInputEnvelope
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
  }

  export type MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput = {
    create?: XOR<MatchSummaryCreateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput> | MatchSummaryCreateWithoutManOfTheMatchUserInput[] | MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput | MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput[]
    createMany?: MatchSummaryCreateManyManOfTheMatchUserInputEnvelope
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
  }

  export type PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutUserInput, PlayerMatchHistoryUncheckedCreateWithoutUserInput> | PlayerMatchHistoryCreateWithoutUserInput[] | PlayerMatchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutUserInput | PlayerMatchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PlayerMatchHistoryCreateManyUserInputEnvelope
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
  }

  export type FixtureUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FixtureCreateWithoutUserInput, FixtureUncheckedCreateWithoutUserInput> | FixtureCreateWithoutUserInput[] | FixtureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixtureCreateOrConnectWithoutUserInput | FixtureCreateOrConnectWithoutUserInput[]
    createMany?: FixtureCreateManyUserInputEnvelope
    connect?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
    unset?: boolean
  }

  export type NullableEnumBattingHandFieldUpdateOperationsInput = {
    set?: $Enums.BattingHand | null
    unset?: boolean
  }

  export type NullableEnumBowlingStyleFieldUpdateOperationsInput = {
    set?: $Enums.BowlingStyle | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CareerStatsUpdateOneWithoutUserNestedInput = {
    create?: XOR<CareerStatsCreateWithoutUserInput, CareerStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CareerStatsCreateOrConnectWithoutUserInput
    upsert?: CareerStatsUpsertWithoutUserInput
    disconnect?: CareerStatsWhereInput | boolean
    delete?: CareerStatsWhereInput | boolean
    connect?: CareerStatsWhereUniqueInput
    update?: XOR<XOR<CareerStatsUpdateToOneWithWhereWithoutUserInput, CareerStatsUpdateWithoutUserInput>, CareerStatsUncheckedUpdateWithoutUserInput>
  }

  export type TeamUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatedByInput | TeamUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatedByInput | TeamUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatedByInput | TeamUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutCaptainNestedInput = {
    create?: XOR<TeamCreateWithoutCaptainInput, TeamUncheckedCreateWithoutCaptainInput> | TeamCreateWithoutCaptainInput[] | TeamUncheckedCreateWithoutCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCaptainInput | TeamCreateOrConnectWithoutCaptainInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCaptainInput | TeamUpsertWithWhereUniqueWithoutCaptainInput[]
    createMany?: TeamCreateManyCaptainInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCaptainInput | TeamUpdateWithWhereUniqueWithoutCaptainInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCaptainInput | TeamUpdateManyWithWhereWithoutCaptainInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutViceCaptainNestedInput = {
    create?: XOR<TeamCreateWithoutViceCaptainInput, TeamUncheckedCreateWithoutViceCaptainInput> | TeamCreateWithoutViceCaptainInput[] | TeamUncheckedCreateWithoutViceCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutViceCaptainInput | TeamCreateOrConnectWithoutViceCaptainInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutViceCaptainInput | TeamUpsertWithWhereUniqueWithoutViceCaptainInput[]
    createMany?: TeamCreateManyViceCaptainInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutViceCaptainInput | TeamUpdateWithWhereUniqueWithoutViceCaptainInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutViceCaptainInput | TeamUpdateManyWithWhereWithoutViceCaptainInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamInvitationUpdateManyWithoutInviterNestedInput = {
    create?: XOR<TeamInvitationCreateWithoutInviterInput, TeamInvitationUncheckedCreateWithoutInviterInput> | TeamInvitationCreateWithoutInviterInput[] | TeamInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInviterInput | TeamInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: TeamInvitationUpsertWithWhereUniqueWithoutInviterInput | TeamInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: TeamInvitationCreateManyInviterInputEnvelope
    set?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    disconnect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    delete?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    update?: TeamInvitationUpdateWithWhereUniqueWithoutInviterInput | TeamInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: TeamInvitationUpdateManyWithWhereWithoutInviterInput | TeamInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
  }

  export type TeamInvitationUpdateManyWithoutInvitedNestedInput = {
    create?: XOR<TeamInvitationCreateWithoutInvitedInput, TeamInvitationUncheckedCreateWithoutInvitedInput> | TeamInvitationCreateWithoutInvitedInput[] | TeamInvitationUncheckedCreateWithoutInvitedInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInvitedInput | TeamInvitationCreateOrConnectWithoutInvitedInput[]
    upsert?: TeamInvitationUpsertWithWhereUniqueWithoutInvitedInput | TeamInvitationUpsertWithWhereUniqueWithoutInvitedInput[]
    createMany?: TeamInvitationCreateManyInvitedInputEnvelope
    set?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    disconnect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    delete?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    update?: TeamInvitationUpdateWithWhereUniqueWithoutInvitedInput | TeamInvitationUpdateWithWhereUniqueWithoutInvitedInput[]
    updateMany?: TeamInvitationUpdateManyWithWhereWithoutInvitedInput | TeamInvitationUpdateManyWithWhereWithoutInvitedInput[]
    deleteMany?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
  }

  export type GuestPlayerUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<GuestPlayerCreateWithoutAddedByInput, GuestPlayerUncheckedCreateWithoutAddedByInput> | GuestPlayerCreateWithoutAddedByInput[] | GuestPlayerUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutAddedByInput | GuestPlayerCreateOrConnectWithoutAddedByInput[]
    upsert?: GuestPlayerUpsertWithWhereUniqueWithoutAddedByInput | GuestPlayerUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: GuestPlayerCreateManyAddedByInputEnvelope
    set?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    disconnect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    delete?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    update?: GuestPlayerUpdateWithWhereUniqueWithoutAddedByInput | GuestPlayerUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: GuestPlayerUpdateManyWithWhereWithoutAddedByInput | GuestPlayerUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
  }

  export type GuestPlayerUpdateManyWithoutLinkedUserNestedInput = {
    create?: XOR<GuestPlayerCreateWithoutLinkedUserInput, GuestPlayerUncheckedCreateWithoutLinkedUserInput> | GuestPlayerCreateWithoutLinkedUserInput[] | GuestPlayerUncheckedCreateWithoutLinkedUserInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutLinkedUserInput | GuestPlayerCreateOrConnectWithoutLinkedUserInput[]
    upsert?: GuestPlayerUpsertWithWhereUniqueWithoutLinkedUserInput | GuestPlayerUpsertWithWhereUniqueWithoutLinkedUserInput[]
    createMany?: GuestPlayerCreateManyLinkedUserInputEnvelope
    set?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    disconnect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    delete?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    update?: GuestPlayerUpdateWithWhereUniqueWithoutLinkedUserInput | GuestPlayerUpdateWithWhereUniqueWithoutLinkedUserInput[]
    updateMany?: GuestPlayerUpdateManyWithWhereWithoutLinkedUserInput | GuestPlayerUpdateManyWithWhereWithoutLinkedUserInput[]
    deleteMany?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchCreateWithoutUserInput, MatchUncheckedCreateWithoutUserInput> | MatchCreateWithoutUserInput[] | MatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserInput | MatchCreateOrConnectWithoutUserInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutUserInput | MatchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchCreateManyUserInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutUserInput | MatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutUserInput | MatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type TeamMatchPlayerUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutUserInput, TeamMatchPlayerUncheckedCreateWithoutUserInput> | TeamMatchPlayerCreateWithoutUserInput[] | TeamMatchPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutUserInput | TeamMatchPlayerCreateOrConnectWithoutUserInput[]
    upsert?: TeamMatchPlayerUpsertWithWhereUniqueWithoutUserInput | TeamMatchPlayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMatchPlayerCreateManyUserInputEnvelope
    set?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    disconnect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    delete?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    update?: TeamMatchPlayerUpdateWithWhereUniqueWithoutUserInput | TeamMatchPlayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMatchPlayerUpdateManyWithWhereWithoutUserInput | TeamMatchPlayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
  }

  export type TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopRunScorerInput, TeamStatisticsUncheckedCreateWithoutTopRunScorerInput> | TeamStatisticsCreateWithoutTopRunScorerInput[] | TeamStatisticsUncheckedCreateWithoutTopRunScorerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopRunScorerInput | TeamStatisticsCreateOrConnectWithoutTopRunScorerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutTopRunScorerInput | TeamStatisticsUpsertWithWhereUniqueWithoutTopRunScorerInput[]
    createMany?: TeamStatisticsCreateManyTopRunScorerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutTopRunScorerInput | TeamStatisticsUpdateWithWhereUniqueWithoutTopRunScorerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutTopRunScorerInput | TeamStatisticsUpdateManyWithWhereWithoutTopRunScorerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopWicketTakerInput, TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput> | TeamStatisticsCreateWithoutTopWicketTakerInput[] | TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput | TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutTopWicketTakerInput | TeamStatisticsUpsertWithWhereUniqueWithoutTopWicketTakerInput[]
    createMany?: TeamStatisticsCreateManyTopWicketTakerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutTopWicketTakerInput | TeamStatisticsUpdateWithWhereUniqueWithoutTopWicketTakerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutTopWicketTakerInput | TeamStatisticsUpdateManyWithWhereWithoutTopWicketTakerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput> | TeamStatisticsCreateWithoutBestStrikeRatePlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput | TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutBestStrikeRatePlayerInput | TeamStatisticsUpsertWithWhereUniqueWithoutBestStrikeRatePlayerInput[]
    createMany?: TeamStatisticsCreateManyBestStrikeRatePlayerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutBestStrikeRatePlayerInput | TeamStatisticsUpdateWithWhereUniqueWithoutBestStrikeRatePlayerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutBestStrikeRatePlayerInput | TeamStatisticsUpdateManyWithWhereWithoutBestStrikeRatePlayerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput> | TeamStatisticsCreateWithoutBestEconomyPlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput | TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutBestEconomyPlayerInput | TeamStatisticsUpsertWithWhereUniqueWithoutBestEconomyPlayerInput[]
    createMany?: TeamStatisticsCreateManyBestEconomyPlayerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutBestEconomyPlayerInput | TeamStatisticsUpdateWithWhereUniqueWithoutBestEconomyPlayerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutBestEconomyPlayerInput | TeamStatisticsUpdateManyWithWhereWithoutBestEconomyPlayerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput> | TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput[] | TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput | TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutMostManOfTheMatchPlayerInput | TeamStatisticsUpsertWithWhereUniqueWithoutMostManOfTheMatchPlayerInput[]
    createMany?: TeamStatisticsCreateManyMostManOfTheMatchPlayerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutMostManOfTheMatchPlayerInput | TeamStatisticsUpdateWithWhereUniqueWithoutMostManOfTheMatchPlayerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutMostManOfTheMatchPlayerInput | TeamStatisticsUpdateManyWithWhereWithoutMostManOfTheMatchPlayerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type LocalMatchUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LocalMatchCreateWithoutCreatorInput, LocalMatchUncheckedCreateWithoutCreatorInput> | LocalMatchCreateWithoutCreatorInput[] | LocalMatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutCreatorInput | LocalMatchCreateOrConnectWithoutCreatorInput[]
    upsert?: LocalMatchUpsertWithWhereUniqueWithoutCreatorInput | LocalMatchUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LocalMatchCreateManyCreatorInputEnvelope
    set?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    disconnect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    delete?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    update?: LocalMatchUpdateWithWhereUniqueWithoutCreatorInput | LocalMatchUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LocalMatchUpdateManyWithWhereWithoutCreatorInput | LocalMatchUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
  }

  export type MatchSpectatorUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchSpectatorCreateWithoutUserInput, MatchSpectatorUncheckedCreateWithoutUserInput> | MatchSpectatorCreateWithoutUserInput[] | MatchSpectatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutUserInput | MatchSpectatorCreateOrConnectWithoutUserInput[]
    upsert?: MatchSpectatorUpsertWithWhereUniqueWithoutUserInput | MatchSpectatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchSpectatorCreateManyUserInputEnvelope
    set?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    disconnect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    delete?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    update?: MatchSpectatorUpdateWithWhereUniqueWithoutUserInput | MatchSpectatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchSpectatorUpdateManyWithWhereWithoutUserInput | MatchSpectatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
  }

  export type MatchSpectatorUpdateManyWithoutAddedByUserNestedInput = {
    create?: XOR<MatchSpectatorCreateWithoutAddedByUserInput, MatchSpectatorUncheckedCreateWithoutAddedByUserInput> | MatchSpectatorCreateWithoutAddedByUserInput[] | MatchSpectatorUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutAddedByUserInput | MatchSpectatorCreateOrConnectWithoutAddedByUserInput[]
    upsert?: MatchSpectatorUpsertWithWhereUniqueWithoutAddedByUserInput | MatchSpectatorUpsertWithWhereUniqueWithoutAddedByUserInput[]
    createMany?: MatchSpectatorCreateManyAddedByUserInputEnvelope
    set?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    disconnect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    delete?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    update?: MatchSpectatorUpdateWithWhereUniqueWithoutAddedByUserInput | MatchSpectatorUpdateWithWhereUniqueWithoutAddedByUserInput[]
    updateMany?: MatchSpectatorUpdateManyWithWhereWithoutAddedByUserInput | MatchSpectatorUpdateManyWithWhereWithoutAddedByUserInput[]
    deleteMany?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
  }

  export type MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput = {
    create?: XOR<MatchSummaryCreateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput> | MatchSummaryCreateWithoutManOfTheMatchUserInput[] | MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput | MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput[]
    upsert?: MatchSummaryUpsertWithWhereUniqueWithoutManOfTheMatchUserInput | MatchSummaryUpsertWithWhereUniqueWithoutManOfTheMatchUserInput[]
    createMany?: MatchSummaryCreateManyManOfTheMatchUserInputEnvelope
    set?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    disconnect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    delete?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    update?: MatchSummaryUpdateWithWhereUniqueWithoutManOfTheMatchUserInput | MatchSummaryUpdateWithWhereUniqueWithoutManOfTheMatchUserInput[]
    updateMany?: MatchSummaryUpdateManyWithWhereWithoutManOfTheMatchUserInput | MatchSummaryUpdateManyWithWhereWithoutManOfTheMatchUserInput[]
    deleteMany?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
  }

  export type PlayerMatchHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutUserInput, PlayerMatchHistoryUncheckedCreateWithoutUserInput> | PlayerMatchHistoryCreateWithoutUserInput[] | PlayerMatchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutUserInput | PlayerMatchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PlayerMatchHistoryUpsertWithWhereUniqueWithoutUserInput | PlayerMatchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerMatchHistoryCreateManyUserInputEnvelope
    set?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    disconnect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    delete?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    update?: PlayerMatchHistoryUpdateWithWhereUniqueWithoutUserInput | PlayerMatchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerMatchHistoryUpdateManyWithWhereWithoutUserInput | PlayerMatchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
  }

  export type FixtureUpdateManyWithoutUserNestedInput = {
    create?: XOR<FixtureCreateWithoutUserInput, FixtureUncheckedCreateWithoutUserInput> | FixtureCreateWithoutUserInput[] | FixtureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixtureCreateOrConnectWithoutUserInput | FixtureCreateOrConnectWithoutUserInput[]
    upsert?: FixtureUpsertWithWhereUniqueWithoutUserInput | FixtureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FixtureCreateManyUserInputEnvelope
    set?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    disconnect?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    delete?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    connect?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    update?: FixtureUpdateWithWhereUniqueWithoutUserInput | FixtureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FixtureUpdateManyWithWhereWithoutUserInput | FixtureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FixtureScalarWhereInput | FixtureScalarWhereInput[]
  }

  export type CareerStatsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<CareerStatsCreateWithoutUserInput, CareerStatsUncheckedCreateWithoutUserInput>
    connectOrCreate?: CareerStatsCreateOrConnectWithoutUserInput
    upsert?: CareerStatsUpsertWithoutUserInput
    disconnect?: CareerStatsWhereInput | boolean
    delete?: CareerStatsWhereInput | boolean
    connect?: CareerStatsWhereUniqueInput
    update?: XOR<XOR<CareerStatsUpdateToOneWithWhereWithoutUserInput, CareerStatsUpdateWithoutUserInput>, CareerStatsUncheckedUpdateWithoutUserInput>
  }

  export type TeamUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatedByInput | TeamUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatedByInput | TeamUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatedByInput | TeamUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutCaptainNestedInput = {
    create?: XOR<TeamCreateWithoutCaptainInput, TeamUncheckedCreateWithoutCaptainInput> | TeamCreateWithoutCaptainInput[] | TeamUncheckedCreateWithoutCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCaptainInput | TeamCreateOrConnectWithoutCaptainInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCaptainInput | TeamUpsertWithWhereUniqueWithoutCaptainInput[]
    createMany?: TeamCreateManyCaptainInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCaptainInput | TeamUpdateWithWhereUniqueWithoutCaptainInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCaptainInput | TeamUpdateManyWithWhereWithoutCaptainInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutViceCaptainNestedInput = {
    create?: XOR<TeamCreateWithoutViceCaptainInput, TeamUncheckedCreateWithoutViceCaptainInput> | TeamCreateWithoutViceCaptainInput[] | TeamUncheckedCreateWithoutViceCaptainInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutViceCaptainInput | TeamCreateOrConnectWithoutViceCaptainInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutViceCaptainInput | TeamUpsertWithWhereUniqueWithoutViceCaptainInput[]
    createMany?: TeamCreateManyViceCaptainInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutViceCaptainInput | TeamUpdateWithWhereUniqueWithoutViceCaptainInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutViceCaptainInput | TeamUpdateManyWithWhereWithoutViceCaptainInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<TeamInvitationCreateWithoutInviterInput, TeamInvitationUncheckedCreateWithoutInviterInput> | TeamInvitationCreateWithoutInviterInput[] | TeamInvitationUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInviterInput | TeamInvitationCreateOrConnectWithoutInviterInput[]
    upsert?: TeamInvitationUpsertWithWhereUniqueWithoutInviterInput | TeamInvitationUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: TeamInvitationCreateManyInviterInputEnvelope
    set?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    disconnect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    delete?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    update?: TeamInvitationUpdateWithWhereUniqueWithoutInviterInput | TeamInvitationUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: TeamInvitationUpdateManyWithWhereWithoutInviterInput | TeamInvitationUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
  }

  export type TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput = {
    create?: XOR<TeamInvitationCreateWithoutInvitedInput, TeamInvitationUncheckedCreateWithoutInvitedInput> | TeamInvitationCreateWithoutInvitedInput[] | TeamInvitationUncheckedCreateWithoutInvitedInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutInvitedInput | TeamInvitationCreateOrConnectWithoutInvitedInput[]
    upsert?: TeamInvitationUpsertWithWhereUniqueWithoutInvitedInput | TeamInvitationUpsertWithWhereUniqueWithoutInvitedInput[]
    createMany?: TeamInvitationCreateManyInvitedInputEnvelope
    set?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    disconnect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    delete?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    update?: TeamInvitationUpdateWithWhereUniqueWithoutInvitedInput | TeamInvitationUpdateWithWhereUniqueWithoutInvitedInput[]
    updateMany?: TeamInvitationUpdateManyWithWhereWithoutInvitedInput | TeamInvitationUpdateManyWithWhereWithoutInvitedInput[]
    deleteMany?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
  }

  export type GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<GuestPlayerCreateWithoutAddedByInput, GuestPlayerUncheckedCreateWithoutAddedByInput> | GuestPlayerCreateWithoutAddedByInput[] | GuestPlayerUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutAddedByInput | GuestPlayerCreateOrConnectWithoutAddedByInput[]
    upsert?: GuestPlayerUpsertWithWhereUniqueWithoutAddedByInput | GuestPlayerUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: GuestPlayerCreateManyAddedByInputEnvelope
    set?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    disconnect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    delete?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    update?: GuestPlayerUpdateWithWhereUniqueWithoutAddedByInput | GuestPlayerUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: GuestPlayerUpdateManyWithWhereWithoutAddedByInput | GuestPlayerUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
  }

  export type GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput = {
    create?: XOR<GuestPlayerCreateWithoutLinkedUserInput, GuestPlayerUncheckedCreateWithoutLinkedUserInput> | GuestPlayerCreateWithoutLinkedUserInput[] | GuestPlayerUncheckedCreateWithoutLinkedUserInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutLinkedUserInput | GuestPlayerCreateOrConnectWithoutLinkedUserInput[]
    upsert?: GuestPlayerUpsertWithWhereUniqueWithoutLinkedUserInput | GuestPlayerUpsertWithWhereUniqueWithoutLinkedUserInput[]
    createMany?: GuestPlayerCreateManyLinkedUserInputEnvelope
    set?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    disconnect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    delete?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    update?: GuestPlayerUpdateWithWhereUniqueWithoutLinkedUserInput | GuestPlayerUpdateWithWhereUniqueWithoutLinkedUserInput[]
    updateMany?: GuestPlayerUpdateManyWithWhereWithoutLinkedUserInput | GuestPlayerUpdateManyWithWhereWithoutLinkedUserInput[]
    deleteMany?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchCreateWithoutUserInput, MatchUncheckedCreateWithoutUserInput> | MatchCreateWithoutUserInput[] | MatchUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutUserInput | MatchCreateOrConnectWithoutUserInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutUserInput | MatchUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchCreateManyUserInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutUserInput | MatchUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutUserInput | MatchUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutUserInput, TeamMatchPlayerUncheckedCreateWithoutUserInput> | TeamMatchPlayerCreateWithoutUserInput[] | TeamMatchPlayerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutUserInput | TeamMatchPlayerCreateOrConnectWithoutUserInput[]
    upsert?: TeamMatchPlayerUpsertWithWhereUniqueWithoutUserInput | TeamMatchPlayerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMatchPlayerCreateManyUserInputEnvelope
    set?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    disconnect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    delete?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    update?: TeamMatchPlayerUpdateWithWhereUniqueWithoutUserInput | TeamMatchPlayerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMatchPlayerUpdateManyWithWhereWithoutUserInput | TeamMatchPlayerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopRunScorerInput, TeamStatisticsUncheckedCreateWithoutTopRunScorerInput> | TeamStatisticsCreateWithoutTopRunScorerInput[] | TeamStatisticsUncheckedCreateWithoutTopRunScorerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopRunScorerInput | TeamStatisticsCreateOrConnectWithoutTopRunScorerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutTopRunScorerInput | TeamStatisticsUpsertWithWhereUniqueWithoutTopRunScorerInput[]
    createMany?: TeamStatisticsCreateManyTopRunScorerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutTopRunScorerInput | TeamStatisticsUpdateWithWhereUniqueWithoutTopRunScorerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutTopRunScorerInput | TeamStatisticsUpdateManyWithWhereWithoutTopRunScorerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutTopWicketTakerInput, TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput> | TeamStatisticsCreateWithoutTopWicketTakerInput[] | TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput | TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutTopWicketTakerInput | TeamStatisticsUpsertWithWhereUniqueWithoutTopWicketTakerInput[]
    createMany?: TeamStatisticsCreateManyTopWicketTakerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutTopWicketTakerInput | TeamStatisticsUpdateWithWhereUniqueWithoutTopWicketTakerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutTopWicketTakerInput | TeamStatisticsUpdateManyWithWhereWithoutTopWicketTakerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput> | TeamStatisticsCreateWithoutBestStrikeRatePlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput | TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutBestStrikeRatePlayerInput | TeamStatisticsUpsertWithWhereUniqueWithoutBestStrikeRatePlayerInput[]
    createMany?: TeamStatisticsCreateManyBestStrikeRatePlayerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutBestStrikeRatePlayerInput | TeamStatisticsUpdateWithWhereUniqueWithoutBestStrikeRatePlayerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutBestStrikeRatePlayerInput | TeamStatisticsUpdateManyWithWhereWithoutBestStrikeRatePlayerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput> | TeamStatisticsCreateWithoutBestEconomyPlayerInput[] | TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput | TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutBestEconomyPlayerInput | TeamStatisticsUpsertWithWhereUniqueWithoutBestEconomyPlayerInput[]
    createMany?: TeamStatisticsCreateManyBestEconomyPlayerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutBestEconomyPlayerInput | TeamStatisticsUpdateWithWhereUniqueWithoutBestEconomyPlayerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutBestEconomyPlayerInput | TeamStatisticsUpdateManyWithWhereWithoutBestEconomyPlayerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput> | TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput[] | TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput[]
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput | TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput[]
    upsert?: TeamStatisticsUpsertWithWhereUniqueWithoutMostManOfTheMatchPlayerInput | TeamStatisticsUpsertWithWhereUniqueWithoutMostManOfTheMatchPlayerInput[]
    createMany?: TeamStatisticsCreateManyMostManOfTheMatchPlayerInputEnvelope
    set?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    disconnect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    delete?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    connect?: TeamStatisticsWhereUniqueInput | TeamStatisticsWhereUniqueInput[]
    update?: TeamStatisticsUpdateWithWhereUniqueWithoutMostManOfTheMatchPlayerInput | TeamStatisticsUpdateWithWhereUniqueWithoutMostManOfTheMatchPlayerInput[]
    updateMany?: TeamStatisticsUpdateManyWithWhereWithoutMostManOfTheMatchPlayerInput | TeamStatisticsUpdateManyWithWhereWithoutMostManOfTheMatchPlayerInput[]
    deleteMany?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
  }

  export type LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LocalMatchCreateWithoutCreatorInput, LocalMatchUncheckedCreateWithoutCreatorInput> | LocalMatchCreateWithoutCreatorInput[] | LocalMatchUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutCreatorInput | LocalMatchCreateOrConnectWithoutCreatorInput[]
    upsert?: LocalMatchUpsertWithWhereUniqueWithoutCreatorInput | LocalMatchUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LocalMatchCreateManyCreatorInputEnvelope
    set?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    disconnect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    delete?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    update?: LocalMatchUpdateWithWhereUniqueWithoutCreatorInput | LocalMatchUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LocalMatchUpdateManyWithWhereWithoutCreatorInput | LocalMatchUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
  }

  export type MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MatchSpectatorCreateWithoutUserInput, MatchSpectatorUncheckedCreateWithoutUserInput> | MatchSpectatorCreateWithoutUserInput[] | MatchSpectatorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutUserInput | MatchSpectatorCreateOrConnectWithoutUserInput[]
    upsert?: MatchSpectatorUpsertWithWhereUniqueWithoutUserInput | MatchSpectatorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MatchSpectatorCreateManyUserInputEnvelope
    set?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    disconnect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    delete?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    update?: MatchSpectatorUpdateWithWhereUniqueWithoutUserInput | MatchSpectatorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MatchSpectatorUpdateManyWithWhereWithoutUserInput | MatchSpectatorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
  }

  export type MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput = {
    create?: XOR<MatchSpectatorCreateWithoutAddedByUserInput, MatchSpectatorUncheckedCreateWithoutAddedByUserInput> | MatchSpectatorCreateWithoutAddedByUserInput[] | MatchSpectatorUncheckedCreateWithoutAddedByUserInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutAddedByUserInput | MatchSpectatorCreateOrConnectWithoutAddedByUserInput[]
    upsert?: MatchSpectatorUpsertWithWhereUniqueWithoutAddedByUserInput | MatchSpectatorUpsertWithWhereUniqueWithoutAddedByUserInput[]
    createMany?: MatchSpectatorCreateManyAddedByUserInputEnvelope
    set?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    disconnect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    delete?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    update?: MatchSpectatorUpdateWithWhereUniqueWithoutAddedByUserInput | MatchSpectatorUpdateWithWhereUniqueWithoutAddedByUserInput[]
    updateMany?: MatchSpectatorUpdateManyWithWhereWithoutAddedByUserInput | MatchSpectatorUpdateManyWithWhereWithoutAddedByUserInput[]
    deleteMany?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
  }

  export type MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput = {
    create?: XOR<MatchSummaryCreateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput> | MatchSummaryCreateWithoutManOfTheMatchUserInput[] | MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput | MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput[]
    upsert?: MatchSummaryUpsertWithWhereUniqueWithoutManOfTheMatchUserInput | MatchSummaryUpsertWithWhereUniqueWithoutManOfTheMatchUserInput[]
    createMany?: MatchSummaryCreateManyManOfTheMatchUserInputEnvelope
    set?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    disconnect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    delete?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    update?: MatchSummaryUpdateWithWhereUniqueWithoutManOfTheMatchUserInput | MatchSummaryUpdateWithWhereUniqueWithoutManOfTheMatchUserInput[]
    updateMany?: MatchSummaryUpdateManyWithWhereWithoutManOfTheMatchUserInput | MatchSummaryUpdateManyWithWhereWithoutManOfTheMatchUserInput[]
    deleteMany?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
  }

  export type PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutUserInput, PlayerMatchHistoryUncheckedCreateWithoutUserInput> | PlayerMatchHistoryCreateWithoutUserInput[] | PlayerMatchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutUserInput | PlayerMatchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PlayerMatchHistoryUpsertWithWhereUniqueWithoutUserInput | PlayerMatchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlayerMatchHistoryCreateManyUserInputEnvelope
    set?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    disconnect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    delete?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    update?: PlayerMatchHistoryUpdateWithWhereUniqueWithoutUserInput | PlayerMatchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlayerMatchHistoryUpdateManyWithWhereWithoutUserInput | PlayerMatchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
  }

  export type FixtureUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FixtureCreateWithoutUserInput, FixtureUncheckedCreateWithoutUserInput> | FixtureCreateWithoutUserInput[] | FixtureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FixtureCreateOrConnectWithoutUserInput | FixtureCreateOrConnectWithoutUserInput[]
    upsert?: FixtureUpsertWithWhereUniqueWithoutUserInput | FixtureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FixtureCreateManyUserInputEnvelope
    set?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    disconnect?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    delete?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    connect?: FixtureWhereUniqueInput | FixtureWhereUniqueInput[]
    update?: FixtureUpdateWithWhereUniqueWithoutUserInput | FixtureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FixtureUpdateManyWithWhereWithoutUserInput | FixtureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FixtureScalarWhereInput | FixtureScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCareerStatsInput = {
    create?: XOR<UserCreateWithoutCareerStatsInput, UserUncheckedCreateWithoutCareerStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCareerStatsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutCareerStatsNestedInput = {
    create?: XOR<UserCreateWithoutCareerStatsInput, UserUncheckedCreateWithoutCareerStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCareerStatsInput
    upsert?: UserUpsertWithoutCareerStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCareerStatsInput, UserUpdateWithoutCareerStatsInput>, UserUncheckedUpdateWithoutCareerStatsInput>
  }

  export type UserCreateNestedOneWithoutCreatedTeamsInput = {
    create?: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCaptainOfTeamsInput = {
    create?: XOR<UserCreateWithoutCaptainOfTeamsInput, UserUncheckedCreateWithoutCaptainOfTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCaptainOfTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutViceCaptainOfTeamsInput = {
    create?: XOR<UserCreateWithoutViceCaptainOfTeamsInput, UserUncheckedCreateWithoutViceCaptainOfTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViceCaptainOfTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type GuestPlayerCreateNestedManyWithoutTeamInput = {
    create?: XOR<GuestPlayerCreateWithoutTeamInput, GuestPlayerUncheckedCreateWithoutTeamInput> | GuestPlayerCreateWithoutTeamInput[] | GuestPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutTeamInput | GuestPlayerCreateOrConnectWithoutTeamInput[]
    createMany?: GuestPlayerCreateManyTeamInputEnvelope
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
  }

  export type TeamInvitationCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamInvitationCreateWithoutTeamInput, TeamInvitationUncheckedCreateWithoutTeamInput> | TeamInvitationCreateWithoutTeamInput[] | TeamInvitationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutTeamInput | TeamInvitationCreateOrConnectWithoutTeamInput[]
    createMany?: TeamInvitationCreateManyTeamInputEnvelope
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
  }

  export type TeamMatchCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<TeamMatchCreateWithoutHomeTeamInput, TeamMatchUncheckedCreateWithoutHomeTeamInput> | TeamMatchCreateWithoutHomeTeamInput[] | TeamMatchUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutHomeTeamInput | TeamMatchCreateOrConnectWithoutHomeTeamInput[]
    createMany?: TeamMatchCreateManyHomeTeamInputEnvelope
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
  }

  export type TeamMatchCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<TeamMatchCreateWithoutAwayTeamInput, TeamMatchUncheckedCreateWithoutAwayTeamInput> | TeamMatchCreateWithoutAwayTeamInput[] | TeamMatchUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutAwayTeamInput | TeamMatchCreateOrConnectWithoutAwayTeamInput[]
    createMany?: TeamMatchCreateManyAwayTeamInputEnvelope
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
  }

  export type TeamStatisticsCreateNestedOneWithoutTeamInput = {
    create?: XOR<TeamStatisticsCreateWithoutTeamInput, TeamStatisticsUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTeamInput
    connect?: TeamStatisticsWhereUniqueInput
  }

  export type TeamMatchPlayerCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamInput, TeamMatchPlayerUncheckedCreateWithoutTeamInput> | TeamMatchPlayerCreateWithoutTeamInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamInput | TeamMatchPlayerCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMatchPlayerCreateManyTeamInputEnvelope
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
  }

  export type LocalMatchCreateNestedManyWithoutMyTeamInput = {
    create?: XOR<LocalMatchCreateWithoutMyTeamInput, LocalMatchUncheckedCreateWithoutMyTeamInput> | LocalMatchCreateWithoutMyTeamInput[] | LocalMatchUncheckedCreateWithoutMyTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutMyTeamInput | LocalMatchCreateOrConnectWithoutMyTeamInput[]
    createMany?: LocalMatchCreateManyMyTeamInputEnvelope
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
  }

  export type LocalMatchCreateNestedManyWithoutOpponentTeamInput = {
    create?: XOR<LocalMatchCreateWithoutOpponentTeamInput, LocalMatchUncheckedCreateWithoutOpponentTeamInput> | LocalMatchCreateWithoutOpponentTeamInput[] | LocalMatchUncheckedCreateWithoutOpponentTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutOpponentTeamInput | LocalMatchCreateOrConnectWithoutOpponentTeamInput[]
    createMany?: LocalMatchCreateManyOpponentTeamInputEnvelope
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
  }

  export type MatchSummaryCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<MatchSummaryCreateWithoutHomeTeamInput, MatchSummaryUncheckedCreateWithoutHomeTeamInput> | MatchSummaryCreateWithoutHomeTeamInput[] | MatchSummaryUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutHomeTeamInput | MatchSummaryCreateOrConnectWithoutHomeTeamInput[]
    createMany?: MatchSummaryCreateManyHomeTeamInputEnvelope
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
  }

  export type MatchSummaryCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<MatchSummaryCreateWithoutAwayTeamInput, MatchSummaryUncheckedCreateWithoutAwayTeamInput> | MatchSummaryCreateWithoutAwayTeamInput[] | MatchSummaryUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutAwayTeamInput | MatchSummaryCreateOrConnectWithoutAwayTeamInput[]
    createMany?: MatchSummaryCreateManyAwayTeamInputEnvelope
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
  }

  export type PlayerMatchHistoryCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutTeamInput, PlayerMatchHistoryUncheckedCreateWithoutTeamInput> | PlayerMatchHistoryCreateWithoutTeamInput[] | PlayerMatchHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutTeamInput | PlayerMatchHistoryCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerMatchHistoryCreateManyTeamInputEnvelope
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type GuestPlayerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<GuestPlayerCreateWithoutTeamInput, GuestPlayerUncheckedCreateWithoutTeamInput> | GuestPlayerCreateWithoutTeamInput[] | GuestPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutTeamInput | GuestPlayerCreateOrConnectWithoutTeamInput[]
    createMany?: GuestPlayerCreateManyTeamInputEnvelope
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
  }

  export type TeamInvitationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamInvitationCreateWithoutTeamInput, TeamInvitationUncheckedCreateWithoutTeamInput> | TeamInvitationCreateWithoutTeamInput[] | TeamInvitationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutTeamInput | TeamInvitationCreateOrConnectWithoutTeamInput[]
    createMany?: TeamInvitationCreateManyTeamInputEnvelope
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
  }

  export type TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<TeamMatchCreateWithoutHomeTeamInput, TeamMatchUncheckedCreateWithoutHomeTeamInput> | TeamMatchCreateWithoutHomeTeamInput[] | TeamMatchUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutHomeTeamInput | TeamMatchCreateOrConnectWithoutHomeTeamInput[]
    createMany?: TeamMatchCreateManyHomeTeamInputEnvelope
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
  }

  export type TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<TeamMatchCreateWithoutAwayTeamInput, TeamMatchUncheckedCreateWithoutAwayTeamInput> | TeamMatchCreateWithoutAwayTeamInput[] | TeamMatchUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutAwayTeamInput | TeamMatchCreateOrConnectWithoutAwayTeamInput[]
    createMany?: TeamMatchCreateManyAwayTeamInputEnvelope
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
  }

  export type TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput = {
    create?: XOR<TeamStatisticsCreateWithoutTeamInput, TeamStatisticsUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTeamInput
    connect?: TeamStatisticsWhereUniqueInput
  }

  export type TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamInput, TeamMatchPlayerUncheckedCreateWithoutTeamInput> | TeamMatchPlayerCreateWithoutTeamInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamInput | TeamMatchPlayerCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMatchPlayerCreateManyTeamInputEnvelope
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
  }

  export type LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput = {
    create?: XOR<LocalMatchCreateWithoutMyTeamInput, LocalMatchUncheckedCreateWithoutMyTeamInput> | LocalMatchCreateWithoutMyTeamInput[] | LocalMatchUncheckedCreateWithoutMyTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutMyTeamInput | LocalMatchCreateOrConnectWithoutMyTeamInput[]
    createMany?: LocalMatchCreateManyMyTeamInputEnvelope
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
  }

  export type LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput = {
    create?: XOR<LocalMatchCreateWithoutOpponentTeamInput, LocalMatchUncheckedCreateWithoutOpponentTeamInput> | LocalMatchCreateWithoutOpponentTeamInput[] | LocalMatchUncheckedCreateWithoutOpponentTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutOpponentTeamInput | LocalMatchCreateOrConnectWithoutOpponentTeamInput[]
    createMany?: LocalMatchCreateManyOpponentTeamInputEnvelope
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
  }

  export type MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput = {
    create?: XOR<MatchSummaryCreateWithoutHomeTeamInput, MatchSummaryUncheckedCreateWithoutHomeTeamInput> | MatchSummaryCreateWithoutHomeTeamInput[] | MatchSummaryUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutHomeTeamInput | MatchSummaryCreateOrConnectWithoutHomeTeamInput[]
    createMany?: MatchSummaryCreateManyHomeTeamInputEnvelope
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
  }

  export type MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput = {
    create?: XOR<MatchSummaryCreateWithoutAwayTeamInput, MatchSummaryUncheckedCreateWithoutAwayTeamInput> | MatchSummaryCreateWithoutAwayTeamInput[] | MatchSummaryUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutAwayTeamInput | MatchSummaryCreateOrConnectWithoutAwayTeamInput[]
    createMany?: MatchSummaryCreateManyAwayTeamInputEnvelope
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
  }

  export type PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutTeamInput, PlayerMatchHistoryUncheckedCreateWithoutTeamInput> | PlayerMatchHistoryCreateWithoutTeamInput[] | PlayerMatchHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutTeamInput | PlayerMatchHistoryCreateOrConnectWithoutTeamInput[]
    createMany?: PlayerMatchHistoryCreateManyTeamInputEnvelope
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedTeamsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamsInput
    upsert?: UserUpsertWithoutCreatedTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTeamsInput, UserUpdateWithoutCreatedTeamsInput>, UserUncheckedUpdateWithoutCreatedTeamsInput>
  }

  export type UserUpdateOneWithoutCaptainOfTeamsNestedInput = {
    create?: XOR<UserCreateWithoutCaptainOfTeamsInput, UserUncheckedCreateWithoutCaptainOfTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCaptainOfTeamsInput
    upsert?: UserUpsertWithoutCaptainOfTeamsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCaptainOfTeamsInput, UserUpdateWithoutCaptainOfTeamsInput>, UserUncheckedUpdateWithoutCaptainOfTeamsInput>
  }

  export type UserUpdateOneWithoutViceCaptainOfTeamsNestedInput = {
    create?: XOR<UserCreateWithoutViceCaptainOfTeamsInput, UserUncheckedCreateWithoutViceCaptainOfTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutViceCaptainOfTeamsInput
    upsert?: UserUpsertWithoutViceCaptainOfTeamsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViceCaptainOfTeamsInput, UserUpdateWithoutViceCaptainOfTeamsInput>, UserUncheckedUpdateWithoutViceCaptainOfTeamsInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type GuestPlayerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<GuestPlayerCreateWithoutTeamInput, GuestPlayerUncheckedCreateWithoutTeamInput> | GuestPlayerCreateWithoutTeamInput[] | GuestPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutTeamInput | GuestPlayerCreateOrConnectWithoutTeamInput[]
    upsert?: GuestPlayerUpsertWithWhereUniqueWithoutTeamInput | GuestPlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: GuestPlayerCreateManyTeamInputEnvelope
    set?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    disconnect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    delete?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    update?: GuestPlayerUpdateWithWhereUniqueWithoutTeamInput | GuestPlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: GuestPlayerUpdateManyWithWhereWithoutTeamInput | GuestPlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
  }

  export type TeamInvitationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamInvitationCreateWithoutTeamInput, TeamInvitationUncheckedCreateWithoutTeamInput> | TeamInvitationCreateWithoutTeamInput[] | TeamInvitationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutTeamInput | TeamInvitationCreateOrConnectWithoutTeamInput[]
    upsert?: TeamInvitationUpsertWithWhereUniqueWithoutTeamInput | TeamInvitationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamInvitationCreateManyTeamInputEnvelope
    set?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    disconnect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    delete?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    update?: TeamInvitationUpdateWithWhereUniqueWithoutTeamInput | TeamInvitationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamInvitationUpdateManyWithWhereWithoutTeamInput | TeamInvitationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
  }

  export type TeamMatchUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<TeamMatchCreateWithoutHomeTeamInput, TeamMatchUncheckedCreateWithoutHomeTeamInput> | TeamMatchCreateWithoutHomeTeamInput[] | TeamMatchUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutHomeTeamInput | TeamMatchCreateOrConnectWithoutHomeTeamInput[]
    upsert?: TeamMatchUpsertWithWhereUniqueWithoutHomeTeamInput | TeamMatchUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: TeamMatchCreateManyHomeTeamInputEnvelope
    set?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    disconnect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    delete?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    update?: TeamMatchUpdateWithWhereUniqueWithoutHomeTeamInput | TeamMatchUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: TeamMatchUpdateManyWithWhereWithoutHomeTeamInput | TeamMatchUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: TeamMatchScalarWhereInput | TeamMatchScalarWhereInput[]
  }

  export type TeamMatchUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<TeamMatchCreateWithoutAwayTeamInput, TeamMatchUncheckedCreateWithoutAwayTeamInput> | TeamMatchCreateWithoutAwayTeamInput[] | TeamMatchUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutAwayTeamInput | TeamMatchCreateOrConnectWithoutAwayTeamInput[]
    upsert?: TeamMatchUpsertWithWhereUniqueWithoutAwayTeamInput | TeamMatchUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: TeamMatchCreateManyAwayTeamInputEnvelope
    set?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    disconnect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    delete?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    update?: TeamMatchUpdateWithWhereUniqueWithoutAwayTeamInput | TeamMatchUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: TeamMatchUpdateManyWithWhereWithoutAwayTeamInput | TeamMatchUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: TeamMatchScalarWhereInput | TeamMatchScalarWhereInput[]
  }

  export type TeamStatisticsUpdateOneWithoutTeamNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutTeamInput, TeamStatisticsUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTeamInput
    upsert?: TeamStatisticsUpsertWithoutTeamInput
    disconnect?: TeamStatisticsWhereInput | boolean
    delete?: TeamStatisticsWhereInput | boolean
    connect?: TeamStatisticsWhereUniqueInput
    update?: XOR<XOR<TeamStatisticsUpdateToOneWithWhereWithoutTeamInput, TeamStatisticsUpdateWithoutTeamInput>, TeamStatisticsUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMatchPlayerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamInput, TeamMatchPlayerUncheckedCreateWithoutTeamInput> | TeamMatchPlayerCreateWithoutTeamInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamInput | TeamMatchPlayerCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamInput | TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMatchPlayerCreateManyTeamInputEnvelope
    set?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    disconnect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    delete?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    update?: TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamInput | TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMatchPlayerUpdateManyWithWhereWithoutTeamInput | TeamMatchPlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
  }

  export type LocalMatchUpdateManyWithoutMyTeamNestedInput = {
    create?: XOR<LocalMatchCreateWithoutMyTeamInput, LocalMatchUncheckedCreateWithoutMyTeamInput> | LocalMatchCreateWithoutMyTeamInput[] | LocalMatchUncheckedCreateWithoutMyTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutMyTeamInput | LocalMatchCreateOrConnectWithoutMyTeamInput[]
    upsert?: LocalMatchUpsertWithWhereUniqueWithoutMyTeamInput | LocalMatchUpsertWithWhereUniqueWithoutMyTeamInput[]
    createMany?: LocalMatchCreateManyMyTeamInputEnvelope
    set?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    disconnect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    delete?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    update?: LocalMatchUpdateWithWhereUniqueWithoutMyTeamInput | LocalMatchUpdateWithWhereUniqueWithoutMyTeamInput[]
    updateMany?: LocalMatchUpdateManyWithWhereWithoutMyTeamInput | LocalMatchUpdateManyWithWhereWithoutMyTeamInput[]
    deleteMany?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
  }

  export type LocalMatchUpdateManyWithoutOpponentTeamNestedInput = {
    create?: XOR<LocalMatchCreateWithoutOpponentTeamInput, LocalMatchUncheckedCreateWithoutOpponentTeamInput> | LocalMatchCreateWithoutOpponentTeamInput[] | LocalMatchUncheckedCreateWithoutOpponentTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutOpponentTeamInput | LocalMatchCreateOrConnectWithoutOpponentTeamInput[]
    upsert?: LocalMatchUpsertWithWhereUniqueWithoutOpponentTeamInput | LocalMatchUpsertWithWhereUniqueWithoutOpponentTeamInput[]
    createMany?: LocalMatchCreateManyOpponentTeamInputEnvelope
    set?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    disconnect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    delete?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    update?: LocalMatchUpdateWithWhereUniqueWithoutOpponentTeamInput | LocalMatchUpdateWithWhereUniqueWithoutOpponentTeamInput[]
    updateMany?: LocalMatchUpdateManyWithWhereWithoutOpponentTeamInput | LocalMatchUpdateManyWithWhereWithoutOpponentTeamInput[]
    deleteMany?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
  }

  export type MatchSummaryUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<MatchSummaryCreateWithoutHomeTeamInput, MatchSummaryUncheckedCreateWithoutHomeTeamInput> | MatchSummaryCreateWithoutHomeTeamInput[] | MatchSummaryUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutHomeTeamInput | MatchSummaryCreateOrConnectWithoutHomeTeamInput[]
    upsert?: MatchSummaryUpsertWithWhereUniqueWithoutHomeTeamInput | MatchSummaryUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: MatchSummaryCreateManyHomeTeamInputEnvelope
    set?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    disconnect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    delete?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    update?: MatchSummaryUpdateWithWhereUniqueWithoutHomeTeamInput | MatchSummaryUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: MatchSummaryUpdateManyWithWhereWithoutHomeTeamInput | MatchSummaryUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
  }

  export type MatchSummaryUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<MatchSummaryCreateWithoutAwayTeamInput, MatchSummaryUncheckedCreateWithoutAwayTeamInput> | MatchSummaryCreateWithoutAwayTeamInput[] | MatchSummaryUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutAwayTeamInput | MatchSummaryCreateOrConnectWithoutAwayTeamInput[]
    upsert?: MatchSummaryUpsertWithWhereUniqueWithoutAwayTeamInput | MatchSummaryUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: MatchSummaryCreateManyAwayTeamInputEnvelope
    set?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    disconnect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    delete?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    update?: MatchSummaryUpdateWithWhereUniqueWithoutAwayTeamInput | MatchSummaryUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: MatchSummaryUpdateManyWithWhereWithoutAwayTeamInput | MatchSummaryUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
  }

  export type PlayerMatchHistoryUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutTeamInput, PlayerMatchHistoryUncheckedCreateWithoutTeamInput> | PlayerMatchHistoryCreateWithoutTeamInput[] | PlayerMatchHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutTeamInput | PlayerMatchHistoryCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerMatchHistoryUpsertWithWhereUniqueWithoutTeamInput | PlayerMatchHistoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerMatchHistoryCreateManyTeamInputEnvelope
    set?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    disconnect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    delete?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    update?: PlayerMatchHistoryUpdateWithWhereUniqueWithoutTeamInput | PlayerMatchHistoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerMatchHistoryUpdateManyWithWhereWithoutTeamInput | PlayerMatchHistoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<GuestPlayerCreateWithoutTeamInput, GuestPlayerUncheckedCreateWithoutTeamInput> | GuestPlayerCreateWithoutTeamInput[] | GuestPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: GuestPlayerCreateOrConnectWithoutTeamInput | GuestPlayerCreateOrConnectWithoutTeamInput[]
    upsert?: GuestPlayerUpsertWithWhereUniqueWithoutTeamInput | GuestPlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: GuestPlayerCreateManyTeamInputEnvelope
    set?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    disconnect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    delete?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    connect?: GuestPlayerWhereUniqueInput | GuestPlayerWhereUniqueInput[]
    update?: GuestPlayerUpdateWithWhereUniqueWithoutTeamInput | GuestPlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: GuestPlayerUpdateManyWithWhereWithoutTeamInput | GuestPlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
  }

  export type TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamInvitationCreateWithoutTeamInput, TeamInvitationUncheckedCreateWithoutTeamInput> | TeamInvitationCreateWithoutTeamInput[] | TeamInvitationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamInvitationCreateOrConnectWithoutTeamInput | TeamInvitationCreateOrConnectWithoutTeamInput[]
    upsert?: TeamInvitationUpsertWithWhereUniqueWithoutTeamInput | TeamInvitationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamInvitationCreateManyTeamInputEnvelope
    set?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    disconnect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    delete?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    connect?: TeamInvitationWhereUniqueInput | TeamInvitationWhereUniqueInput[]
    update?: TeamInvitationUpdateWithWhereUniqueWithoutTeamInput | TeamInvitationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamInvitationUpdateManyWithWhereWithoutTeamInput | TeamInvitationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
  }

  export type TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<TeamMatchCreateWithoutHomeTeamInput, TeamMatchUncheckedCreateWithoutHomeTeamInput> | TeamMatchCreateWithoutHomeTeamInput[] | TeamMatchUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutHomeTeamInput | TeamMatchCreateOrConnectWithoutHomeTeamInput[]
    upsert?: TeamMatchUpsertWithWhereUniqueWithoutHomeTeamInput | TeamMatchUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: TeamMatchCreateManyHomeTeamInputEnvelope
    set?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    disconnect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    delete?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    update?: TeamMatchUpdateWithWhereUniqueWithoutHomeTeamInput | TeamMatchUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: TeamMatchUpdateManyWithWhereWithoutHomeTeamInput | TeamMatchUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: TeamMatchScalarWhereInput | TeamMatchScalarWhereInput[]
  }

  export type TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<TeamMatchCreateWithoutAwayTeamInput, TeamMatchUncheckedCreateWithoutAwayTeamInput> | TeamMatchCreateWithoutAwayTeamInput[] | TeamMatchUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: TeamMatchCreateOrConnectWithoutAwayTeamInput | TeamMatchCreateOrConnectWithoutAwayTeamInput[]
    upsert?: TeamMatchUpsertWithWhereUniqueWithoutAwayTeamInput | TeamMatchUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: TeamMatchCreateManyAwayTeamInputEnvelope
    set?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    disconnect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    delete?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    connect?: TeamMatchWhereUniqueInput | TeamMatchWhereUniqueInput[]
    update?: TeamMatchUpdateWithWhereUniqueWithoutAwayTeamInput | TeamMatchUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: TeamMatchUpdateManyWithWhereWithoutAwayTeamInput | TeamMatchUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: TeamMatchScalarWhereInput | TeamMatchScalarWhereInput[]
  }

  export type TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput = {
    create?: XOR<TeamStatisticsCreateWithoutTeamInput, TeamStatisticsUncheckedCreateWithoutTeamInput>
    connectOrCreate?: TeamStatisticsCreateOrConnectWithoutTeamInput
    upsert?: TeamStatisticsUpsertWithoutTeamInput
    disconnect?: TeamStatisticsWhereInput | boolean
    delete?: TeamStatisticsWhereInput | boolean
    connect?: TeamStatisticsWhereUniqueInput
    update?: XOR<XOR<TeamStatisticsUpdateToOneWithWhereWithoutTeamInput, TeamStatisticsUpdateWithoutTeamInput>, TeamStatisticsUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamInput, TeamMatchPlayerUncheckedCreateWithoutTeamInput> | TeamMatchPlayerCreateWithoutTeamInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamInput | TeamMatchPlayerCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamInput | TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMatchPlayerCreateManyTeamInputEnvelope
    set?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    disconnect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    delete?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    update?: TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamInput | TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMatchPlayerUpdateManyWithWhereWithoutTeamInput | TeamMatchPlayerUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
  }

  export type LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput = {
    create?: XOR<LocalMatchCreateWithoutMyTeamInput, LocalMatchUncheckedCreateWithoutMyTeamInput> | LocalMatchCreateWithoutMyTeamInput[] | LocalMatchUncheckedCreateWithoutMyTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutMyTeamInput | LocalMatchCreateOrConnectWithoutMyTeamInput[]
    upsert?: LocalMatchUpsertWithWhereUniqueWithoutMyTeamInput | LocalMatchUpsertWithWhereUniqueWithoutMyTeamInput[]
    createMany?: LocalMatchCreateManyMyTeamInputEnvelope
    set?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    disconnect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    delete?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    update?: LocalMatchUpdateWithWhereUniqueWithoutMyTeamInput | LocalMatchUpdateWithWhereUniqueWithoutMyTeamInput[]
    updateMany?: LocalMatchUpdateManyWithWhereWithoutMyTeamInput | LocalMatchUpdateManyWithWhereWithoutMyTeamInput[]
    deleteMany?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
  }

  export type LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput = {
    create?: XOR<LocalMatchCreateWithoutOpponentTeamInput, LocalMatchUncheckedCreateWithoutOpponentTeamInput> | LocalMatchCreateWithoutOpponentTeamInput[] | LocalMatchUncheckedCreateWithoutOpponentTeamInput[]
    connectOrCreate?: LocalMatchCreateOrConnectWithoutOpponentTeamInput | LocalMatchCreateOrConnectWithoutOpponentTeamInput[]
    upsert?: LocalMatchUpsertWithWhereUniqueWithoutOpponentTeamInput | LocalMatchUpsertWithWhereUniqueWithoutOpponentTeamInput[]
    createMany?: LocalMatchCreateManyOpponentTeamInputEnvelope
    set?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    disconnect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    delete?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    connect?: LocalMatchWhereUniqueInput | LocalMatchWhereUniqueInput[]
    update?: LocalMatchUpdateWithWhereUniqueWithoutOpponentTeamInput | LocalMatchUpdateWithWhereUniqueWithoutOpponentTeamInput[]
    updateMany?: LocalMatchUpdateManyWithWhereWithoutOpponentTeamInput | LocalMatchUpdateManyWithWhereWithoutOpponentTeamInput[]
    deleteMany?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
  }

  export type MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput = {
    create?: XOR<MatchSummaryCreateWithoutHomeTeamInput, MatchSummaryUncheckedCreateWithoutHomeTeamInput> | MatchSummaryCreateWithoutHomeTeamInput[] | MatchSummaryUncheckedCreateWithoutHomeTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutHomeTeamInput | MatchSummaryCreateOrConnectWithoutHomeTeamInput[]
    upsert?: MatchSummaryUpsertWithWhereUniqueWithoutHomeTeamInput | MatchSummaryUpsertWithWhereUniqueWithoutHomeTeamInput[]
    createMany?: MatchSummaryCreateManyHomeTeamInputEnvelope
    set?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    disconnect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    delete?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    update?: MatchSummaryUpdateWithWhereUniqueWithoutHomeTeamInput | MatchSummaryUpdateWithWhereUniqueWithoutHomeTeamInput[]
    updateMany?: MatchSummaryUpdateManyWithWhereWithoutHomeTeamInput | MatchSummaryUpdateManyWithWhereWithoutHomeTeamInput[]
    deleteMany?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
  }

  export type MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput = {
    create?: XOR<MatchSummaryCreateWithoutAwayTeamInput, MatchSummaryUncheckedCreateWithoutAwayTeamInput> | MatchSummaryCreateWithoutAwayTeamInput[] | MatchSummaryUncheckedCreateWithoutAwayTeamInput[]
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutAwayTeamInput | MatchSummaryCreateOrConnectWithoutAwayTeamInput[]
    upsert?: MatchSummaryUpsertWithWhereUniqueWithoutAwayTeamInput | MatchSummaryUpsertWithWhereUniqueWithoutAwayTeamInput[]
    createMany?: MatchSummaryCreateManyAwayTeamInputEnvelope
    set?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    disconnect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    delete?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    connect?: MatchSummaryWhereUniqueInput | MatchSummaryWhereUniqueInput[]
    update?: MatchSummaryUpdateWithWhereUniqueWithoutAwayTeamInput | MatchSummaryUpdateWithWhereUniqueWithoutAwayTeamInput[]
    updateMany?: MatchSummaryUpdateManyWithWhereWithoutAwayTeamInput | MatchSummaryUpdateManyWithWhereWithoutAwayTeamInput[]
    deleteMany?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
  }

  export type PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutTeamInput, PlayerMatchHistoryUncheckedCreateWithoutTeamInput> | PlayerMatchHistoryCreateWithoutTeamInput[] | PlayerMatchHistoryUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutTeamInput | PlayerMatchHistoryCreateOrConnectWithoutTeamInput[]
    upsert?: PlayerMatchHistoryUpsertWithWhereUniqueWithoutTeamInput | PlayerMatchHistoryUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PlayerMatchHistoryCreateManyTeamInputEnvelope
    set?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    disconnect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    delete?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    update?: PlayerMatchHistoryUpdateWithWhereUniqueWithoutTeamInput | PlayerMatchHistoryUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PlayerMatchHistoryUpdateManyWithWhereWithoutTeamInput | PlayerMatchHistoryUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type TeamCreateNestedOneWithoutGuestPlayersInput = {
    create?: XOR<TeamCreateWithoutGuestPlayersInput, TeamUncheckedCreateWithoutGuestPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutGuestPlayersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGuestPlayersAddedInput = {
    create?: XOR<UserCreateWithoutGuestPlayersAddedInput, UserUncheckedCreateWithoutGuestPlayersAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuestPlayersAddedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGuestPlayersLinkedInput = {
    create?: XOR<UserCreateWithoutGuestPlayersLinkedInput, UserUncheckedCreateWithoutGuestPlayersLinkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuestPlayersLinkedInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutGuestPlayersNestedInput = {
    create?: XOR<TeamCreateWithoutGuestPlayersInput, TeamUncheckedCreateWithoutGuestPlayersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutGuestPlayersInput
    upsert?: TeamUpsertWithoutGuestPlayersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutGuestPlayersInput, TeamUpdateWithoutGuestPlayersInput>, TeamUncheckedUpdateWithoutGuestPlayersInput>
  }

  export type UserUpdateOneRequiredWithoutGuestPlayersAddedNestedInput = {
    create?: XOR<UserCreateWithoutGuestPlayersAddedInput, UserUncheckedCreateWithoutGuestPlayersAddedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuestPlayersAddedInput
    upsert?: UserUpsertWithoutGuestPlayersAddedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGuestPlayersAddedInput, UserUpdateWithoutGuestPlayersAddedInput>, UserUncheckedUpdateWithoutGuestPlayersAddedInput>
  }

  export type UserUpdateOneWithoutGuestPlayersLinkedNestedInput = {
    create?: XOR<UserCreateWithoutGuestPlayersLinkedInput, UserUncheckedCreateWithoutGuestPlayersLinkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutGuestPlayersLinkedInput
    upsert?: UserUpsertWithoutGuestPlayersLinkedInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGuestPlayersLinkedInput, UserUpdateWithoutGuestPlayersLinkedInput>, UserUncheckedUpdateWithoutGuestPlayersLinkedInput>
  }

  export type TeamCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<TeamCreateWithoutInvitationsInput, TeamUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitationsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentInvitationsInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedInvitationsInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type TeamUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<TeamCreateWithoutInvitationsInput, TeamUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutInvitationsInput
    upsert?: TeamUpsertWithoutInvitationsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutInvitationsInput, TeamUpdateWithoutInvitationsInput>, TeamUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutSentInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentInvitationsInput
    upsert?: UserUpsertWithoutSentInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentInvitationsInput, UserUpdateWithoutSentInvitationsInput>, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedInvitationsInput
    upsert?: UserUpsertWithoutReceivedInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedInvitationsInput, UserUpdateWithoutReceivedInvitationsInput>, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type UserCreateNestedOneWithoutMatchesInput = {
    create?: XOR<UserCreateWithoutMatchesInput, UserUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<UserCreateWithoutMatchesInput, UserUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesInput
    upsert?: UserUpsertWithoutMatchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesInput, UserUpdateWithoutMatchesInput>, UserUncheckedUpdateWithoutMatchesInput>
  }

  export type TeamCreateNestedOneWithoutHomeMatchesInput = {
    create?: XOR<TeamCreateWithoutHomeMatchesInput, TeamUncheckedCreateWithoutHomeMatchesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeMatchesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutAwayMatchesInput = {
    create?: XOR<TeamCreateWithoutAwayMatchesInput, TeamUncheckedCreateWithoutAwayMatchesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayMatchesInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamMatchPlayerCreateNestedManyWithoutTeamMatchInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamMatchInput, TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput> | TeamMatchPlayerCreateWithoutTeamMatchInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput | TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput[]
    createMany?: TeamMatchPlayerCreateManyTeamMatchInputEnvelope
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
  }

  export type TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamMatchInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamMatchInput, TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput> | TeamMatchPlayerCreateWithoutTeamMatchInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput | TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput[]
    createMany?: TeamMatchPlayerCreateManyTeamMatchInputEnvelope
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type NullableEnumMatchResultFieldUpdateOperationsInput = {
    set?: $Enums.MatchResult | null
    unset?: boolean
  }

  export type TeamUpdateOneRequiredWithoutHomeMatchesNestedInput = {
    create?: XOR<TeamCreateWithoutHomeMatchesInput, TeamUncheckedCreateWithoutHomeMatchesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutHomeMatchesInput
    upsert?: TeamUpsertWithoutHomeMatchesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutHomeMatchesInput, TeamUpdateWithoutHomeMatchesInput>, TeamUncheckedUpdateWithoutHomeMatchesInput>
  }

  export type TeamUpdateOneRequiredWithoutAwayMatchesNestedInput = {
    create?: XOR<TeamCreateWithoutAwayMatchesInput, TeamUncheckedCreateWithoutAwayMatchesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAwayMatchesInput
    upsert?: TeamUpsertWithoutAwayMatchesInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutAwayMatchesInput, TeamUpdateWithoutAwayMatchesInput>, TeamUncheckedUpdateWithoutAwayMatchesInput>
  }

  export type TeamMatchPlayerUpdateManyWithoutTeamMatchNestedInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamMatchInput, TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput> | TeamMatchPlayerCreateWithoutTeamMatchInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput | TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput[]
    upsert?: TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamMatchInput | TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamMatchInput[]
    createMany?: TeamMatchPlayerCreateManyTeamMatchInputEnvelope
    set?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    disconnect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    delete?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    update?: TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamMatchInput | TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamMatchInput[]
    updateMany?: TeamMatchPlayerUpdateManyWithWhereWithoutTeamMatchInput | TeamMatchPlayerUpdateManyWithWhereWithoutTeamMatchInput[]
    deleteMany?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
  }

  export type TeamMatchPlayerUncheckedUpdateManyWithoutTeamMatchNestedInput = {
    create?: XOR<TeamMatchPlayerCreateWithoutTeamMatchInput, TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput> | TeamMatchPlayerCreateWithoutTeamMatchInput[] | TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput[]
    connectOrCreate?: TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput | TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput[]
    upsert?: TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamMatchInput | TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamMatchInput[]
    createMany?: TeamMatchPlayerCreateManyTeamMatchInputEnvelope
    set?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    disconnect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    delete?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    connect?: TeamMatchPlayerWhereUniqueInput | TeamMatchPlayerWhereUniqueInput[]
    update?: TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamMatchInput | TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamMatchInput[]
    updateMany?: TeamMatchPlayerUpdateManyWithWhereWithoutTeamMatchInput | TeamMatchPlayerUpdateManyWithWhereWithoutTeamMatchInput[]
    deleteMany?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
  }

  export type TeamMatchCreateNestedOneWithoutPlayerStatsInput = {
    create?: XOR<TeamMatchCreateWithoutPlayerStatsInput, TeamMatchUncheckedCreateWithoutPlayerStatsInput>
    connectOrCreate?: TeamMatchCreateOrConnectWithoutPlayerStatsInput
    connect?: TeamMatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMatchStatsInput = {
    create?: XOR<UserCreateWithoutTeamMatchStatsInput, UserUncheckedCreateWithoutTeamMatchStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMatchStatsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTeamMatchStatsInput = {
    create?: XOR<TeamCreateWithoutTeamMatchStatsInput, TeamUncheckedCreateWithoutTeamMatchStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamMatchStatsInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamMatchUpdateOneRequiredWithoutPlayerStatsNestedInput = {
    create?: XOR<TeamMatchCreateWithoutPlayerStatsInput, TeamMatchUncheckedCreateWithoutPlayerStatsInput>
    connectOrCreate?: TeamMatchCreateOrConnectWithoutPlayerStatsInput
    upsert?: TeamMatchUpsertWithoutPlayerStatsInput
    connect?: TeamMatchWhereUniqueInput
    update?: XOR<XOR<TeamMatchUpdateToOneWithWhereWithoutPlayerStatsInput, TeamMatchUpdateWithoutPlayerStatsInput>, TeamMatchUncheckedUpdateWithoutPlayerStatsInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMatchStatsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMatchStatsInput, UserUncheckedCreateWithoutTeamMatchStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMatchStatsInput
    upsert?: UserUpsertWithoutTeamMatchStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMatchStatsInput, UserUpdateWithoutTeamMatchStatsInput>, UserUncheckedUpdateWithoutTeamMatchStatsInput>
  }

  export type TeamUpdateOneRequiredWithoutTeamMatchStatsNestedInput = {
    create?: XOR<TeamCreateWithoutTeamMatchStatsInput, TeamUncheckedCreateWithoutTeamMatchStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamMatchStatsInput
    upsert?: TeamUpsertWithoutTeamMatchStatsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTeamMatchStatsInput, TeamUpdateWithoutTeamMatchStatsInput>, TeamUncheckedUpdateWithoutTeamMatchStatsInput>
  }

  export type TeamCreateNestedOneWithoutTeamStatsInput = {
    create?: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamStatsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTopRunScorerForInput = {
    create?: XOR<UserCreateWithoutTopRunScorerForInput, UserUncheckedCreateWithoutTopRunScorerForInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopRunScorerForInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTopWicketTakerForInput = {
    create?: XOR<UserCreateWithoutTopWicketTakerForInput, UserUncheckedCreateWithoutTopWicketTakerForInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopWicketTakerForInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBestStrikeRateForInput = {
    create?: XOR<UserCreateWithoutBestStrikeRateForInput, UserUncheckedCreateWithoutBestStrikeRateForInput>
    connectOrCreate?: UserCreateOrConnectWithoutBestStrikeRateForInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBestEconomyForInput = {
    create?: XOR<UserCreateWithoutBestEconomyForInput, UserUncheckedCreateWithoutBestEconomyForInput>
    connectOrCreate?: UserCreateOrConnectWithoutBestEconomyForInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMostManOfTheMatchForInput = {
    create?: XOR<UserCreateWithoutMostManOfTheMatchForInput, UserUncheckedCreateWithoutMostManOfTheMatchForInput>
    connectOrCreate?: UserCreateOrConnectWithoutMostManOfTheMatchForInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutTeamStatsNestedInput = {
    create?: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamStatsInput
    upsert?: TeamUpsertWithoutTeamStatsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTeamStatsInput, TeamUpdateWithoutTeamStatsInput>, TeamUncheckedUpdateWithoutTeamStatsInput>
  }

  export type UserUpdateOneWithoutTopRunScorerForNestedInput = {
    create?: XOR<UserCreateWithoutTopRunScorerForInput, UserUncheckedCreateWithoutTopRunScorerForInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopRunScorerForInput
    upsert?: UserUpsertWithoutTopRunScorerForInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopRunScorerForInput, UserUpdateWithoutTopRunScorerForInput>, UserUncheckedUpdateWithoutTopRunScorerForInput>
  }

  export type UserUpdateOneWithoutTopWicketTakerForNestedInput = {
    create?: XOR<UserCreateWithoutTopWicketTakerForInput, UserUncheckedCreateWithoutTopWicketTakerForInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopWicketTakerForInput
    upsert?: UserUpsertWithoutTopWicketTakerForInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopWicketTakerForInput, UserUpdateWithoutTopWicketTakerForInput>, UserUncheckedUpdateWithoutTopWicketTakerForInput>
  }

  export type UserUpdateOneWithoutBestStrikeRateForNestedInput = {
    create?: XOR<UserCreateWithoutBestStrikeRateForInput, UserUncheckedCreateWithoutBestStrikeRateForInput>
    connectOrCreate?: UserCreateOrConnectWithoutBestStrikeRateForInput
    upsert?: UserUpsertWithoutBestStrikeRateForInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBestStrikeRateForInput, UserUpdateWithoutBestStrikeRateForInput>, UserUncheckedUpdateWithoutBestStrikeRateForInput>
  }

  export type UserUpdateOneWithoutBestEconomyForNestedInput = {
    create?: XOR<UserCreateWithoutBestEconomyForInput, UserUncheckedCreateWithoutBestEconomyForInput>
    connectOrCreate?: UserCreateOrConnectWithoutBestEconomyForInput
    upsert?: UserUpsertWithoutBestEconomyForInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBestEconomyForInput, UserUpdateWithoutBestEconomyForInput>, UserUncheckedUpdateWithoutBestEconomyForInput>
  }

  export type UserUpdateOneWithoutMostManOfTheMatchForNestedInput = {
    create?: XOR<UserCreateWithoutMostManOfTheMatchForInput, UserUncheckedCreateWithoutMostManOfTheMatchForInput>
    connectOrCreate?: UserCreateOrConnectWithoutMostManOfTheMatchForInput
    upsert?: UserUpsertWithoutMostManOfTheMatchForInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMostManOfTheMatchForInput, UserUpdateWithoutMostManOfTheMatchForInput>, UserUncheckedUpdateWithoutMostManOfTheMatchForInput>
  }

  export type UserCreateNestedOneWithoutCreatedLocalMatchesInput = {
    create?: XOR<UserCreateWithoutCreatedLocalMatchesInput, UserUncheckedCreateWithoutCreatedLocalMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLocalMatchesInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutLocalMatchesAsMyTeamInput = {
    create?: XOR<TeamCreateWithoutLocalMatchesAsMyTeamInput, TeamUncheckedCreateWithoutLocalMatchesAsMyTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLocalMatchesAsMyTeamInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutLocalMatchesAsOpponentInput = {
    create?: XOR<TeamCreateWithoutLocalMatchesAsOpponentInput, TeamUncheckedCreateWithoutLocalMatchesAsOpponentInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLocalMatchesAsOpponentInput
    connect?: TeamWhereUniqueInput
  }

  export type MatchSpectatorCreateNestedManyWithoutLocalMatchInput = {
    create?: XOR<MatchSpectatorCreateWithoutLocalMatchInput, MatchSpectatorUncheckedCreateWithoutLocalMatchInput> | MatchSpectatorCreateWithoutLocalMatchInput[] | MatchSpectatorUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutLocalMatchInput | MatchSpectatorCreateOrConnectWithoutLocalMatchInput[]
    createMany?: MatchSpectatorCreateManyLocalMatchInputEnvelope
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
  }

  export type OverHistoryCreateNestedManyWithoutLocalMatchInput = {
    create?: XOR<OverHistoryCreateWithoutLocalMatchInput, OverHistoryUncheckedCreateWithoutLocalMatchInput> | OverHistoryCreateWithoutLocalMatchInput[] | OverHistoryUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: OverHistoryCreateOrConnectWithoutLocalMatchInput | OverHistoryCreateOrConnectWithoutLocalMatchInput[]
    createMany?: OverHistoryCreateManyLocalMatchInputEnvelope
    connect?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
  }

  export type MatchSpectatorUncheckedCreateNestedManyWithoutLocalMatchInput = {
    create?: XOR<MatchSpectatorCreateWithoutLocalMatchInput, MatchSpectatorUncheckedCreateWithoutLocalMatchInput> | MatchSpectatorCreateWithoutLocalMatchInput[] | MatchSpectatorUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutLocalMatchInput | MatchSpectatorCreateOrConnectWithoutLocalMatchInput[]
    createMany?: MatchSpectatorCreateManyLocalMatchInputEnvelope
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
  }

  export type OverHistoryUncheckedCreateNestedManyWithoutLocalMatchInput = {
    create?: XOR<OverHistoryCreateWithoutLocalMatchInput, OverHistoryUncheckedCreateWithoutLocalMatchInput> | OverHistoryCreateWithoutLocalMatchInput[] | OverHistoryUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: OverHistoryCreateOrConnectWithoutLocalMatchInput | OverHistoryCreateOrConnectWithoutLocalMatchInput[]
    createMany?: OverHistoryCreateManyLocalMatchInputEnvelope
    connect?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
  }

  export type EnumLocalMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.LocalMatchStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedLocalMatchesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedLocalMatchesInput, UserUncheckedCreateWithoutCreatedLocalMatchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedLocalMatchesInput
    upsert?: UserUpsertWithoutCreatedLocalMatchesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedLocalMatchesInput, UserUpdateWithoutCreatedLocalMatchesInput>, UserUncheckedUpdateWithoutCreatedLocalMatchesInput>
  }

  export type TeamUpdateOneWithoutLocalMatchesAsMyTeamNestedInput = {
    create?: XOR<TeamCreateWithoutLocalMatchesAsMyTeamInput, TeamUncheckedCreateWithoutLocalMatchesAsMyTeamInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLocalMatchesAsMyTeamInput
    upsert?: TeamUpsertWithoutLocalMatchesAsMyTeamInput
    disconnect?: boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutLocalMatchesAsMyTeamInput, TeamUpdateWithoutLocalMatchesAsMyTeamInput>, TeamUncheckedUpdateWithoutLocalMatchesAsMyTeamInput>
  }

  export type TeamUpdateOneWithoutLocalMatchesAsOpponentNestedInput = {
    create?: XOR<TeamCreateWithoutLocalMatchesAsOpponentInput, TeamUncheckedCreateWithoutLocalMatchesAsOpponentInput>
    connectOrCreate?: TeamCreateOrConnectWithoutLocalMatchesAsOpponentInput
    upsert?: TeamUpsertWithoutLocalMatchesAsOpponentInput
    disconnect?: boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutLocalMatchesAsOpponentInput, TeamUpdateWithoutLocalMatchesAsOpponentInput>, TeamUncheckedUpdateWithoutLocalMatchesAsOpponentInput>
  }

  export type MatchSpectatorUpdateManyWithoutLocalMatchNestedInput = {
    create?: XOR<MatchSpectatorCreateWithoutLocalMatchInput, MatchSpectatorUncheckedCreateWithoutLocalMatchInput> | MatchSpectatorCreateWithoutLocalMatchInput[] | MatchSpectatorUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutLocalMatchInput | MatchSpectatorCreateOrConnectWithoutLocalMatchInput[]
    upsert?: MatchSpectatorUpsertWithWhereUniqueWithoutLocalMatchInput | MatchSpectatorUpsertWithWhereUniqueWithoutLocalMatchInput[]
    createMany?: MatchSpectatorCreateManyLocalMatchInputEnvelope
    set?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    disconnect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    delete?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    update?: MatchSpectatorUpdateWithWhereUniqueWithoutLocalMatchInput | MatchSpectatorUpdateWithWhereUniqueWithoutLocalMatchInput[]
    updateMany?: MatchSpectatorUpdateManyWithWhereWithoutLocalMatchInput | MatchSpectatorUpdateManyWithWhereWithoutLocalMatchInput[]
    deleteMany?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
  }

  export type OverHistoryUpdateManyWithoutLocalMatchNestedInput = {
    create?: XOR<OverHistoryCreateWithoutLocalMatchInput, OverHistoryUncheckedCreateWithoutLocalMatchInput> | OverHistoryCreateWithoutLocalMatchInput[] | OverHistoryUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: OverHistoryCreateOrConnectWithoutLocalMatchInput | OverHistoryCreateOrConnectWithoutLocalMatchInput[]
    upsert?: OverHistoryUpsertWithWhereUniqueWithoutLocalMatchInput | OverHistoryUpsertWithWhereUniqueWithoutLocalMatchInput[]
    createMany?: OverHistoryCreateManyLocalMatchInputEnvelope
    set?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    disconnect?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    delete?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    connect?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    update?: OverHistoryUpdateWithWhereUniqueWithoutLocalMatchInput | OverHistoryUpdateWithWhereUniqueWithoutLocalMatchInput[]
    updateMany?: OverHistoryUpdateManyWithWhereWithoutLocalMatchInput | OverHistoryUpdateManyWithWhereWithoutLocalMatchInput[]
    deleteMany?: OverHistoryScalarWhereInput | OverHistoryScalarWhereInput[]
  }

  export type MatchSpectatorUncheckedUpdateManyWithoutLocalMatchNestedInput = {
    create?: XOR<MatchSpectatorCreateWithoutLocalMatchInput, MatchSpectatorUncheckedCreateWithoutLocalMatchInput> | MatchSpectatorCreateWithoutLocalMatchInput[] | MatchSpectatorUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: MatchSpectatorCreateOrConnectWithoutLocalMatchInput | MatchSpectatorCreateOrConnectWithoutLocalMatchInput[]
    upsert?: MatchSpectatorUpsertWithWhereUniqueWithoutLocalMatchInput | MatchSpectatorUpsertWithWhereUniqueWithoutLocalMatchInput[]
    createMany?: MatchSpectatorCreateManyLocalMatchInputEnvelope
    set?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    disconnect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    delete?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    connect?: MatchSpectatorWhereUniqueInput | MatchSpectatorWhereUniqueInput[]
    update?: MatchSpectatorUpdateWithWhereUniqueWithoutLocalMatchInput | MatchSpectatorUpdateWithWhereUniqueWithoutLocalMatchInput[]
    updateMany?: MatchSpectatorUpdateManyWithWhereWithoutLocalMatchInput | MatchSpectatorUpdateManyWithWhereWithoutLocalMatchInput[]
    deleteMany?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
  }

  export type OverHistoryUncheckedUpdateManyWithoutLocalMatchNestedInput = {
    create?: XOR<OverHistoryCreateWithoutLocalMatchInput, OverHistoryUncheckedCreateWithoutLocalMatchInput> | OverHistoryCreateWithoutLocalMatchInput[] | OverHistoryUncheckedCreateWithoutLocalMatchInput[]
    connectOrCreate?: OverHistoryCreateOrConnectWithoutLocalMatchInput | OverHistoryCreateOrConnectWithoutLocalMatchInput[]
    upsert?: OverHistoryUpsertWithWhereUniqueWithoutLocalMatchInput | OverHistoryUpsertWithWhereUniqueWithoutLocalMatchInput[]
    createMany?: OverHistoryCreateManyLocalMatchInputEnvelope
    set?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    disconnect?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    delete?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    connect?: OverHistoryWhereUniqueInput | OverHistoryWhereUniqueInput[]
    update?: OverHistoryUpdateWithWhereUniqueWithoutLocalMatchInput | OverHistoryUpdateWithWhereUniqueWithoutLocalMatchInput[]
    updateMany?: OverHistoryUpdateManyWithWhereWithoutLocalMatchInput | OverHistoryUpdateManyWithWhereWithoutLocalMatchInput[]
    deleteMany?: OverHistoryScalarWhereInput | OverHistoryScalarWhereInput[]
  }

  export type LocalMatchCreateNestedOneWithoutSpectatorsInput = {
    create?: XOR<LocalMatchCreateWithoutSpectatorsInput, LocalMatchUncheckedCreateWithoutSpectatorsInput>
    connectOrCreate?: LocalMatchCreateOrConnectWithoutSpectatorsInput
    connect?: LocalMatchWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSpectatorOfInput = {
    create?: XOR<UserCreateWithoutSpectatorOfInput, UserUncheckedCreateWithoutSpectatorOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpectatorOfInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAddedSpectatorsInput = {
    create?: XOR<UserCreateWithoutAddedSpectatorsInput, UserUncheckedCreateWithoutAddedSpectatorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedSpectatorsInput
    connect?: UserWhereUniqueInput
  }

  export type LocalMatchUpdateOneRequiredWithoutSpectatorsNestedInput = {
    create?: XOR<LocalMatchCreateWithoutSpectatorsInput, LocalMatchUncheckedCreateWithoutSpectatorsInput>
    connectOrCreate?: LocalMatchCreateOrConnectWithoutSpectatorsInput
    upsert?: LocalMatchUpsertWithoutSpectatorsInput
    connect?: LocalMatchWhereUniqueInput
    update?: XOR<XOR<LocalMatchUpdateToOneWithWhereWithoutSpectatorsInput, LocalMatchUpdateWithoutSpectatorsInput>, LocalMatchUncheckedUpdateWithoutSpectatorsInput>
  }

  export type UserUpdateOneRequiredWithoutSpectatorOfNestedInput = {
    create?: XOR<UserCreateWithoutSpectatorOfInput, UserUncheckedCreateWithoutSpectatorOfInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpectatorOfInput
    upsert?: UserUpsertWithoutSpectatorOfInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpectatorOfInput, UserUpdateWithoutSpectatorOfInput>, UserUncheckedUpdateWithoutSpectatorOfInput>
  }

  export type UserUpdateOneRequiredWithoutAddedSpectatorsNestedInput = {
    create?: XOR<UserCreateWithoutAddedSpectatorsInput, UserUncheckedCreateWithoutAddedSpectatorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedSpectatorsInput
    upsert?: UserUpsertWithoutAddedSpectatorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddedSpectatorsInput, UserUpdateWithoutAddedSpectatorsInput>, UserUncheckedUpdateWithoutAddedSpectatorsInput>
  }

  export type LocalMatchCreateNestedOneWithoutOverHistoryInput = {
    create?: XOR<LocalMatchCreateWithoutOverHistoryInput, LocalMatchUncheckedCreateWithoutOverHistoryInput>
    connectOrCreate?: LocalMatchCreateOrConnectWithoutOverHistoryInput
    connect?: LocalMatchWhereUniqueInput
  }

  export type LocalMatchUpdateOneRequiredWithoutOverHistoryNestedInput = {
    create?: XOR<LocalMatchCreateWithoutOverHistoryInput, LocalMatchUncheckedCreateWithoutOverHistoryInput>
    connectOrCreate?: LocalMatchCreateOrConnectWithoutOverHistoryInput
    upsert?: LocalMatchUpsertWithoutOverHistoryInput
    connect?: LocalMatchWhereUniqueInput
    update?: XOR<XOR<LocalMatchUpdateToOneWithWhereWithoutOverHistoryInput, LocalMatchUpdateWithoutOverHistoryInput>, LocalMatchUncheckedUpdateWithoutOverHistoryInput>
  }

  export type TeamCreateNestedOneWithoutMatchSummariesAsHomeInput = {
    create?: XOR<TeamCreateWithoutMatchSummariesAsHomeInput, TeamUncheckedCreateWithoutMatchSummariesAsHomeInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchSummariesAsHomeInput
    connect?: TeamWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMatchSummariesAsAwayInput = {
    create?: XOR<TeamCreateWithoutMatchSummariesAsAwayInput, TeamUncheckedCreateWithoutMatchSummariesAsAwayInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchSummariesAsAwayInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchSummariesAsManOfTheMatchInput = {
    create?: XOR<UserCreateWithoutMatchSummariesAsManOfTheMatchInput, UserUncheckedCreateWithoutMatchSummariesAsManOfTheMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchSummariesAsManOfTheMatchInput
    connect?: UserWhereUniqueInput
  }

  export type PlayerMatchHistoryCreateNestedManyWithoutMatchSummaryInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput> | PlayerMatchHistoryCreateWithoutMatchSummaryInput[] | PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput | PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput[]
    createMany?: PlayerMatchHistoryCreateManyMatchSummaryInputEnvelope
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
  }

  export type PlayerMatchHistoryUncheckedCreateNestedManyWithoutMatchSummaryInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput> | PlayerMatchHistoryCreateWithoutMatchSummaryInput[] | PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput | PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput[]
    createMany?: PlayerMatchHistoryCreateManyMatchSummaryInputEnvelope
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
  }

  export type EnumMatchResultFieldUpdateOperationsInput = {
    set?: $Enums.MatchResult
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type TeamUpdateOneWithoutMatchSummariesAsHomeNestedInput = {
    create?: XOR<TeamCreateWithoutMatchSummariesAsHomeInput, TeamUncheckedCreateWithoutMatchSummariesAsHomeInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchSummariesAsHomeInput
    upsert?: TeamUpsertWithoutMatchSummariesAsHomeInput
    disconnect?: boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMatchSummariesAsHomeInput, TeamUpdateWithoutMatchSummariesAsHomeInput>, TeamUncheckedUpdateWithoutMatchSummariesAsHomeInput>
  }

  export type TeamUpdateOneWithoutMatchSummariesAsAwayNestedInput = {
    create?: XOR<TeamCreateWithoutMatchSummariesAsAwayInput, TeamUncheckedCreateWithoutMatchSummariesAsAwayInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMatchSummariesAsAwayInput
    upsert?: TeamUpsertWithoutMatchSummariesAsAwayInput
    disconnect?: boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMatchSummariesAsAwayInput, TeamUpdateWithoutMatchSummariesAsAwayInput>, TeamUncheckedUpdateWithoutMatchSummariesAsAwayInput>
  }

  export type UserUpdateOneWithoutMatchSummariesAsManOfTheMatchNestedInput = {
    create?: XOR<UserCreateWithoutMatchSummariesAsManOfTheMatchInput, UserUncheckedCreateWithoutMatchSummariesAsManOfTheMatchInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchSummariesAsManOfTheMatchInput
    upsert?: UserUpsertWithoutMatchSummariesAsManOfTheMatchInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchSummariesAsManOfTheMatchInput, UserUpdateWithoutMatchSummariesAsManOfTheMatchInput>, UserUncheckedUpdateWithoutMatchSummariesAsManOfTheMatchInput>
  }

  export type PlayerMatchHistoryUpdateManyWithoutMatchSummaryNestedInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput> | PlayerMatchHistoryCreateWithoutMatchSummaryInput[] | PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput | PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput[]
    upsert?: PlayerMatchHistoryUpsertWithWhereUniqueWithoutMatchSummaryInput | PlayerMatchHistoryUpsertWithWhereUniqueWithoutMatchSummaryInput[]
    createMany?: PlayerMatchHistoryCreateManyMatchSummaryInputEnvelope
    set?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    disconnect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    delete?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    update?: PlayerMatchHistoryUpdateWithWhereUniqueWithoutMatchSummaryInput | PlayerMatchHistoryUpdateWithWhereUniqueWithoutMatchSummaryInput[]
    updateMany?: PlayerMatchHistoryUpdateManyWithWhereWithoutMatchSummaryInput | PlayerMatchHistoryUpdateManyWithWhereWithoutMatchSummaryInput[]
    deleteMany?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
  }

  export type PlayerMatchHistoryUncheckedUpdateManyWithoutMatchSummaryNestedInput = {
    create?: XOR<PlayerMatchHistoryCreateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput> | PlayerMatchHistoryCreateWithoutMatchSummaryInput[] | PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput[]
    connectOrCreate?: PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput | PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput[]
    upsert?: PlayerMatchHistoryUpsertWithWhereUniqueWithoutMatchSummaryInput | PlayerMatchHistoryUpsertWithWhereUniqueWithoutMatchSummaryInput[]
    createMany?: PlayerMatchHistoryCreateManyMatchSummaryInputEnvelope
    set?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    disconnect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    delete?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    connect?: PlayerMatchHistoryWhereUniqueInput | PlayerMatchHistoryWhereUniqueInput[]
    update?: PlayerMatchHistoryUpdateWithWhereUniqueWithoutMatchSummaryInput | PlayerMatchHistoryUpdateWithWhereUniqueWithoutMatchSummaryInput[]
    updateMany?: PlayerMatchHistoryUpdateManyWithWhereWithoutMatchSummaryInput | PlayerMatchHistoryUpdateManyWithWhereWithoutMatchSummaryInput[]
    deleteMany?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPlayerMatchHistoryInput = {
    create?: XOR<UserCreateWithoutPlayerMatchHistoryInput, UserUncheckedCreateWithoutPlayerMatchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerMatchHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type MatchSummaryCreateNestedOneWithoutPlayerHistoryInput = {
    create?: XOR<MatchSummaryCreateWithoutPlayerHistoryInput, MatchSummaryUncheckedCreateWithoutPlayerHistoryInput>
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutPlayerHistoryInput
    connect?: MatchSummaryWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutPlayerMatchHistoryInput = {
    create?: XOR<TeamCreateWithoutPlayerMatchHistoryInput, TeamUncheckedCreateWithoutPlayerMatchHistoryInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayerMatchHistoryInput
    connect?: TeamWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlayerMatchHistoryNestedInput = {
    create?: XOR<UserCreateWithoutPlayerMatchHistoryInput, UserUncheckedCreateWithoutPlayerMatchHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayerMatchHistoryInput
    upsert?: UserUpsertWithoutPlayerMatchHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayerMatchHistoryInput, UserUpdateWithoutPlayerMatchHistoryInput>, UserUncheckedUpdateWithoutPlayerMatchHistoryInput>
  }

  export type MatchSummaryUpdateOneRequiredWithoutPlayerHistoryNestedInput = {
    create?: XOR<MatchSummaryCreateWithoutPlayerHistoryInput, MatchSummaryUncheckedCreateWithoutPlayerHistoryInput>
    connectOrCreate?: MatchSummaryCreateOrConnectWithoutPlayerHistoryInput
    upsert?: MatchSummaryUpsertWithoutPlayerHistoryInput
    connect?: MatchSummaryWhereUniqueInput
    update?: XOR<XOR<MatchSummaryUpdateToOneWithWhereWithoutPlayerHistoryInput, MatchSummaryUpdateWithoutPlayerHistoryInput>, MatchSummaryUncheckedUpdateWithoutPlayerHistoryInput>
  }

  export type TeamUpdateOneWithoutPlayerMatchHistoryNestedInput = {
    create?: XOR<TeamCreateWithoutPlayerMatchHistoryInput, TeamUncheckedCreateWithoutPlayerMatchHistoryInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPlayerMatchHistoryInput
    upsert?: TeamUpsertWithoutPlayerMatchHistoryInput
    disconnect?: boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPlayerMatchHistoryInput, TeamUpdateWithoutPlayerMatchHistoryInput>, TeamUncheckedUpdateWithoutPlayerMatchHistoryInput>
  }

  export type UserCreateNestedOneWithoutFixturesInput = {
    create?: XOR<UserCreateWithoutFixturesInput, UserUncheckedCreateWithoutFixturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFixturesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFixturesNestedInput = {
    create?: XOR<UserCreateWithoutFixturesInput, UserUncheckedCreateWithoutFixturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFixturesInput
    upsert?: UserUpsertWithoutFixturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFixturesInput, UserUpdateWithoutFixturesInput>, UserUncheckedUpdateWithoutFixturesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
    isSet?: boolean
  }

  export type NestedEnumBattingHandNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BattingHand | EnumBattingHandFieldRefInput<$PrismaModel> | null
    in?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBattingHandNullableFilter<$PrismaModel> | $Enums.BattingHand | null
    isSet?: boolean
  }

  export type NestedEnumBowlingStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BowlingStyle | EnumBowlingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBowlingStyleNullableFilter<$PrismaModel> | $Enums.BowlingStyle | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumBattingHandNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BattingHand | EnumBattingHandFieldRefInput<$PrismaModel> | null
    in?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BattingHand[] | ListEnumBattingHandFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBattingHandNullableWithAggregatesFilter<$PrismaModel> | $Enums.BattingHand | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBattingHandNullableFilter<$PrismaModel>
    _max?: NestedEnumBattingHandNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumBowlingStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BowlingStyle | EnumBowlingStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BowlingStyle[] | ListEnumBowlingStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBowlingStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.BowlingStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBowlingStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumBowlingStyleNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumMatchResultNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMatchResultNullableFilter<$PrismaModel> | $Enums.MatchResult | null
    isSet?: boolean
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchResultNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel> | null
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel> | null
    not?: NestedEnumMatchResultNullableWithAggregatesFilter<$PrismaModel> | $Enums.MatchResult | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumMatchResultNullableFilter<$PrismaModel>
    _max?: NestedEnumMatchResultNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumLocalMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LocalMatchStatus | EnumLocalMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLocalMatchStatusFilter<$PrismaModel> | $Enums.LocalMatchStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedEnumLocalMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocalMatchStatus | EnumLocalMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LocalMatchStatus[] | ListEnumLocalMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLocalMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.LocalMatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocalMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumLocalMatchStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumMatchResultFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel>
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchResultFilter<$PrismaModel> | $Enums.MatchResult
  }

  export type NestedEnumMatchResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchResult | EnumMatchResultFieldRefInput<$PrismaModel>
    in?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchResult[] | ListEnumMatchResultFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchResultWithAggregatesFilter<$PrismaModel> | $Enums.MatchResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchResultFilter<$PrismaModel>
    _max?: NestedEnumMatchResultFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type CareerStatsCreateWithoutUserInput = {
    id?: string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    strikeRate?: number
    highestScore?: number
    timesOut?: number
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    economy?: number
    bestBowlingWickets?: number
    bestBowlingRuns?: number
    catchesTaken?: number
    runOuts?: number
    manOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type CareerStatsUncheckedCreateWithoutUserInput = {
    id?: string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    strikeRate?: number
    highestScore?: number
    timesOut?: number
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    economy?: number
    bestBowlingWickets?: number
    bestBowlingRuns?: number
    catchesTaken?: number
    runOuts?: number
    manOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type CareerStatsCreateOrConnectWithoutUserInput = {
    where: CareerStatsWhereUniqueInput
    create: XOR<CareerStatsCreateWithoutUserInput, CareerStatsUncheckedCreateWithoutUserInput>
  }

  export type TeamCreateWithoutCreatedByInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCreatedByInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamCreateManyCreatedByInputEnvelope = {
    data: TeamCreateManyCreatedByInput | TeamCreateManyCreatedByInput[]
  }

  export type TeamCreateWithoutCaptainInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCaptainInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCaptainInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCaptainInput, TeamUncheckedCreateWithoutCaptainInput>
  }

  export type TeamCreateManyCaptainInputEnvelope = {
    data: TeamCreateManyCaptainInput | TeamCreateManyCaptainInput[]
  }

  export type TeamCreateWithoutViceCaptainInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutViceCaptainInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutViceCaptainInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutViceCaptainInput, TeamUncheckedCreateWithoutViceCaptainInput>
  }

  export type TeamCreateManyViceCaptainInputEnvelope = {
    data: TeamCreateManyViceCaptainInput | TeamCreateManyViceCaptainInput[]
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
  }

  export type TeamInvitationCreateWithoutInviterInput = {
    id?: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutInvitationsInput
    invited: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type TeamInvitationUncheckedCreateWithoutInviterInput = {
    id?: string
    teamId: string
    invitedUser: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type TeamInvitationCreateOrConnectWithoutInviterInput = {
    where: TeamInvitationWhereUniqueInput
    create: XOR<TeamInvitationCreateWithoutInviterInput, TeamInvitationUncheckedCreateWithoutInviterInput>
  }

  export type TeamInvitationCreateManyInviterInputEnvelope = {
    data: TeamInvitationCreateManyInviterInput | TeamInvitationCreateManyInviterInput[]
  }

  export type TeamInvitationCreateWithoutInvitedInput = {
    id?: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    team: TeamCreateNestedOneWithoutInvitationsInput
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
  }

  export type TeamInvitationUncheckedCreateWithoutInvitedInput = {
    id?: string
    teamId: string
    invitedBy: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type TeamInvitationCreateOrConnectWithoutInvitedInput = {
    where: TeamInvitationWhereUniqueInput
    create: XOR<TeamInvitationCreateWithoutInvitedInput, TeamInvitationUncheckedCreateWithoutInvitedInput>
  }

  export type TeamInvitationCreateManyInvitedInputEnvelope = {
    data: TeamInvitationCreateManyInvitedInput | TeamInvitationCreateManyInvitedInput[]
  }

  export type GuestPlayerCreateWithoutAddedByInput = {
    id?: string
    name: string
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
    team: TeamCreateNestedOneWithoutGuestPlayersInput
    linkedUser?: UserCreateNestedOneWithoutGuestPlayersLinkedInput
  }

  export type GuestPlayerUncheckedCreateWithoutAddedByInput = {
    id?: string
    teamId: string
    name: string
    linkedUserId?: string | null
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type GuestPlayerCreateOrConnectWithoutAddedByInput = {
    where: GuestPlayerWhereUniqueInput
    create: XOR<GuestPlayerCreateWithoutAddedByInput, GuestPlayerUncheckedCreateWithoutAddedByInput>
  }

  export type GuestPlayerCreateManyAddedByInputEnvelope = {
    data: GuestPlayerCreateManyAddedByInput | GuestPlayerCreateManyAddedByInput[]
  }

  export type GuestPlayerCreateWithoutLinkedUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
    team: TeamCreateNestedOneWithoutGuestPlayersInput
    addedBy: UserCreateNestedOneWithoutGuestPlayersAddedInput
  }

  export type GuestPlayerUncheckedCreateWithoutLinkedUserInput = {
    id?: string
    teamId: string
    name: string
    addedByUserId: string
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type GuestPlayerCreateOrConnectWithoutLinkedUserInput = {
    where: GuestPlayerWhereUniqueInput
    create: XOR<GuestPlayerCreateWithoutLinkedUserInput, GuestPlayerUncheckedCreateWithoutLinkedUserInput>
  }

  export type GuestPlayerCreateManyLinkedUserInputEnvelope = {
    data: GuestPlayerCreateManyLinkedUserInput | GuestPlayerCreateManyLinkedUserInput[]
  }

  export type MatchCreateWithoutUserInput = {
    id?: string
    opponent: string
    matchDate: Date | string
    runsScored: number
    ballsFaced: number
    wasDismissed?: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type MatchUncheckedCreateWithoutUserInput = {
    id?: string
    opponent: string
    matchDate: Date | string
    runsScored: number
    ballsFaced: number
    wasDismissed?: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type MatchCreateOrConnectWithoutUserInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutUserInput, MatchUncheckedCreateWithoutUserInput>
  }

  export type MatchCreateManyUserInputEnvelope = {
    data: MatchCreateManyUserInput | MatchCreateManyUserInput[]
  }

  export type TeamMatchPlayerCreateWithoutUserInput = {
    id?: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
    teamMatch: TeamMatchCreateNestedOneWithoutPlayerStatsInput
    team: TeamCreateNestedOneWithoutTeamMatchStatsInput
  }

  export type TeamMatchPlayerUncheckedCreateWithoutUserInput = {
    id?: string
    teamMatchId: string
    teamId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type TeamMatchPlayerCreateOrConnectWithoutUserInput = {
    where: TeamMatchPlayerWhereUniqueInput
    create: XOR<TeamMatchPlayerCreateWithoutUserInput, TeamMatchPlayerUncheckedCreateWithoutUserInput>
  }

  export type TeamMatchPlayerCreateManyUserInputEnvelope = {
    data: TeamMatchPlayerCreateManyUserInput | TeamMatchPlayerCreateManyUserInput[]
  }

  export type TeamStatisticsCreateWithoutTopRunScorerInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamStatsInput
    topWicketTaker?: UserCreateNestedOneWithoutTopWicketTakerForInput
    bestStrikeRatePlayer?: UserCreateNestedOneWithoutBestStrikeRateForInput
    bestEconomyPlayer?: UserCreateNestedOneWithoutBestEconomyForInput
    mostManOfTheMatchPlayer?: UserCreateNestedOneWithoutMostManOfTheMatchForInput
  }

  export type TeamStatisticsUncheckedCreateWithoutTopRunScorerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateOrConnectWithoutTopRunScorerInput = {
    where: TeamStatisticsWhereUniqueInput
    create: XOR<TeamStatisticsCreateWithoutTopRunScorerInput, TeamStatisticsUncheckedCreateWithoutTopRunScorerInput>
  }

  export type TeamStatisticsCreateManyTopRunScorerInputEnvelope = {
    data: TeamStatisticsCreateManyTopRunScorerInput | TeamStatisticsCreateManyTopRunScorerInput[]
  }

  export type TeamStatisticsCreateWithoutTopWicketTakerInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamStatsInput
    topRunScorer?: UserCreateNestedOneWithoutTopRunScorerForInput
    bestStrikeRatePlayer?: UserCreateNestedOneWithoutBestStrikeRateForInput
    bestEconomyPlayer?: UserCreateNestedOneWithoutBestEconomyForInput
    mostManOfTheMatchPlayer?: UserCreateNestedOneWithoutMostManOfTheMatchForInput
  }

  export type TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateOrConnectWithoutTopWicketTakerInput = {
    where: TeamStatisticsWhereUniqueInput
    create: XOR<TeamStatisticsCreateWithoutTopWicketTakerInput, TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput>
  }

  export type TeamStatisticsCreateManyTopWicketTakerInputEnvelope = {
    data: TeamStatisticsCreateManyTopWicketTakerInput | TeamStatisticsCreateManyTopWicketTakerInput[]
  }

  export type TeamStatisticsCreateWithoutBestStrikeRatePlayerInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamStatsInput
    topRunScorer?: UserCreateNestedOneWithoutTopRunScorerForInput
    topWicketTaker?: UserCreateNestedOneWithoutTopWicketTakerForInput
    bestEconomyPlayer?: UserCreateNestedOneWithoutBestEconomyForInput
    mostManOfTheMatchPlayer?: UserCreateNestedOneWithoutMostManOfTheMatchForInput
  }

  export type TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateOrConnectWithoutBestStrikeRatePlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    create: XOR<TeamStatisticsCreateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput>
  }

  export type TeamStatisticsCreateManyBestStrikeRatePlayerInputEnvelope = {
    data: TeamStatisticsCreateManyBestStrikeRatePlayerInput | TeamStatisticsCreateManyBestStrikeRatePlayerInput[]
  }

  export type TeamStatisticsCreateWithoutBestEconomyPlayerInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamStatsInput
    topRunScorer?: UserCreateNestedOneWithoutTopRunScorerForInput
    topWicketTaker?: UserCreateNestedOneWithoutTopWicketTakerForInput
    bestStrikeRatePlayer?: UserCreateNestedOneWithoutBestStrikeRateForInput
    mostManOfTheMatchPlayer?: UserCreateNestedOneWithoutMostManOfTheMatchForInput
  }

  export type TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateOrConnectWithoutBestEconomyPlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    create: XOR<TeamStatisticsCreateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput>
  }

  export type TeamStatisticsCreateManyBestEconomyPlayerInputEnvelope = {
    data: TeamStatisticsCreateManyBestEconomyPlayerInput | TeamStatisticsCreateManyBestEconomyPlayerInput[]
  }

  export type TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutTeamStatsInput
    topRunScorer?: UserCreateNestedOneWithoutTopRunScorerForInput
    topWicketTaker?: UserCreateNestedOneWithoutTopWicketTakerForInput
    bestStrikeRatePlayer?: UserCreateNestedOneWithoutBestStrikeRateForInput
    bestEconomyPlayer?: UserCreateNestedOneWithoutBestEconomyForInput
  }

  export type TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateOrConnectWithoutMostManOfTheMatchPlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    create: XOR<TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput>
  }

  export type TeamStatisticsCreateManyMostManOfTheMatchPlayerInputEnvelope = {
    data: TeamStatisticsCreateManyMostManOfTheMatchPlayerInput | TeamStatisticsCreateManyMostManOfTheMatchPlayerInput[]
  }

  export type LocalMatchCreateWithoutCreatorInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    myTeam?: TeamCreateNestedOneWithoutLocalMatchesAsMyTeamInput
    opponentTeam?: TeamCreateNestedOneWithoutLocalMatchesAsOpponentInput
    spectators?: MatchSpectatorCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchUncheckedCreateWithoutCreatorInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    spectators?: MatchSpectatorUncheckedCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryUncheckedCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchCreateOrConnectWithoutCreatorInput = {
    where: LocalMatchWhereUniqueInput
    create: XOR<LocalMatchCreateWithoutCreatorInput, LocalMatchUncheckedCreateWithoutCreatorInput>
  }

  export type LocalMatchCreateManyCreatorInputEnvelope = {
    data: LocalMatchCreateManyCreatorInput | LocalMatchCreateManyCreatorInput[]
  }

  export type MatchSpectatorCreateWithoutUserInput = {
    id?: string
    addedAt?: Date | string
    notified?: boolean
    localMatch: LocalMatchCreateNestedOneWithoutSpectatorsInput
    addedByUser: UserCreateNestedOneWithoutAddedSpectatorsInput
  }

  export type MatchSpectatorUncheckedCreateWithoutUserInput = {
    id?: string
    localMatchId: string
    addedBy: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type MatchSpectatorCreateOrConnectWithoutUserInput = {
    where: MatchSpectatorWhereUniqueInput
    create: XOR<MatchSpectatorCreateWithoutUserInput, MatchSpectatorUncheckedCreateWithoutUserInput>
  }

  export type MatchSpectatorCreateManyUserInputEnvelope = {
    data: MatchSpectatorCreateManyUserInput | MatchSpectatorCreateManyUserInput[]
  }

  export type MatchSpectatorCreateWithoutAddedByUserInput = {
    id?: string
    addedAt?: Date | string
    notified?: boolean
    localMatch: LocalMatchCreateNestedOneWithoutSpectatorsInput
    user: UserCreateNestedOneWithoutSpectatorOfInput
  }

  export type MatchSpectatorUncheckedCreateWithoutAddedByUserInput = {
    id?: string
    localMatchId: string
    userId: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type MatchSpectatorCreateOrConnectWithoutAddedByUserInput = {
    where: MatchSpectatorWhereUniqueInput
    create: XOR<MatchSpectatorCreateWithoutAddedByUserInput, MatchSpectatorUncheckedCreateWithoutAddedByUserInput>
  }

  export type MatchSpectatorCreateManyAddedByUserInputEnvelope = {
    data: MatchSpectatorCreateManyAddedByUserInput | MatchSpectatorCreateManyAddedByUserInput[]
  }

  export type MatchSummaryCreateWithoutManOfTheMatchUserInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    awayTeamName: string
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    homeTeam?: TeamCreateNestedOneWithoutMatchSummariesAsHomeInput
    awayTeam?: TeamCreateNestedOneWithoutMatchSummariesAsAwayInput
    playerHistory?: PlayerMatchHistoryCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    homeTeamId?: string | null
    awayTeamName: string
    awayTeamId?: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    playerHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryCreateOrConnectWithoutManOfTheMatchUserInput = {
    where: MatchSummaryWhereUniqueInput
    create: XOR<MatchSummaryCreateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput>
  }

  export type MatchSummaryCreateManyManOfTheMatchUserInputEnvelope = {
    data: MatchSummaryCreateManyManOfTheMatchUserInput | MatchSummaryCreateManyManOfTheMatchUserInput[]
  }

  export type PlayerMatchHistoryCreateWithoutUserInput = {
    id?: string
    teamName: string
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
    matchSummary: MatchSummaryCreateNestedOneWithoutPlayerHistoryInput
    team?: TeamCreateNestedOneWithoutPlayerMatchHistoryInput
  }

  export type PlayerMatchHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    matchSummaryId: string
    teamName: string
    teamId?: string | null
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryCreateOrConnectWithoutUserInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    create: XOR<PlayerMatchHistoryCreateWithoutUserInput, PlayerMatchHistoryUncheckedCreateWithoutUserInput>
  }

  export type PlayerMatchHistoryCreateManyUserInputEnvelope = {
    data: PlayerMatchHistoryCreateManyUserInput | PlayerMatchHistoryCreateManyUserInput[]
  }

  export type FixtureCreateWithoutUserInput = {
    id?: string
    teamAId?: string | null
    teamAName: string
    teamALogo?: string | null
    teamAPlayers: InputJsonValue
    teamBId?: string | null
    teamBName: string
    teamBLogo?: string | null
    teamBPlayers: InputJsonValue
    overs?: number
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixtureUncheckedCreateWithoutUserInput = {
    id?: string
    teamAId?: string | null
    teamAName: string
    teamALogo?: string | null
    teamAPlayers: InputJsonValue
    teamBId?: string | null
    teamBName: string
    teamBLogo?: string | null
    teamBPlayers: InputJsonValue
    overs?: number
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FixtureCreateOrConnectWithoutUserInput = {
    where: FixtureWhereUniqueInput
    create: XOR<FixtureCreateWithoutUserInput, FixtureUncheckedCreateWithoutUserInput>
  }

  export type FixtureCreateManyUserInputEnvelope = {
    data: FixtureCreateManyUserInput | FixtureCreateManyUserInput[]
  }

  export type CareerStatsUpsertWithoutUserInput = {
    update: XOR<CareerStatsUpdateWithoutUserInput, CareerStatsUncheckedUpdateWithoutUserInput>
    create: XOR<CareerStatsCreateWithoutUserInput, CareerStatsUncheckedCreateWithoutUserInput>
    where?: CareerStatsWhereInput
  }

  export type CareerStatsUpdateToOneWithWhereWithoutUserInput = {
    where?: CareerStatsWhereInput
    data: XOR<CareerStatsUpdateWithoutUserInput, CareerStatsUncheckedUpdateWithoutUserInput>
  }

  export type CareerStatsUpdateWithoutUserInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    strikeRate?: FloatFieldUpdateOperationsInput | number
    highestScore?: IntFieldUpdateOperationsInput | number
    timesOut?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    economy?: FloatFieldUpdateOperationsInput | number
    bestBowlingWickets?: IntFieldUpdateOperationsInput | number
    bestBowlingRuns?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    manOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CareerStatsUncheckedUpdateWithoutUserInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    strikeRate?: FloatFieldUpdateOperationsInput | number
    highestScore?: IntFieldUpdateOperationsInput | number
    timesOut?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    economy?: FloatFieldUpdateOperationsInput | number
    bestBowlingWickets?: IntFieldUpdateOperationsInput | number
    bestBowlingRuns?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    manOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutCreatedByInput, TeamUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutCreatedByInput, TeamUncheckedUpdateWithoutCreatedByInput>
  }

  export type TeamUpdateManyWithWhereWithoutCreatedByInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    teamCode?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    logoUrl?: StringNullableFilter<"Team"> | string | null
    createdById?: StringFilter<"Team"> | string
    captainId?: StringNullableFilter<"Team"> | string | null
    viceCaptainId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutCaptainInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutCaptainInput, TeamUncheckedUpdateWithoutCaptainInput>
    create: XOR<TeamCreateWithoutCaptainInput, TeamUncheckedCreateWithoutCaptainInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutCaptainInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutCaptainInput, TeamUncheckedUpdateWithoutCaptainInput>
  }

  export type TeamUpdateManyWithWhereWithoutCaptainInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutCaptainInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutViceCaptainInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutViceCaptainInput, TeamUncheckedUpdateWithoutViceCaptainInput>
    create: XOR<TeamCreateWithoutViceCaptainInput, TeamUncheckedCreateWithoutViceCaptainInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutViceCaptainInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutViceCaptainInput, TeamUncheckedUpdateWithoutViceCaptainInput>
  }

  export type TeamUpdateManyWithWhereWithoutViceCaptainInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutViceCaptainInput>
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type TeamInvitationUpsertWithWhereUniqueWithoutInviterInput = {
    where: TeamInvitationWhereUniqueInput
    update: XOR<TeamInvitationUpdateWithoutInviterInput, TeamInvitationUncheckedUpdateWithoutInviterInput>
    create: XOR<TeamInvitationCreateWithoutInviterInput, TeamInvitationUncheckedCreateWithoutInviterInput>
  }

  export type TeamInvitationUpdateWithWhereUniqueWithoutInviterInput = {
    where: TeamInvitationWhereUniqueInput
    data: XOR<TeamInvitationUpdateWithoutInviterInput, TeamInvitationUncheckedUpdateWithoutInviterInput>
  }

  export type TeamInvitationUpdateManyWithWhereWithoutInviterInput = {
    where: TeamInvitationScalarWhereInput
    data: XOR<TeamInvitationUpdateManyMutationInput, TeamInvitationUncheckedUpdateManyWithoutInviterInput>
  }

  export type TeamInvitationScalarWhereInput = {
    AND?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
    OR?: TeamInvitationScalarWhereInput[]
    NOT?: TeamInvitationScalarWhereInput | TeamInvitationScalarWhereInput[]
    id?: StringFilter<"TeamInvitation"> | string
    teamId?: StringFilter<"TeamInvitation"> | string
    invitedBy?: StringFilter<"TeamInvitation"> | string
    invitedUser?: StringFilter<"TeamInvitation"> | string
    status?: EnumInvitationStatusFilter<"TeamInvitation"> | $Enums.InvitationStatus
    createdAt?: DateTimeFilter<"TeamInvitation"> | Date | string
  }

  export type TeamInvitationUpsertWithWhereUniqueWithoutInvitedInput = {
    where: TeamInvitationWhereUniqueInput
    update: XOR<TeamInvitationUpdateWithoutInvitedInput, TeamInvitationUncheckedUpdateWithoutInvitedInput>
    create: XOR<TeamInvitationCreateWithoutInvitedInput, TeamInvitationUncheckedCreateWithoutInvitedInput>
  }

  export type TeamInvitationUpdateWithWhereUniqueWithoutInvitedInput = {
    where: TeamInvitationWhereUniqueInput
    data: XOR<TeamInvitationUpdateWithoutInvitedInput, TeamInvitationUncheckedUpdateWithoutInvitedInput>
  }

  export type TeamInvitationUpdateManyWithWhereWithoutInvitedInput = {
    where: TeamInvitationScalarWhereInput
    data: XOR<TeamInvitationUpdateManyMutationInput, TeamInvitationUncheckedUpdateManyWithoutInvitedInput>
  }

  export type GuestPlayerUpsertWithWhereUniqueWithoutAddedByInput = {
    where: GuestPlayerWhereUniqueInput
    update: XOR<GuestPlayerUpdateWithoutAddedByInput, GuestPlayerUncheckedUpdateWithoutAddedByInput>
    create: XOR<GuestPlayerCreateWithoutAddedByInput, GuestPlayerUncheckedCreateWithoutAddedByInput>
  }

  export type GuestPlayerUpdateWithWhereUniqueWithoutAddedByInput = {
    where: GuestPlayerWhereUniqueInput
    data: XOR<GuestPlayerUpdateWithoutAddedByInput, GuestPlayerUncheckedUpdateWithoutAddedByInput>
  }

  export type GuestPlayerUpdateManyWithWhereWithoutAddedByInput = {
    where: GuestPlayerScalarWhereInput
    data: XOR<GuestPlayerUpdateManyMutationInput, GuestPlayerUncheckedUpdateManyWithoutAddedByInput>
  }

  export type GuestPlayerScalarWhereInput = {
    AND?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
    OR?: GuestPlayerScalarWhereInput[]
    NOT?: GuestPlayerScalarWhereInput | GuestPlayerScalarWhereInput[]
    id?: StringFilter<"GuestPlayer"> | string
    teamId?: StringFilter<"GuestPlayer"> | string
    name?: StringFilter<"GuestPlayer"> | string
    addedByUserId?: StringFilter<"GuestPlayer"> | string
    linkedUserId?: StringNullableFilter<"GuestPlayer"> | string | null
    createdAt?: DateTimeFilter<"GuestPlayer"> | Date | string
    matchesPlayed?: IntFilter<"GuestPlayer"> | number
    totalRuns?: IntFilter<"GuestPlayer"> | number
    ballsFaced?: IntFilter<"GuestPlayer"> | number
    fours?: IntFilter<"GuestPlayer"> | number
    sixes?: IntFilter<"GuestPlayer"> | number
    wicketsTaken?: IntFilter<"GuestPlayer"> | number
    runsConceded?: IntFilter<"GuestPlayer"> | number
    oversBowled?: FloatFilter<"GuestPlayer"> | number
    catchesTaken?: IntFilter<"GuestPlayer"> | number
    runOuts?: IntFilter<"GuestPlayer"> | number
  }

  export type GuestPlayerUpsertWithWhereUniqueWithoutLinkedUserInput = {
    where: GuestPlayerWhereUniqueInput
    update: XOR<GuestPlayerUpdateWithoutLinkedUserInput, GuestPlayerUncheckedUpdateWithoutLinkedUserInput>
    create: XOR<GuestPlayerCreateWithoutLinkedUserInput, GuestPlayerUncheckedCreateWithoutLinkedUserInput>
  }

  export type GuestPlayerUpdateWithWhereUniqueWithoutLinkedUserInput = {
    where: GuestPlayerWhereUniqueInput
    data: XOR<GuestPlayerUpdateWithoutLinkedUserInput, GuestPlayerUncheckedUpdateWithoutLinkedUserInput>
  }

  export type GuestPlayerUpdateManyWithWhereWithoutLinkedUserInput = {
    where: GuestPlayerScalarWhereInput
    data: XOR<GuestPlayerUpdateManyMutationInput, GuestPlayerUncheckedUpdateManyWithoutLinkedUserInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutUserInput, MatchUncheckedUpdateWithoutUserInput>
    create: XOR<MatchCreateWithoutUserInput, MatchUncheckedCreateWithoutUserInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutUserInput, MatchUncheckedUpdateWithoutUserInput>
  }

  export type MatchUpdateManyWithWhereWithoutUserInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: StringFilter<"Match"> | string
    userId?: StringFilter<"Match"> | string
    opponent?: StringFilter<"Match"> | string
    matchDate?: DateTimeFilter<"Match"> | Date | string
    runsScored?: IntFilter<"Match"> | number
    ballsFaced?: IntFilter<"Match"> | number
    wasDismissed?: BoolFilter<"Match"> | boolean
    oversBowled?: FloatFilter<"Match"> | number
    runsConceded?: IntFilter<"Match"> | number
    wicketsTaken?: IntFilter<"Match"> | number
    catchesTaken?: IntFilter<"Match"> | number
    runOuts?: IntFilter<"Match"> | number
    isManOfTheMatch?: BoolFilter<"Match"> | boolean
    createdAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type TeamMatchPlayerUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMatchPlayerWhereUniqueInput
    update: XOR<TeamMatchPlayerUpdateWithoutUserInput, TeamMatchPlayerUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMatchPlayerCreateWithoutUserInput, TeamMatchPlayerUncheckedCreateWithoutUserInput>
  }

  export type TeamMatchPlayerUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMatchPlayerWhereUniqueInput
    data: XOR<TeamMatchPlayerUpdateWithoutUserInput, TeamMatchPlayerUncheckedUpdateWithoutUserInput>
  }

  export type TeamMatchPlayerUpdateManyWithWhereWithoutUserInput = {
    where: TeamMatchPlayerScalarWhereInput
    data: XOR<TeamMatchPlayerUpdateManyMutationInput, TeamMatchPlayerUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMatchPlayerScalarWhereInput = {
    AND?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
    OR?: TeamMatchPlayerScalarWhereInput[]
    NOT?: TeamMatchPlayerScalarWhereInput | TeamMatchPlayerScalarWhereInput[]
    id?: StringFilter<"TeamMatchPlayer"> | string
    teamMatchId?: StringFilter<"TeamMatchPlayer"> | string
    userId?: StringFilter<"TeamMatchPlayer"> | string
    teamId?: StringFilter<"TeamMatchPlayer"> | string
    runsScored?: IntFilter<"TeamMatchPlayer"> | number
    ballsFaced?: IntFilter<"TeamMatchPlayer"> | number
    wasDismissed?: BoolFilter<"TeamMatchPlayer"> | boolean
    oversBowled?: FloatFilter<"TeamMatchPlayer"> | number
    runsConceded?: IntFilter<"TeamMatchPlayer"> | number
    wicketsTaken?: IntFilter<"TeamMatchPlayer"> | number
    catchesTaken?: IntFilter<"TeamMatchPlayer"> | number
  }

  export type TeamStatisticsUpsertWithWhereUniqueWithoutTopRunScorerInput = {
    where: TeamStatisticsWhereUniqueInput
    update: XOR<TeamStatisticsUpdateWithoutTopRunScorerInput, TeamStatisticsUncheckedUpdateWithoutTopRunScorerInput>
    create: XOR<TeamStatisticsCreateWithoutTopRunScorerInput, TeamStatisticsUncheckedCreateWithoutTopRunScorerInput>
  }

  export type TeamStatisticsUpdateWithWhereUniqueWithoutTopRunScorerInput = {
    where: TeamStatisticsWhereUniqueInput
    data: XOR<TeamStatisticsUpdateWithoutTopRunScorerInput, TeamStatisticsUncheckedUpdateWithoutTopRunScorerInput>
  }

  export type TeamStatisticsUpdateManyWithWhereWithoutTopRunScorerInput = {
    where: TeamStatisticsScalarWhereInput
    data: XOR<TeamStatisticsUpdateManyMutationInput, TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerInput>
  }

  export type TeamStatisticsScalarWhereInput = {
    AND?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
    OR?: TeamStatisticsScalarWhereInput[]
    NOT?: TeamStatisticsScalarWhereInput | TeamStatisticsScalarWhereInput[]
    id?: StringFilter<"TeamStatistics"> | string
    teamId?: StringFilter<"TeamStatistics"> | string
    matchesPlayed?: IntFilter<"TeamStatistics"> | number
    matchesWon?: IntFilter<"TeamStatistics"> | number
    matchesLost?: IntFilter<"TeamStatistics"> | number
    matchesDrawn?: IntFilter<"TeamStatistics"> | number
    winRatio?: FloatFilter<"TeamStatistics"> | number
    topRunScorerId?: StringNullableFilter<"TeamStatistics"> | string | null
    topRunScorerRuns?: IntFilter<"TeamStatistics"> | number
    topWicketTakerId?: StringNullableFilter<"TeamStatistics"> | string | null
    topWicketTakerWickets?: IntFilter<"TeamStatistics"> | number
    bestStrikeRatePlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    bestStrikeRate?: FloatFilter<"TeamStatistics"> | number
    bestEconomyPlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    bestEconomy?: FloatFilter<"TeamStatistics"> | number
    mostManOfTheMatchPlayerId?: StringNullableFilter<"TeamStatistics"> | string | null
    mostManOfTheMatchAwards?: IntFilter<"TeamStatistics"> | number
    updatedAt?: DateTimeFilter<"TeamStatistics"> | Date | string
  }

  export type TeamStatisticsUpsertWithWhereUniqueWithoutTopWicketTakerInput = {
    where: TeamStatisticsWhereUniqueInput
    update: XOR<TeamStatisticsUpdateWithoutTopWicketTakerInput, TeamStatisticsUncheckedUpdateWithoutTopWicketTakerInput>
    create: XOR<TeamStatisticsCreateWithoutTopWicketTakerInput, TeamStatisticsUncheckedCreateWithoutTopWicketTakerInput>
  }

  export type TeamStatisticsUpdateWithWhereUniqueWithoutTopWicketTakerInput = {
    where: TeamStatisticsWhereUniqueInput
    data: XOR<TeamStatisticsUpdateWithoutTopWicketTakerInput, TeamStatisticsUncheckedUpdateWithoutTopWicketTakerInput>
  }

  export type TeamStatisticsUpdateManyWithWhereWithoutTopWicketTakerInput = {
    where: TeamStatisticsScalarWhereInput
    data: XOR<TeamStatisticsUpdateManyMutationInput, TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerInput>
  }

  export type TeamStatisticsUpsertWithWhereUniqueWithoutBestStrikeRatePlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    update: XOR<TeamStatisticsUpdateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedUpdateWithoutBestStrikeRatePlayerInput>
    create: XOR<TeamStatisticsCreateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedCreateWithoutBestStrikeRatePlayerInput>
  }

  export type TeamStatisticsUpdateWithWhereUniqueWithoutBestStrikeRatePlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    data: XOR<TeamStatisticsUpdateWithoutBestStrikeRatePlayerInput, TeamStatisticsUncheckedUpdateWithoutBestStrikeRatePlayerInput>
  }

  export type TeamStatisticsUpdateManyWithWhereWithoutBestStrikeRatePlayerInput = {
    where: TeamStatisticsScalarWhereInput
    data: XOR<TeamStatisticsUpdateManyMutationInput, TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerInput>
  }

  export type TeamStatisticsUpsertWithWhereUniqueWithoutBestEconomyPlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    update: XOR<TeamStatisticsUpdateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedUpdateWithoutBestEconomyPlayerInput>
    create: XOR<TeamStatisticsCreateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedCreateWithoutBestEconomyPlayerInput>
  }

  export type TeamStatisticsUpdateWithWhereUniqueWithoutBestEconomyPlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    data: XOR<TeamStatisticsUpdateWithoutBestEconomyPlayerInput, TeamStatisticsUncheckedUpdateWithoutBestEconomyPlayerInput>
  }

  export type TeamStatisticsUpdateManyWithWhereWithoutBestEconomyPlayerInput = {
    where: TeamStatisticsScalarWhereInput
    data: XOR<TeamStatisticsUpdateManyMutationInput, TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerInput>
  }

  export type TeamStatisticsUpsertWithWhereUniqueWithoutMostManOfTheMatchPlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    update: XOR<TeamStatisticsUpdateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedUpdateWithoutMostManOfTheMatchPlayerInput>
    create: XOR<TeamStatisticsCreateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedCreateWithoutMostManOfTheMatchPlayerInput>
  }

  export type TeamStatisticsUpdateWithWhereUniqueWithoutMostManOfTheMatchPlayerInput = {
    where: TeamStatisticsWhereUniqueInput
    data: XOR<TeamStatisticsUpdateWithoutMostManOfTheMatchPlayerInput, TeamStatisticsUncheckedUpdateWithoutMostManOfTheMatchPlayerInput>
  }

  export type TeamStatisticsUpdateManyWithWhereWithoutMostManOfTheMatchPlayerInput = {
    where: TeamStatisticsScalarWhereInput
    data: XOR<TeamStatisticsUpdateManyMutationInput, TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerInput>
  }

  export type LocalMatchUpsertWithWhereUniqueWithoutCreatorInput = {
    where: LocalMatchWhereUniqueInput
    update: XOR<LocalMatchUpdateWithoutCreatorInput, LocalMatchUncheckedUpdateWithoutCreatorInput>
    create: XOR<LocalMatchCreateWithoutCreatorInput, LocalMatchUncheckedCreateWithoutCreatorInput>
  }

  export type LocalMatchUpdateWithWhereUniqueWithoutCreatorInput = {
    where: LocalMatchWhereUniqueInput
    data: XOR<LocalMatchUpdateWithoutCreatorInput, LocalMatchUncheckedUpdateWithoutCreatorInput>
  }

  export type LocalMatchUpdateManyWithWhereWithoutCreatorInput = {
    where: LocalMatchScalarWhereInput
    data: XOR<LocalMatchUpdateManyMutationInput, LocalMatchUncheckedUpdateManyWithoutCreatorInput>
  }

  export type LocalMatchScalarWhereInput = {
    AND?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
    OR?: LocalMatchScalarWhereInput[]
    NOT?: LocalMatchScalarWhereInput | LocalMatchScalarWhereInput[]
    id?: StringFilter<"LocalMatch"> | string
    creatorId?: StringFilter<"LocalMatch"> | string
    matchName?: StringFilter<"LocalMatch"> | string
    venue?: StringFilter<"LocalMatch"> | string
    matchDate?: DateTimeFilter<"LocalMatch"> | Date | string
    overs?: IntFilter<"LocalMatch"> | number
    myTeamName?: StringNullableFilter<"LocalMatch"> | string | null
    myTeamId?: StringNullableFilter<"LocalMatch"> | string | null
    opponentTeamName?: StringNullableFilter<"LocalMatch"> | string | null
    opponentTeamId?: StringNullableFilter<"LocalMatch"> | string | null
    myTeamPlayers?: JsonFilter<"LocalMatch">
    opponentTeamPlayers?: JsonFilter<"LocalMatch">
    allowSpectators?: BoolFilter<"LocalMatch"> | boolean
    isRoomMatch?: BoolFilter<"LocalMatch"> | boolean
    roomPassword?: StringNullableFilter<"LocalMatch"> | string | null
    status?: EnumLocalMatchStatusFilter<"LocalMatch"> | $Enums.LocalMatchStatus
    currentInnings?: IntFilter<"LocalMatch"> | number
    currentOver?: IntFilter<"LocalMatch"> | number
    currentBall?: IntFilter<"LocalMatch"> | number
    myTeamScore?: IntFilter<"LocalMatch"> | number
    myTeamWickets?: IntFilter<"LocalMatch"> | number
    myTeamOvers?: FloatFilter<"LocalMatch"> | number
    opponentTeamScore?: IntFilter<"LocalMatch"> | number
    opponentTeamWickets?: IntFilter<"LocalMatch"> | number
    opponentTeamOvers?: FloatFilter<"LocalMatch"> | number
    fullState?: JsonNullableFilter<"LocalMatch">
    createdAt?: DateTimeFilter<"LocalMatch"> | Date | string
    updatedAt?: DateTimeFilter<"LocalMatch"> | Date | string
  }

  export type MatchSpectatorUpsertWithWhereUniqueWithoutUserInput = {
    where: MatchSpectatorWhereUniqueInput
    update: XOR<MatchSpectatorUpdateWithoutUserInput, MatchSpectatorUncheckedUpdateWithoutUserInput>
    create: XOR<MatchSpectatorCreateWithoutUserInput, MatchSpectatorUncheckedCreateWithoutUserInput>
  }

  export type MatchSpectatorUpdateWithWhereUniqueWithoutUserInput = {
    where: MatchSpectatorWhereUniqueInput
    data: XOR<MatchSpectatorUpdateWithoutUserInput, MatchSpectatorUncheckedUpdateWithoutUserInput>
  }

  export type MatchSpectatorUpdateManyWithWhereWithoutUserInput = {
    where: MatchSpectatorScalarWhereInput
    data: XOR<MatchSpectatorUpdateManyMutationInput, MatchSpectatorUncheckedUpdateManyWithoutUserInput>
  }

  export type MatchSpectatorScalarWhereInput = {
    AND?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
    OR?: MatchSpectatorScalarWhereInput[]
    NOT?: MatchSpectatorScalarWhereInput | MatchSpectatorScalarWhereInput[]
    id?: StringFilter<"MatchSpectator"> | string
    localMatchId?: StringFilter<"MatchSpectator"> | string
    userId?: StringFilter<"MatchSpectator"> | string
    addedBy?: StringFilter<"MatchSpectator"> | string
    addedAt?: DateTimeFilter<"MatchSpectator"> | Date | string
    notified?: BoolFilter<"MatchSpectator"> | boolean
  }

  export type MatchSpectatorUpsertWithWhereUniqueWithoutAddedByUserInput = {
    where: MatchSpectatorWhereUniqueInput
    update: XOR<MatchSpectatorUpdateWithoutAddedByUserInput, MatchSpectatorUncheckedUpdateWithoutAddedByUserInput>
    create: XOR<MatchSpectatorCreateWithoutAddedByUserInput, MatchSpectatorUncheckedCreateWithoutAddedByUserInput>
  }

  export type MatchSpectatorUpdateWithWhereUniqueWithoutAddedByUserInput = {
    where: MatchSpectatorWhereUniqueInput
    data: XOR<MatchSpectatorUpdateWithoutAddedByUserInput, MatchSpectatorUncheckedUpdateWithoutAddedByUserInput>
  }

  export type MatchSpectatorUpdateManyWithWhereWithoutAddedByUserInput = {
    where: MatchSpectatorScalarWhereInput
    data: XOR<MatchSpectatorUpdateManyMutationInput, MatchSpectatorUncheckedUpdateManyWithoutAddedByUserInput>
  }

  export type MatchSummaryUpsertWithWhereUniqueWithoutManOfTheMatchUserInput = {
    where: MatchSummaryWhereUniqueInput
    update: XOR<MatchSummaryUpdateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedUpdateWithoutManOfTheMatchUserInput>
    create: XOR<MatchSummaryCreateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedCreateWithoutManOfTheMatchUserInput>
  }

  export type MatchSummaryUpdateWithWhereUniqueWithoutManOfTheMatchUserInput = {
    where: MatchSummaryWhereUniqueInput
    data: XOR<MatchSummaryUpdateWithoutManOfTheMatchUserInput, MatchSummaryUncheckedUpdateWithoutManOfTheMatchUserInput>
  }

  export type MatchSummaryUpdateManyWithWhereWithoutManOfTheMatchUserInput = {
    where: MatchSummaryScalarWhereInput
    data: XOR<MatchSummaryUpdateManyMutationInput, MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserInput>
  }

  export type MatchSummaryScalarWhereInput = {
    AND?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
    OR?: MatchSummaryScalarWhereInput[]
    NOT?: MatchSummaryScalarWhereInput | MatchSummaryScalarWhereInput[]
    id?: StringFilter<"MatchSummary"> | string
    matchDate?: DateTimeFilter<"MatchSummary"> | Date | string
    venue?: StringFilter<"MatchSummary"> | string
    homeTeamName?: StringFilter<"MatchSummary"> | string
    homeTeamId?: StringNullableFilter<"MatchSummary"> | string | null
    awayTeamName?: StringFilter<"MatchSummary"> | string
    awayTeamId?: StringNullableFilter<"MatchSummary"> | string | null
    result?: EnumMatchResultFilter<"MatchSummary"> | $Enums.MatchResult
    winningTeam?: StringFilter<"MatchSummary"> | string
    firstInningsTeam?: StringFilter<"MatchSummary"> | string
    firstInningsRuns?: IntFilter<"MatchSummary"> | number
    firstInningsWickets?: IntFilter<"MatchSummary"> | number
    firstInningsOvers?: FloatFilter<"MatchSummary"> | number
    secondInningsTeam?: StringFilter<"MatchSummary"> | string
    secondInningsRuns?: IntFilter<"MatchSummary"> | number
    secondInningsWickets?: IntFilter<"MatchSummary"> | number
    secondInningsOvers?: FloatFilter<"MatchSummary"> | number
    target?: IntNullableFilter<"MatchSummary"> | number | null
    totalOvers?: IntFilter<"MatchSummary"> | number
    manOfTheMatchPlayerName?: StringNullableFilter<"MatchSummary"> | string | null
    manOfTheMatchUserId?: StringNullableFilter<"MatchSummary"> | string | null
    manOfTheMatchStats?: JsonNullableFilter<"MatchSummary">
    firstInningsBatsmen?: JsonFilter<"MatchSummary">
    firstInningsBowlers?: JsonFilter<"MatchSummary">
    secondInningsBatsmen?: JsonFilter<"MatchSummary">
    secondInningsBowlers?: JsonFilter<"MatchSummary">
    createdAt?: DateTimeFilter<"MatchSummary"> | Date | string
  }

  export type PlayerMatchHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    update: XOR<PlayerMatchHistoryUpdateWithoutUserInput, PlayerMatchHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<PlayerMatchHistoryCreateWithoutUserInput, PlayerMatchHistoryUncheckedCreateWithoutUserInput>
  }

  export type PlayerMatchHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    data: XOR<PlayerMatchHistoryUpdateWithoutUserInput, PlayerMatchHistoryUncheckedUpdateWithoutUserInput>
  }

  export type PlayerMatchHistoryUpdateManyWithWhereWithoutUserInput = {
    where: PlayerMatchHistoryScalarWhereInput
    data: XOR<PlayerMatchHistoryUpdateManyMutationInput, PlayerMatchHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type PlayerMatchHistoryScalarWhereInput = {
    AND?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
    OR?: PlayerMatchHistoryScalarWhereInput[]
    NOT?: PlayerMatchHistoryScalarWhereInput | PlayerMatchHistoryScalarWhereInput[]
    id?: StringFilter<"PlayerMatchHistory"> | string
    userId?: StringFilter<"PlayerMatchHistory"> | string
    matchSummaryId?: StringFilter<"PlayerMatchHistory"> | string
    teamName?: StringFilter<"PlayerMatchHistory"> | string
    teamId?: StringNullableFilter<"PlayerMatchHistory"> | string | null
    playerName?: StringFilter<"PlayerMatchHistory"> | string
    runsScored?: IntFilter<"PlayerMatchHistory"> | number
    ballsFaced?: IntFilter<"PlayerMatchHistory"> | number
    wicketsTaken?: IntFilter<"PlayerMatchHistory"> | number
    oversBowled?: FloatFilter<"PlayerMatchHistory"> | number
    isManOfTheMatch?: BoolFilter<"PlayerMatchHistory"> | boolean
    createdAt?: DateTimeFilter<"PlayerMatchHistory"> | Date | string
  }

  export type FixtureUpsertWithWhereUniqueWithoutUserInput = {
    where: FixtureWhereUniqueInput
    update: XOR<FixtureUpdateWithoutUserInput, FixtureUncheckedUpdateWithoutUserInput>
    create: XOR<FixtureCreateWithoutUserInput, FixtureUncheckedCreateWithoutUserInput>
  }

  export type FixtureUpdateWithWhereUniqueWithoutUserInput = {
    where: FixtureWhereUniqueInput
    data: XOR<FixtureUpdateWithoutUserInput, FixtureUncheckedUpdateWithoutUserInput>
  }

  export type FixtureUpdateManyWithWhereWithoutUserInput = {
    where: FixtureScalarWhereInput
    data: XOR<FixtureUpdateManyMutationInput, FixtureUncheckedUpdateManyWithoutUserInput>
  }

  export type FixtureScalarWhereInput = {
    AND?: FixtureScalarWhereInput | FixtureScalarWhereInput[]
    OR?: FixtureScalarWhereInput[]
    NOT?: FixtureScalarWhereInput | FixtureScalarWhereInput[]
    id?: StringFilter<"Fixture"> | string
    userId?: StringFilter<"Fixture"> | string
    teamAId?: StringNullableFilter<"Fixture"> | string | null
    teamAName?: StringFilter<"Fixture"> | string
    teamALogo?: StringNullableFilter<"Fixture"> | string | null
    teamAPlayers?: JsonFilter<"Fixture">
    teamBId?: StringNullableFilter<"Fixture"> | string | null
    teamBName?: StringFilter<"Fixture"> | string
    teamBLogo?: StringNullableFilter<"Fixture"> | string | null
    teamBPlayers?: JsonFilter<"Fixture">
    overs?: IntFilter<"Fixture"> | number
    venue?: StringNullableFilter<"Fixture"> | string | null
    createdAt?: DateTimeFilter<"Fixture"> | Date | string
    updatedAt?: DateTimeFilter<"Fixture"> | Date | string
  }

  export type UserCreateWithoutCareerStatsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCareerStatsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCareerStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCareerStatsInput, UserUncheckedCreateWithoutCareerStatsInput>
  }

  export type UserUpsertWithoutCareerStatsInput = {
    update: XOR<UserUpdateWithoutCareerStatsInput, UserUncheckedUpdateWithoutCareerStatsInput>
    create: XOR<UserCreateWithoutCareerStatsInput, UserUncheckedCreateWithoutCareerStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCareerStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCareerStatsInput, UserUncheckedUpdateWithoutCareerStatsInput>
  }

  export type UserUpdateWithoutCareerStatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCareerStatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedTeamsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedTeamsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
  }

  export type UserCreateWithoutCaptainOfTeamsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCaptainOfTeamsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCaptainOfTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCaptainOfTeamsInput, UserUncheckedCreateWithoutCaptainOfTeamsInput>
  }

  export type UserCreateWithoutViceCaptainOfTeamsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutViceCaptainOfTeamsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutViceCaptainOfTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViceCaptainOfTeamsInput, UserUncheckedCreateWithoutViceCaptainOfTeamsInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
  }

  export type GuestPlayerCreateWithoutTeamInput = {
    id?: string
    name: string
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
    addedBy: UserCreateNestedOneWithoutGuestPlayersAddedInput
    linkedUser?: UserCreateNestedOneWithoutGuestPlayersLinkedInput
  }

  export type GuestPlayerUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    addedByUserId: string
    linkedUserId?: string | null
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type GuestPlayerCreateOrConnectWithoutTeamInput = {
    where: GuestPlayerWhereUniqueInput
    create: XOR<GuestPlayerCreateWithoutTeamInput, GuestPlayerUncheckedCreateWithoutTeamInput>
  }

  export type GuestPlayerCreateManyTeamInputEnvelope = {
    data: GuestPlayerCreateManyTeamInput | GuestPlayerCreateManyTeamInput[]
  }

  export type TeamInvitationCreateWithoutTeamInput = {
    id?: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
    inviter: UserCreateNestedOneWithoutSentInvitationsInput
    invited: UserCreateNestedOneWithoutReceivedInvitationsInput
  }

  export type TeamInvitationUncheckedCreateWithoutTeamInput = {
    id?: string
    invitedBy: string
    invitedUser: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type TeamInvitationCreateOrConnectWithoutTeamInput = {
    where: TeamInvitationWhereUniqueInput
    create: XOR<TeamInvitationCreateWithoutTeamInput, TeamInvitationUncheckedCreateWithoutTeamInput>
  }

  export type TeamInvitationCreateManyTeamInputEnvelope = {
    data: TeamInvitationCreateManyTeamInput | TeamInvitationCreateManyTeamInput[]
  }

  export type TeamMatchCreateWithoutHomeTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
    awayTeam: TeamCreateNestedOneWithoutAwayMatchesInput
    playerStats?: TeamMatchPlayerCreateNestedManyWithoutTeamMatchInput
  }

  export type TeamMatchUncheckedCreateWithoutHomeTeamInput = {
    id?: string
    awayTeamId: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
    playerStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamMatchInput
  }

  export type TeamMatchCreateOrConnectWithoutHomeTeamInput = {
    where: TeamMatchWhereUniqueInput
    create: XOR<TeamMatchCreateWithoutHomeTeamInput, TeamMatchUncheckedCreateWithoutHomeTeamInput>
  }

  export type TeamMatchCreateManyHomeTeamInputEnvelope = {
    data: TeamMatchCreateManyHomeTeamInput | TeamMatchCreateManyHomeTeamInput[]
  }

  export type TeamMatchCreateWithoutAwayTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
    homeTeam: TeamCreateNestedOneWithoutHomeMatchesInput
    playerStats?: TeamMatchPlayerCreateNestedManyWithoutTeamMatchInput
  }

  export type TeamMatchUncheckedCreateWithoutAwayTeamInput = {
    id?: string
    homeTeamId: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
    playerStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamMatchInput
  }

  export type TeamMatchCreateOrConnectWithoutAwayTeamInput = {
    where: TeamMatchWhereUniqueInput
    create: XOR<TeamMatchCreateWithoutAwayTeamInput, TeamMatchUncheckedCreateWithoutAwayTeamInput>
  }

  export type TeamMatchCreateManyAwayTeamInputEnvelope = {
    data: TeamMatchCreateManyAwayTeamInput | TeamMatchCreateManyAwayTeamInput[]
  }

  export type TeamStatisticsCreateWithoutTeamInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
    topRunScorer?: UserCreateNestedOneWithoutTopRunScorerForInput
    topWicketTaker?: UserCreateNestedOneWithoutTopWicketTakerForInput
    bestStrikeRatePlayer?: UserCreateNestedOneWithoutBestStrikeRateForInput
    bestEconomyPlayer?: UserCreateNestedOneWithoutBestEconomyForInput
    mostManOfTheMatchPlayer?: UserCreateNestedOneWithoutMostManOfTheMatchForInput
  }

  export type TeamStatisticsUncheckedCreateWithoutTeamInput = {
    id?: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateOrConnectWithoutTeamInput = {
    where: TeamStatisticsWhereUniqueInput
    create: XOR<TeamStatisticsCreateWithoutTeamInput, TeamStatisticsUncheckedCreateWithoutTeamInput>
  }

  export type TeamMatchPlayerCreateWithoutTeamInput = {
    id?: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
    teamMatch: TeamMatchCreateNestedOneWithoutPlayerStatsInput
    user: UserCreateNestedOneWithoutTeamMatchStatsInput
  }

  export type TeamMatchPlayerUncheckedCreateWithoutTeamInput = {
    id?: string
    teamMatchId: string
    userId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type TeamMatchPlayerCreateOrConnectWithoutTeamInput = {
    where: TeamMatchPlayerWhereUniqueInput
    create: XOR<TeamMatchPlayerCreateWithoutTeamInput, TeamMatchPlayerUncheckedCreateWithoutTeamInput>
  }

  export type TeamMatchPlayerCreateManyTeamInputEnvelope = {
    data: TeamMatchPlayerCreateManyTeamInput | TeamMatchPlayerCreateManyTeamInput[]
  }

  export type LocalMatchCreateWithoutMyTeamInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedLocalMatchesInput
    opponentTeam?: TeamCreateNestedOneWithoutLocalMatchesAsOpponentInput
    spectators?: MatchSpectatorCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchUncheckedCreateWithoutMyTeamInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    spectators?: MatchSpectatorUncheckedCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryUncheckedCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchCreateOrConnectWithoutMyTeamInput = {
    where: LocalMatchWhereUniqueInput
    create: XOR<LocalMatchCreateWithoutMyTeamInput, LocalMatchUncheckedCreateWithoutMyTeamInput>
  }

  export type LocalMatchCreateManyMyTeamInputEnvelope = {
    data: LocalMatchCreateManyMyTeamInput | LocalMatchCreateManyMyTeamInput[]
  }

  export type LocalMatchCreateWithoutOpponentTeamInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedLocalMatchesInput
    myTeam?: TeamCreateNestedOneWithoutLocalMatchesAsMyTeamInput
    spectators?: MatchSpectatorCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchUncheckedCreateWithoutOpponentTeamInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    spectators?: MatchSpectatorUncheckedCreateNestedManyWithoutLocalMatchInput
    overHistory?: OverHistoryUncheckedCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchCreateOrConnectWithoutOpponentTeamInput = {
    where: LocalMatchWhereUniqueInput
    create: XOR<LocalMatchCreateWithoutOpponentTeamInput, LocalMatchUncheckedCreateWithoutOpponentTeamInput>
  }

  export type LocalMatchCreateManyOpponentTeamInputEnvelope = {
    data: LocalMatchCreateManyOpponentTeamInput | LocalMatchCreateManyOpponentTeamInput[]
  }

  export type MatchSummaryCreateWithoutHomeTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    awayTeamName: string
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    awayTeam?: TeamCreateNestedOneWithoutMatchSummariesAsAwayInput
    manOfTheMatchUser?: UserCreateNestedOneWithoutMatchSummariesAsManOfTheMatchInput
    playerHistory?: PlayerMatchHistoryCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryUncheckedCreateWithoutHomeTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    awayTeamName: string
    awayTeamId?: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchUserId?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    playerHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryCreateOrConnectWithoutHomeTeamInput = {
    where: MatchSummaryWhereUniqueInput
    create: XOR<MatchSummaryCreateWithoutHomeTeamInput, MatchSummaryUncheckedCreateWithoutHomeTeamInput>
  }

  export type MatchSummaryCreateManyHomeTeamInputEnvelope = {
    data: MatchSummaryCreateManyHomeTeamInput | MatchSummaryCreateManyHomeTeamInput[]
  }

  export type MatchSummaryCreateWithoutAwayTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    awayTeamName: string
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    homeTeam?: TeamCreateNestedOneWithoutMatchSummariesAsHomeInput
    manOfTheMatchUser?: UserCreateNestedOneWithoutMatchSummariesAsManOfTheMatchInput
    playerHistory?: PlayerMatchHistoryCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryUncheckedCreateWithoutAwayTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    homeTeamId?: string | null
    awayTeamName: string
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchUserId?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    playerHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutMatchSummaryInput
  }

  export type MatchSummaryCreateOrConnectWithoutAwayTeamInput = {
    where: MatchSummaryWhereUniqueInput
    create: XOR<MatchSummaryCreateWithoutAwayTeamInput, MatchSummaryUncheckedCreateWithoutAwayTeamInput>
  }

  export type MatchSummaryCreateManyAwayTeamInputEnvelope = {
    data: MatchSummaryCreateManyAwayTeamInput | MatchSummaryCreateManyAwayTeamInput[]
  }

  export type PlayerMatchHistoryCreateWithoutTeamInput = {
    id?: string
    teamName: string
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerMatchHistoryInput
    matchSummary: MatchSummaryCreateNestedOneWithoutPlayerHistoryInput
  }

  export type PlayerMatchHistoryUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    matchSummaryId: string
    teamName: string
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryCreateOrConnectWithoutTeamInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    create: XOR<PlayerMatchHistoryCreateWithoutTeamInput, PlayerMatchHistoryUncheckedCreateWithoutTeamInput>
  }

  export type PlayerMatchHistoryCreateManyTeamInputEnvelope = {
    data: PlayerMatchHistoryCreateManyTeamInput | PlayerMatchHistoryCreateManyTeamInput[]
  }

  export type UserUpsertWithoutCreatedTeamsInput = {
    update: XOR<UserUpdateWithoutCreatedTeamsInput, UserUncheckedUpdateWithoutCreatedTeamsInput>
    create: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTeamsInput, UserUncheckedUpdateWithoutCreatedTeamsInput>
  }

  export type UserUpdateWithoutCreatedTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutCaptainOfTeamsInput = {
    update: XOR<UserUpdateWithoutCaptainOfTeamsInput, UserUncheckedUpdateWithoutCaptainOfTeamsInput>
    create: XOR<UserCreateWithoutCaptainOfTeamsInput, UserUncheckedCreateWithoutCaptainOfTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCaptainOfTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCaptainOfTeamsInput, UserUncheckedUpdateWithoutCaptainOfTeamsInput>
  }

  export type UserUpdateWithoutCaptainOfTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCaptainOfTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutViceCaptainOfTeamsInput = {
    update: XOR<UserUpdateWithoutViceCaptainOfTeamsInput, UserUncheckedUpdateWithoutViceCaptainOfTeamsInput>
    create: XOR<UserCreateWithoutViceCaptainOfTeamsInput, UserUncheckedCreateWithoutViceCaptainOfTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViceCaptainOfTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViceCaptainOfTeamsInput, UserUncheckedUpdateWithoutViceCaptainOfTeamsInput>
  }

  export type UserUpdateWithoutViceCaptainOfTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutViceCaptainOfTeamsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type GuestPlayerUpsertWithWhereUniqueWithoutTeamInput = {
    where: GuestPlayerWhereUniqueInput
    update: XOR<GuestPlayerUpdateWithoutTeamInput, GuestPlayerUncheckedUpdateWithoutTeamInput>
    create: XOR<GuestPlayerCreateWithoutTeamInput, GuestPlayerUncheckedCreateWithoutTeamInput>
  }

  export type GuestPlayerUpdateWithWhereUniqueWithoutTeamInput = {
    where: GuestPlayerWhereUniqueInput
    data: XOR<GuestPlayerUpdateWithoutTeamInput, GuestPlayerUncheckedUpdateWithoutTeamInput>
  }

  export type GuestPlayerUpdateManyWithWhereWithoutTeamInput = {
    where: GuestPlayerScalarWhereInput
    data: XOR<GuestPlayerUpdateManyMutationInput, GuestPlayerUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamInvitationUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamInvitationWhereUniqueInput
    update: XOR<TeamInvitationUpdateWithoutTeamInput, TeamInvitationUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamInvitationCreateWithoutTeamInput, TeamInvitationUncheckedCreateWithoutTeamInput>
  }

  export type TeamInvitationUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamInvitationWhereUniqueInput
    data: XOR<TeamInvitationUpdateWithoutTeamInput, TeamInvitationUncheckedUpdateWithoutTeamInput>
  }

  export type TeamInvitationUpdateManyWithWhereWithoutTeamInput = {
    where: TeamInvitationScalarWhereInput
    data: XOR<TeamInvitationUpdateManyMutationInput, TeamInvitationUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamMatchUpsertWithWhereUniqueWithoutHomeTeamInput = {
    where: TeamMatchWhereUniqueInput
    update: XOR<TeamMatchUpdateWithoutHomeTeamInput, TeamMatchUncheckedUpdateWithoutHomeTeamInput>
    create: XOR<TeamMatchCreateWithoutHomeTeamInput, TeamMatchUncheckedCreateWithoutHomeTeamInput>
  }

  export type TeamMatchUpdateWithWhereUniqueWithoutHomeTeamInput = {
    where: TeamMatchWhereUniqueInput
    data: XOR<TeamMatchUpdateWithoutHomeTeamInput, TeamMatchUncheckedUpdateWithoutHomeTeamInput>
  }

  export type TeamMatchUpdateManyWithWhereWithoutHomeTeamInput = {
    where: TeamMatchScalarWhereInput
    data: XOR<TeamMatchUpdateManyMutationInput, TeamMatchUncheckedUpdateManyWithoutHomeTeamInput>
  }

  export type TeamMatchScalarWhereInput = {
    AND?: TeamMatchScalarWhereInput | TeamMatchScalarWhereInput[]
    OR?: TeamMatchScalarWhereInput[]
    NOT?: TeamMatchScalarWhereInput | TeamMatchScalarWhereInput[]
    id?: StringFilter<"TeamMatch"> | string
    homeTeamId?: StringFilter<"TeamMatch"> | string
    awayTeamId?: StringFilter<"TeamMatch"> | string
    matchDate?: DateTimeFilter<"TeamMatch"> | Date | string
    venue?: StringFilter<"TeamMatch"> | string
    status?: EnumMatchStatusFilter<"TeamMatch"> | $Enums.MatchStatus
    result?: EnumMatchResultNullableFilter<"TeamMatch"> | $Enums.MatchResult | null
    homeTeamRuns?: IntFilter<"TeamMatch"> | number
    homeTeamWickets?: IntFilter<"TeamMatch"> | number
    homeTeamOvers?: FloatFilter<"TeamMatch"> | number
    awayTeamRuns?: IntFilter<"TeamMatch"> | number
    awayTeamWickets?: IntFilter<"TeamMatch"> | number
    awayTeamOvers?: FloatFilter<"TeamMatch"> | number
    createdAt?: DateTimeFilter<"TeamMatch"> | Date | string
  }

  export type TeamMatchUpsertWithWhereUniqueWithoutAwayTeamInput = {
    where: TeamMatchWhereUniqueInput
    update: XOR<TeamMatchUpdateWithoutAwayTeamInput, TeamMatchUncheckedUpdateWithoutAwayTeamInput>
    create: XOR<TeamMatchCreateWithoutAwayTeamInput, TeamMatchUncheckedCreateWithoutAwayTeamInput>
  }

  export type TeamMatchUpdateWithWhereUniqueWithoutAwayTeamInput = {
    where: TeamMatchWhereUniqueInput
    data: XOR<TeamMatchUpdateWithoutAwayTeamInput, TeamMatchUncheckedUpdateWithoutAwayTeamInput>
  }

  export type TeamMatchUpdateManyWithWhereWithoutAwayTeamInput = {
    where: TeamMatchScalarWhereInput
    data: XOR<TeamMatchUpdateManyMutationInput, TeamMatchUncheckedUpdateManyWithoutAwayTeamInput>
  }

  export type TeamStatisticsUpsertWithoutTeamInput = {
    update: XOR<TeamStatisticsUpdateWithoutTeamInput, TeamStatisticsUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamStatisticsCreateWithoutTeamInput, TeamStatisticsUncheckedCreateWithoutTeamInput>
    where?: TeamStatisticsWhereInput
  }

  export type TeamStatisticsUpdateToOneWithWhereWithoutTeamInput = {
    where?: TeamStatisticsWhereInput
    data: XOR<TeamStatisticsUpdateWithoutTeamInput, TeamStatisticsUncheckedUpdateWithoutTeamInput>
  }

  export type TeamStatisticsUpdateWithoutTeamInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topRunScorer?: UserUpdateOneWithoutTopRunScorerForNestedInput
    topWicketTaker?: UserUpdateOneWithoutTopWicketTakerForNestedInput
    bestStrikeRatePlayer?: UserUpdateOneWithoutBestStrikeRateForNestedInput
    bestEconomyPlayer?: UserUpdateOneWithoutBestEconomyForNestedInput
    mostManOfTheMatchPlayer?: UserUpdateOneWithoutMostManOfTheMatchForNestedInput
  }

  export type TeamStatisticsUncheckedUpdateWithoutTeamInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMatchPlayerWhereUniqueInput
    update: XOR<TeamMatchPlayerUpdateWithoutTeamInput, TeamMatchPlayerUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMatchPlayerCreateWithoutTeamInput, TeamMatchPlayerUncheckedCreateWithoutTeamInput>
  }

  export type TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMatchPlayerWhereUniqueInput
    data: XOR<TeamMatchPlayerUpdateWithoutTeamInput, TeamMatchPlayerUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMatchPlayerUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMatchPlayerScalarWhereInput
    data: XOR<TeamMatchPlayerUpdateManyMutationInput, TeamMatchPlayerUncheckedUpdateManyWithoutTeamInput>
  }

  export type LocalMatchUpsertWithWhereUniqueWithoutMyTeamInput = {
    where: LocalMatchWhereUniqueInput
    update: XOR<LocalMatchUpdateWithoutMyTeamInput, LocalMatchUncheckedUpdateWithoutMyTeamInput>
    create: XOR<LocalMatchCreateWithoutMyTeamInput, LocalMatchUncheckedCreateWithoutMyTeamInput>
  }

  export type LocalMatchUpdateWithWhereUniqueWithoutMyTeamInput = {
    where: LocalMatchWhereUniqueInput
    data: XOR<LocalMatchUpdateWithoutMyTeamInput, LocalMatchUncheckedUpdateWithoutMyTeamInput>
  }

  export type LocalMatchUpdateManyWithWhereWithoutMyTeamInput = {
    where: LocalMatchScalarWhereInput
    data: XOR<LocalMatchUpdateManyMutationInput, LocalMatchUncheckedUpdateManyWithoutMyTeamInput>
  }

  export type LocalMatchUpsertWithWhereUniqueWithoutOpponentTeamInput = {
    where: LocalMatchWhereUniqueInput
    update: XOR<LocalMatchUpdateWithoutOpponentTeamInput, LocalMatchUncheckedUpdateWithoutOpponentTeamInput>
    create: XOR<LocalMatchCreateWithoutOpponentTeamInput, LocalMatchUncheckedCreateWithoutOpponentTeamInput>
  }

  export type LocalMatchUpdateWithWhereUniqueWithoutOpponentTeamInput = {
    where: LocalMatchWhereUniqueInput
    data: XOR<LocalMatchUpdateWithoutOpponentTeamInput, LocalMatchUncheckedUpdateWithoutOpponentTeamInput>
  }

  export type LocalMatchUpdateManyWithWhereWithoutOpponentTeamInput = {
    where: LocalMatchScalarWhereInput
    data: XOR<LocalMatchUpdateManyMutationInput, LocalMatchUncheckedUpdateManyWithoutOpponentTeamInput>
  }

  export type MatchSummaryUpsertWithWhereUniqueWithoutHomeTeamInput = {
    where: MatchSummaryWhereUniqueInput
    update: XOR<MatchSummaryUpdateWithoutHomeTeamInput, MatchSummaryUncheckedUpdateWithoutHomeTeamInput>
    create: XOR<MatchSummaryCreateWithoutHomeTeamInput, MatchSummaryUncheckedCreateWithoutHomeTeamInput>
  }

  export type MatchSummaryUpdateWithWhereUniqueWithoutHomeTeamInput = {
    where: MatchSummaryWhereUniqueInput
    data: XOR<MatchSummaryUpdateWithoutHomeTeamInput, MatchSummaryUncheckedUpdateWithoutHomeTeamInput>
  }

  export type MatchSummaryUpdateManyWithWhereWithoutHomeTeamInput = {
    where: MatchSummaryScalarWhereInput
    data: XOR<MatchSummaryUpdateManyMutationInput, MatchSummaryUncheckedUpdateManyWithoutHomeTeamInput>
  }

  export type MatchSummaryUpsertWithWhereUniqueWithoutAwayTeamInput = {
    where: MatchSummaryWhereUniqueInput
    update: XOR<MatchSummaryUpdateWithoutAwayTeamInput, MatchSummaryUncheckedUpdateWithoutAwayTeamInput>
    create: XOR<MatchSummaryCreateWithoutAwayTeamInput, MatchSummaryUncheckedCreateWithoutAwayTeamInput>
  }

  export type MatchSummaryUpdateWithWhereUniqueWithoutAwayTeamInput = {
    where: MatchSummaryWhereUniqueInput
    data: XOR<MatchSummaryUpdateWithoutAwayTeamInput, MatchSummaryUncheckedUpdateWithoutAwayTeamInput>
  }

  export type MatchSummaryUpdateManyWithWhereWithoutAwayTeamInput = {
    where: MatchSummaryScalarWhereInput
    data: XOR<MatchSummaryUpdateManyMutationInput, MatchSummaryUncheckedUpdateManyWithoutAwayTeamInput>
  }

  export type PlayerMatchHistoryUpsertWithWhereUniqueWithoutTeamInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    update: XOR<PlayerMatchHistoryUpdateWithoutTeamInput, PlayerMatchHistoryUncheckedUpdateWithoutTeamInput>
    create: XOR<PlayerMatchHistoryCreateWithoutTeamInput, PlayerMatchHistoryUncheckedCreateWithoutTeamInput>
  }

  export type PlayerMatchHistoryUpdateWithWhereUniqueWithoutTeamInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    data: XOR<PlayerMatchHistoryUpdateWithoutTeamInput, PlayerMatchHistoryUncheckedUpdateWithoutTeamInput>
  }

  export type PlayerMatchHistoryUpdateManyWithWhereWithoutTeamInput = {
    where: PlayerMatchHistoryScalarWhereInput
    data: XOR<PlayerMatchHistoryUpdateManyMutationInput, PlayerMatchHistoryUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutGuestPlayersInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutGuestPlayersInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutGuestPlayersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutGuestPlayersInput, TeamUncheckedCreateWithoutGuestPlayersInput>
  }

  export type UserCreateWithoutGuestPlayersAddedInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGuestPlayersAddedInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGuestPlayersAddedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGuestPlayersAddedInput, UserUncheckedCreateWithoutGuestPlayersAddedInput>
  }

  export type UserCreateWithoutGuestPlayersLinkedInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGuestPlayersLinkedInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGuestPlayersLinkedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGuestPlayersLinkedInput, UserUncheckedCreateWithoutGuestPlayersLinkedInput>
  }

  export type TeamUpsertWithoutGuestPlayersInput = {
    update: XOR<TeamUpdateWithoutGuestPlayersInput, TeamUncheckedUpdateWithoutGuestPlayersInput>
    create: XOR<TeamCreateWithoutGuestPlayersInput, TeamUncheckedCreateWithoutGuestPlayersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutGuestPlayersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutGuestPlayersInput, TeamUncheckedUpdateWithoutGuestPlayersInput>
  }

  export type TeamUpdateWithoutGuestPlayersInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutGuestPlayersInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutGuestPlayersAddedInput = {
    update: XOR<UserUpdateWithoutGuestPlayersAddedInput, UserUncheckedUpdateWithoutGuestPlayersAddedInput>
    create: XOR<UserCreateWithoutGuestPlayersAddedInput, UserUncheckedCreateWithoutGuestPlayersAddedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGuestPlayersAddedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGuestPlayersAddedInput, UserUncheckedUpdateWithoutGuestPlayersAddedInput>
  }

  export type UserUpdateWithoutGuestPlayersAddedInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGuestPlayersAddedInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutGuestPlayersLinkedInput = {
    update: XOR<UserUpdateWithoutGuestPlayersLinkedInput, UserUncheckedUpdateWithoutGuestPlayersLinkedInput>
    create: XOR<UserCreateWithoutGuestPlayersLinkedInput, UserUncheckedCreateWithoutGuestPlayersLinkedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGuestPlayersLinkedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGuestPlayersLinkedInput, UserUncheckedUpdateWithoutGuestPlayersLinkedInput>
  }

  export type UserUpdateWithoutGuestPlayersLinkedInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGuestPlayersLinkedInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutInvitationsInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutInvitationsInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutInvitationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutInvitationsInput, TeamUncheckedCreateWithoutInvitationsInput>
  }

  export type UserCreateWithoutSentInvitationsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentInvitationsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
  }

  export type UserCreateWithoutReceivedInvitationsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedInvitationsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
  }

  export type TeamUpsertWithoutInvitationsInput = {
    update: XOR<TeamUpdateWithoutInvitationsInput, TeamUncheckedUpdateWithoutInvitationsInput>
    create: XOR<TeamCreateWithoutInvitationsInput, TeamUncheckedCreateWithoutInvitationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutInvitationsInput, TeamUncheckedUpdateWithoutInvitationsInput>
  }

  export type TeamUpdateWithoutInvitationsInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutInvitationsInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutSentInvitationsInput = {
    update: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
    create: XOR<UserCreateWithoutSentInvitationsInput, UserUncheckedCreateWithoutSentInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentInvitationsInput, UserUncheckedUpdateWithoutSentInvitationsInput>
  }

  export type UserUpdateWithoutSentInvitationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentInvitationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutReceivedInvitationsInput = {
    update: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
    create: XOR<UserCreateWithoutReceivedInvitationsInput, UserUncheckedCreateWithoutReceivedInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedInvitationsInput, UserUncheckedUpdateWithoutReceivedInvitationsInput>
  }

  export type UserUpdateWithoutReceivedInvitationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedInvitationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMatchesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesInput, UserUncheckedCreateWithoutMatchesInput>
  }

  export type UserUpsertWithoutMatchesInput = {
    update: XOR<UserUpdateWithoutMatchesInput, UserUncheckedUpdateWithoutMatchesInput>
    create: XOR<UserCreateWithoutMatchesInput, UserUncheckedCreateWithoutMatchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesInput, UserUncheckedUpdateWithoutMatchesInput>
  }

  export type UserUpdateWithoutMatchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateWithoutHomeMatchesInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutHomeMatchesInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutHomeMatchesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutHomeMatchesInput, TeamUncheckedCreateWithoutHomeMatchesInput>
  }

  export type TeamCreateWithoutAwayMatchesInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutAwayMatchesInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutAwayMatchesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutAwayMatchesInput, TeamUncheckedCreateWithoutAwayMatchesInput>
  }

  export type TeamMatchPlayerCreateWithoutTeamMatchInput = {
    id?: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
    user: UserCreateNestedOneWithoutTeamMatchStatsInput
    team: TeamCreateNestedOneWithoutTeamMatchStatsInput
  }

  export type TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput = {
    id?: string
    userId: string
    teamId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type TeamMatchPlayerCreateOrConnectWithoutTeamMatchInput = {
    where: TeamMatchPlayerWhereUniqueInput
    create: XOR<TeamMatchPlayerCreateWithoutTeamMatchInput, TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput>
  }

  export type TeamMatchPlayerCreateManyTeamMatchInputEnvelope = {
    data: TeamMatchPlayerCreateManyTeamMatchInput | TeamMatchPlayerCreateManyTeamMatchInput[]
  }

  export type TeamUpsertWithoutHomeMatchesInput = {
    update: XOR<TeamUpdateWithoutHomeMatchesInput, TeamUncheckedUpdateWithoutHomeMatchesInput>
    create: XOR<TeamCreateWithoutHomeMatchesInput, TeamUncheckedCreateWithoutHomeMatchesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutHomeMatchesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutHomeMatchesInput, TeamUncheckedUpdateWithoutHomeMatchesInput>
  }

  export type TeamUpdateWithoutHomeMatchesInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutHomeMatchesInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUpsertWithoutAwayMatchesInput = {
    update: XOR<TeamUpdateWithoutAwayMatchesInput, TeamUncheckedUpdateWithoutAwayMatchesInput>
    create: XOR<TeamCreateWithoutAwayMatchesInput, TeamUncheckedCreateWithoutAwayMatchesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutAwayMatchesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutAwayMatchesInput, TeamUncheckedUpdateWithoutAwayMatchesInput>
  }

  export type TeamUpdateWithoutAwayMatchesInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutAwayMatchesInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamMatchPlayerUpsertWithWhereUniqueWithoutTeamMatchInput = {
    where: TeamMatchPlayerWhereUniqueInput
    update: XOR<TeamMatchPlayerUpdateWithoutTeamMatchInput, TeamMatchPlayerUncheckedUpdateWithoutTeamMatchInput>
    create: XOR<TeamMatchPlayerCreateWithoutTeamMatchInput, TeamMatchPlayerUncheckedCreateWithoutTeamMatchInput>
  }

  export type TeamMatchPlayerUpdateWithWhereUniqueWithoutTeamMatchInput = {
    where: TeamMatchPlayerWhereUniqueInput
    data: XOR<TeamMatchPlayerUpdateWithoutTeamMatchInput, TeamMatchPlayerUncheckedUpdateWithoutTeamMatchInput>
  }

  export type TeamMatchPlayerUpdateManyWithWhereWithoutTeamMatchInput = {
    where: TeamMatchPlayerScalarWhereInput
    data: XOR<TeamMatchPlayerUpdateManyMutationInput, TeamMatchPlayerUncheckedUpdateManyWithoutTeamMatchInput>
  }

  export type TeamMatchCreateWithoutPlayerStatsInput = {
    id?: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
    homeTeam: TeamCreateNestedOneWithoutHomeMatchesInput
    awayTeam: TeamCreateNestedOneWithoutAwayMatchesInput
  }

  export type TeamMatchUncheckedCreateWithoutPlayerStatsInput = {
    id?: string
    homeTeamId: string
    awayTeamId: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
  }

  export type TeamMatchCreateOrConnectWithoutPlayerStatsInput = {
    where: TeamMatchWhereUniqueInput
    create: XOR<TeamMatchCreateWithoutPlayerStatsInput, TeamMatchUncheckedCreateWithoutPlayerStatsInput>
  }

  export type UserCreateWithoutTeamMatchStatsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamMatchStatsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamMatchStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMatchStatsInput, UserUncheckedCreateWithoutTeamMatchStatsInput>
  }

  export type TeamCreateWithoutTeamMatchStatsInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamMatchStatsInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamMatchStatsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamMatchStatsInput, TeamUncheckedCreateWithoutTeamMatchStatsInput>
  }

  export type TeamMatchUpsertWithoutPlayerStatsInput = {
    update: XOR<TeamMatchUpdateWithoutPlayerStatsInput, TeamMatchUncheckedUpdateWithoutPlayerStatsInput>
    create: XOR<TeamMatchCreateWithoutPlayerStatsInput, TeamMatchUncheckedCreateWithoutPlayerStatsInput>
    where?: TeamMatchWhereInput
  }

  export type TeamMatchUpdateToOneWithWhereWithoutPlayerStatsInput = {
    where?: TeamMatchWhereInput
    data: XOR<TeamMatchUpdateWithoutPlayerStatsInput, TeamMatchUncheckedUpdateWithoutPlayerStatsInput>
  }

  export type TeamMatchUpdateWithoutPlayerStatsInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneRequiredWithoutHomeMatchesNestedInput
    awayTeam?: TeamUpdateOneRequiredWithoutAwayMatchesNestedInput
  }

  export type TeamMatchUncheckedUpdateWithoutPlayerStatsInput = {
    homeTeamId?: StringFieldUpdateOperationsInput | string
    awayTeamId?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTeamMatchStatsInput = {
    update: XOR<UserUpdateWithoutTeamMatchStatsInput, UserUncheckedUpdateWithoutTeamMatchStatsInput>
    create: XOR<UserCreateWithoutTeamMatchStatsInput, UserUncheckedCreateWithoutTeamMatchStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMatchStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMatchStatsInput, UserUncheckedUpdateWithoutTeamMatchStatsInput>
  }

  export type UserUpdateWithoutTeamMatchStatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMatchStatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutTeamMatchStatsInput = {
    update: XOR<TeamUpdateWithoutTeamMatchStatsInput, TeamUncheckedUpdateWithoutTeamMatchStatsInput>
    create: XOR<TeamCreateWithoutTeamMatchStatsInput, TeamUncheckedCreateWithoutTeamMatchStatsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTeamMatchStatsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTeamMatchStatsInput, TeamUncheckedUpdateWithoutTeamMatchStatsInput>
  }

  export type TeamUpdateWithoutTeamMatchStatsInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamMatchStatsInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateWithoutTeamStatsInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamStatsInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamStatsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
  }

  export type UserCreateWithoutTopRunScorerForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTopRunScorerForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTopRunScorerForInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopRunScorerForInput, UserUncheckedCreateWithoutTopRunScorerForInput>
  }

  export type UserCreateWithoutTopWicketTakerForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTopWicketTakerForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTopWicketTakerForInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopWicketTakerForInput, UserUncheckedCreateWithoutTopWicketTakerForInput>
  }

  export type UserCreateWithoutBestStrikeRateForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBestStrikeRateForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBestStrikeRateForInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBestStrikeRateForInput, UserUncheckedCreateWithoutBestStrikeRateForInput>
  }

  export type UserCreateWithoutBestEconomyForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBestEconomyForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBestEconomyForInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBestEconomyForInput, UserUncheckedCreateWithoutBestEconomyForInput>
  }

  export type UserCreateWithoutMostManOfTheMatchForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMostManOfTheMatchForInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMostManOfTheMatchForInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMostManOfTheMatchForInput, UserUncheckedCreateWithoutMostManOfTheMatchForInput>
  }

  export type TeamUpsertWithoutTeamStatsInput = {
    update: XOR<TeamUpdateWithoutTeamStatsInput, TeamUncheckedUpdateWithoutTeamStatsInput>
    create: XOR<TeamCreateWithoutTeamStatsInput, TeamUncheckedCreateWithoutTeamStatsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTeamStatsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTeamStatsInput, TeamUncheckedUpdateWithoutTeamStatsInput>
  }

  export type TeamUpdateWithoutTeamStatsInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamStatsInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTopRunScorerForInput = {
    update: XOR<UserUpdateWithoutTopRunScorerForInput, UserUncheckedUpdateWithoutTopRunScorerForInput>
    create: XOR<UserCreateWithoutTopRunScorerForInput, UserUncheckedCreateWithoutTopRunScorerForInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopRunScorerForInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopRunScorerForInput, UserUncheckedUpdateWithoutTopRunScorerForInput>
  }

  export type UserUpdateWithoutTopRunScorerForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTopRunScorerForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutTopWicketTakerForInput = {
    update: XOR<UserUpdateWithoutTopWicketTakerForInput, UserUncheckedUpdateWithoutTopWicketTakerForInput>
    create: XOR<UserCreateWithoutTopWicketTakerForInput, UserUncheckedCreateWithoutTopWicketTakerForInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopWicketTakerForInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopWicketTakerForInput, UserUncheckedUpdateWithoutTopWicketTakerForInput>
  }

  export type UserUpdateWithoutTopWicketTakerForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTopWicketTakerForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBestStrikeRateForInput = {
    update: XOR<UserUpdateWithoutBestStrikeRateForInput, UserUncheckedUpdateWithoutBestStrikeRateForInput>
    create: XOR<UserCreateWithoutBestStrikeRateForInput, UserUncheckedCreateWithoutBestStrikeRateForInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBestStrikeRateForInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBestStrikeRateForInput, UserUncheckedUpdateWithoutBestStrikeRateForInput>
  }

  export type UserUpdateWithoutBestStrikeRateForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBestStrikeRateForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBestEconomyForInput = {
    update: XOR<UserUpdateWithoutBestEconomyForInput, UserUncheckedUpdateWithoutBestEconomyForInput>
    create: XOR<UserCreateWithoutBestEconomyForInput, UserUncheckedCreateWithoutBestEconomyForInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBestEconomyForInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBestEconomyForInput, UserUncheckedUpdateWithoutBestEconomyForInput>
  }

  export type UserUpdateWithoutBestEconomyForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBestEconomyForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMostManOfTheMatchForInput = {
    update: XOR<UserUpdateWithoutMostManOfTheMatchForInput, UserUncheckedUpdateWithoutMostManOfTheMatchForInput>
    create: XOR<UserCreateWithoutMostManOfTheMatchForInput, UserUncheckedCreateWithoutMostManOfTheMatchForInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMostManOfTheMatchForInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMostManOfTheMatchForInput, UserUncheckedUpdateWithoutMostManOfTheMatchForInput>
  }

  export type UserUpdateWithoutMostManOfTheMatchForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMostManOfTheMatchForInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCreatedLocalMatchesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedLocalMatchesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedLocalMatchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedLocalMatchesInput, UserUncheckedCreateWithoutCreatedLocalMatchesInput>
  }

  export type TeamCreateWithoutLocalMatchesAsMyTeamInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutLocalMatchesAsMyTeamInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutLocalMatchesAsMyTeamInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLocalMatchesAsMyTeamInput, TeamUncheckedCreateWithoutLocalMatchesAsMyTeamInput>
  }

  export type TeamCreateWithoutLocalMatchesAsOpponentInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutLocalMatchesAsOpponentInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutLocalMatchesAsOpponentInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLocalMatchesAsOpponentInput, TeamUncheckedCreateWithoutLocalMatchesAsOpponentInput>
  }

  export type MatchSpectatorCreateWithoutLocalMatchInput = {
    id?: string
    addedAt?: Date | string
    notified?: boolean
    user: UserCreateNestedOneWithoutSpectatorOfInput
    addedByUser: UserCreateNestedOneWithoutAddedSpectatorsInput
  }

  export type MatchSpectatorUncheckedCreateWithoutLocalMatchInput = {
    id?: string
    userId: string
    addedBy: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type MatchSpectatorCreateOrConnectWithoutLocalMatchInput = {
    where: MatchSpectatorWhereUniqueInput
    create: XOR<MatchSpectatorCreateWithoutLocalMatchInput, MatchSpectatorUncheckedCreateWithoutLocalMatchInput>
  }

  export type MatchSpectatorCreateManyLocalMatchInputEnvelope = {
    data: MatchSpectatorCreateManyLocalMatchInput | MatchSpectatorCreateManyLocalMatchInput[]
  }

  export type OverHistoryCreateWithoutLocalMatchInput = {
    id?: string
    overNumber: number
    innings: number
    balls: InputJsonValue
    totalRuns?: number
    wickets?: number
    createdAt?: Date | string
  }

  export type OverHistoryUncheckedCreateWithoutLocalMatchInput = {
    id?: string
    overNumber: number
    innings: number
    balls: InputJsonValue
    totalRuns?: number
    wickets?: number
    createdAt?: Date | string
  }

  export type OverHistoryCreateOrConnectWithoutLocalMatchInput = {
    where: OverHistoryWhereUniqueInput
    create: XOR<OverHistoryCreateWithoutLocalMatchInput, OverHistoryUncheckedCreateWithoutLocalMatchInput>
  }

  export type OverHistoryCreateManyLocalMatchInputEnvelope = {
    data: OverHistoryCreateManyLocalMatchInput | OverHistoryCreateManyLocalMatchInput[]
  }

  export type UserUpsertWithoutCreatedLocalMatchesInput = {
    update: XOR<UserUpdateWithoutCreatedLocalMatchesInput, UserUncheckedUpdateWithoutCreatedLocalMatchesInput>
    create: XOR<UserCreateWithoutCreatedLocalMatchesInput, UserUncheckedCreateWithoutCreatedLocalMatchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedLocalMatchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedLocalMatchesInput, UserUncheckedUpdateWithoutCreatedLocalMatchesInput>
  }

  export type UserUpdateWithoutCreatedLocalMatchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedLocalMatchesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamUpsertWithoutLocalMatchesAsMyTeamInput = {
    update: XOR<TeamUpdateWithoutLocalMatchesAsMyTeamInput, TeamUncheckedUpdateWithoutLocalMatchesAsMyTeamInput>
    create: XOR<TeamCreateWithoutLocalMatchesAsMyTeamInput, TeamUncheckedCreateWithoutLocalMatchesAsMyTeamInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutLocalMatchesAsMyTeamInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutLocalMatchesAsMyTeamInput, TeamUncheckedUpdateWithoutLocalMatchesAsMyTeamInput>
  }

  export type TeamUpdateWithoutLocalMatchesAsMyTeamInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLocalMatchesAsMyTeamInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUpsertWithoutLocalMatchesAsOpponentInput = {
    update: XOR<TeamUpdateWithoutLocalMatchesAsOpponentInput, TeamUncheckedUpdateWithoutLocalMatchesAsOpponentInput>
    create: XOR<TeamCreateWithoutLocalMatchesAsOpponentInput, TeamUncheckedCreateWithoutLocalMatchesAsOpponentInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutLocalMatchesAsOpponentInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutLocalMatchesAsOpponentInput, TeamUncheckedUpdateWithoutLocalMatchesAsOpponentInput>
  }

  export type TeamUpdateWithoutLocalMatchesAsOpponentInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLocalMatchesAsOpponentInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type MatchSpectatorUpsertWithWhereUniqueWithoutLocalMatchInput = {
    where: MatchSpectatorWhereUniqueInput
    update: XOR<MatchSpectatorUpdateWithoutLocalMatchInput, MatchSpectatorUncheckedUpdateWithoutLocalMatchInput>
    create: XOR<MatchSpectatorCreateWithoutLocalMatchInput, MatchSpectatorUncheckedCreateWithoutLocalMatchInput>
  }

  export type MatchSpectatorUpdateWithWhereUniqueWithoutLocalMatchInput = {
    where: MatchSpectatorWhereUniqueInput
    data: XOR<MatchSpectatorUpdateWithoutLocalMatchInput, MatchSpectatorUncheckedUpdateWithoutLocalMatchInput>
  }

  export type MatchSpectatorUpdateManyWithWhereWithoutLocalMatchInput = {
    where: MatchSpectatorScalarWhereInput
    data: XOR<MatchSpectatorUpdateManyMutationInput, MatchSpectatorUncheckedUpdateManyWithoutLocalMatchInput>
  }

  export type OverHistoryUpsertWithWhereUniqueWithoutLocalMatchInput = {
    where: OverHistoryWhereUniqueInput
    update: XOR<OverHistoryUpdateWithoutLocalMatchInput, OverHistoryUncheckedUpdateWithoutLocalMatchInput>
    create: XOR<OverHistoryCreateWithoutLocalMatchInput, OverHistoryUncheckedCreateWithoutLocalMatchInput>
  }

  export type OverHistoryUpdateWithWhereUniqueWithoutLocalMatchInput = {
    where: OverHistoryWhereUniqueInput
    data: XOR<OverHistoryUpdateWithoutLocalMatchInput, OverHistoryUncheckedUpdateWithoutLocalMatchInput>
  }

  export type OverHistoryUpdateManyWithWhereWithoutLocalMatchInput = {
    where: OverHistoryScalarWhereInput
    data: XOR<OverHistoryUpdateManyMutationInput, OverHistoryUncheckedUpdateManyWithoutLocalMatchInput>
  }

  export type OverHistoryScalarWhereInput = {
    AND?: OverHistoryScalarWhereInput | OverHistoryScalarWhereInput[]
    OR?: OverHistoryScalarWhereInput[]
    NOT?: OverHistoryScalarWhereInput | OverHistoryScalarWhereInput[]
    id?: StringFilter<"OverHistory"> | string
    localMatchId?: StringFilter<"OverHistory"> | string
    overNumber?: IntFilter<"OverHistory"> | number
    innings?: IntFilter<"OverHistory"> | number
    balls?: JsonFilter<"OverHistory">
    totalRuns?: IntFilter<"OverHistory"> | number
    wickets?: IntFilter<"OverHistory"> | number
    createdAt?: DateTimeFilter<"OverHistory"> | Date | string
  }

  export type LocalMatchCreateWithoutSpectatorsInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedLocalMatchesInput
    myTeam?: TeamCreateNestedOneWithoutLocalMatchesAsMyTeamInput
    opponentTeam?: TeamCreateNestedOneWithoutLocalMatchesAsOpponentInput
    overHistory?: OverHistoryCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchUncheckedCreateWithoutSpectatorsInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overHistory?: OverHistoryUncheckedCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchCreateOrConnectWithoutSpectatorsInput = {
    where: LocalMatchWhereUniqueInput
    create: XOR<LocalMatchCreateWithoutSpectatorsInput, LocalMatchUncheckedCreateWithoutSpectatorsInput>
  }

  export type UserCreateWithoutSpectatorOfInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSpectatorOfInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSpectatorOfInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpectatorOfInput, UserUncheckedCreateWithoutSpectatorOfInput>
  }

  export type UserCreateWithoutAddedSpectatorsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddedSpectatorsInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddedSpectatorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddedSpectatorsInput, UserUncheckedCreateWithoutAddedSpectatorsInput>
  }

  export type LocalMatchUpsertWithoutSpectatorsInput = {
    update: XOR<LocalMatchUpdateWithoutSpectatorsInput, LocalMatchUncheckedUpdateWithoutSpectatorsInput>
    create: XOR<LocalMatchCreateWithoutSpectatorsInput, LocalMatchUncheckedCreateWithoutSpectatorsInput>
    where?: LocalMatchWhereInput
  }

  export type LocalMatchUpdateToOneWithWhereWithoutSpectatorsInput = {
    where?: LocalMatchWhereInput
    data: XOR<LocalMatchUpdateWithoutSpectatorsInput, LocalMatchUncheckedUpdateWithoutSpectatorsInput>
  }

  export type LocalMatchUpdateWithoutSpectatorsInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedLocalMatchesNestedInput
    myTeam?: TeamUpdateOneWithoutLocalMatchesAsMyTeamNestedInput
    opponentTeam?: TeamUpdateOneWithoutLocalMatchesAsOpponentNestedInput
    overHistory?: OverHistoryUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateWithoutSpectatorsInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overHistory?: OverHistoryUncheckedUpdateManyWithoutLocalMatchNestedInput
  }

  export type UserUpsertWithoutSpectatorOfInput = {
    update: XOR<UserUpdateWithoutSpectatorOfInput, UserUncheckedUpdateWithoutSpectatorOfInput>
    create: XOR<UserCreateWithoutSpectatorOfInput, UserUncheckedCreateWithoutSpectatorOfInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpectatorOfInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpectatorOfInput, UserUncheckedUpdateWithoutSpectatorOfInput>
  }

  export type UserUpdateWithoutSpectatorOfInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSpectatorOfInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAddedSpectatorsInput = {
    update: XOR<UserUpdateWithoutAddedSpectatorsInput, UserUncheckedUpdateWithoutAddedSpectatorsInput>
    create: XOR<UserCreateWithoutAddedSpectatorsInput, UserUncheckedCreateWithoutAddedSpectatorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddedSpectatorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddedSpectatorsInput, UserUncheckedUpdateWithoutAddedSpectatorsInput>
  }

  export type UserUpdateWithoutAddedSpectatorsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddedSpectatorsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LocalMatchCreateWithoutOverHistoryInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedLocalMatchesInput
    myTeam?: TeamCreateNestedOneWithoutLocalMatchesAsMyTeamInput
    opponentTeam?: TeamCreateNestedOneWithoutLocalMatchesAsOpponentInput
    spectators?: MatchSpectatorCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchUncheckedCreateWithoutOverHistoryInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    spectators?: MatchSpectatorUncheckedCreateNestedManyWithoutLocalMatchInput
  }

  export type LocalMatchCreateOrConnectWithoutOverHistoryInput = {
    where: LocalMatchWhereUniqueInput
    create: XOR<LocalMatchCreateWithoutOverHistoryInput, LocalMatchUncheckedCreateWithoutOverHistoryInput>
  }

  export type LocalMatchUpsertWithoutOverHistoryInput = {
    update: XOR<LocalMatchUpdateWithoutOverHistoryInput, LocalMatchUncheckedUpdateWithoutOverHistoryInput>
    create: XOR<LocalMatchCreateWithoutOverHistoryInput, LocalMatchUncheckedCreateWithoutOverHistoryInput>
    where?: LocalMatchWhereInput
  }

  export type LocalMatchUpdateToOneWithWhereWithoutOverHistoryInput = {
    where?: LocalMatchWhereInput
    data: XOR<LocalMatchUpdateWithoutOverHistoryInput, LocalMatchUncheckedUpdateWithoutOverHistoryInput>
  }

  export type LocalMatchUpdateWithoutOverHistoryInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedLocalMatchesNestedInput
    myTeam?: TeamUpdateOneWithoutLocalMatchesAsMyTeamNestedInput
    opponentTeam?: TeamUpdateOneWithoutLocalMatchesAsOpponentNestedInput
    spectators?: MatchSpectatorUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateWithoutOverHistoryInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spectators?: MatchSpectatorUncheckedUpdateManyWithoutLocalMatchNestedInput
  }

  export type TeamCreateWithoutMatchSummariesAsHomeInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMatchSummariesAsHomeInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMatchSummariesAsHomeInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMatchSummariesAsHomeInput, TeamUncheckedCreateWithoutMatchSummariesAsHomeInput>
  }

  export type TeamCreateWithoutMatchSummariesAsAwayInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMatchSummariesAsAwayInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMatchSummariesAsAwayInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMatchSummariesAsAwayInput, TeamUncheckedCreateWithoutMatchSummariesAsAwayInput>
  }

  export type UserCreateWithoutMatchSummariesAsManOfTheMatchInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchSummariesAsManOfTheMatchInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchSummariesAsManOfTheMatchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchSummariesAsManOfTheMatchInput, UserUncheckedCreateWithoutMatchSummariesAsManOfTheMatchInput>
  }

  export type PlayerMatchHistoryCreateWithoutMatchSummaryInput = {
    id?: string
    teamName: string
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPlayerMatchHistoryInput
    team?: TeamCreateNestedOneWithoutPlayerMatchHistoryInput
  }

  export type PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput = {
    id?: string
    userId: string
    teamName: string
    teamId?: string | null
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryCreateOrConnectWithoutMatchSummaryInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    create: XOR<PlayerMatchHistoryCreateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput>
  }

  export type PlayerMatchHistoryCreateManyMatchSummaryInputEnvelope = {
    data: PlayerMatchHistoryCreateManyMatchSummaryInput | PlayerMatchHistoryCreateManyMatchSummaryInput[]
  }

  export type TeamUpsertWithoutMatchSummariesAsHomeInput = {
    update: XOR<TeamUpdateWithoutMatchSummariesAsHomeInput, TeamUncheckedUpdateWithoutMatchSummariesAsHomeInput>
    create: XOR<TeamCreateWithoutMatchSummariesAsHomeInput, TeamUncheckedCreateWithoutMatchSummariesAsHomeInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMatchSummariesAsHomeInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMatchSummariesAsHomeInput, TeamUncheckedUpdateWithoutMatchSummariesAsHomeInput>
  }

  export type TeamUpdateWithoutMatchSummariesAsHomeInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMatchSummariesAsHomeInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUpsertWithoutMatchSummariesAsAwayInput = {
    update: XOR<TeamUpdateWithoutMatchSummariesAsAwayInput, TeamUncheckedUpdateWithoutMatchSummariesAsAwayInput>
    create: XOR<TeamCreateWithoutMatchSummariesAsAwayInput, TeamUncheckedCreateWithoutMatchSummariesAsAwayInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMatchSummariesAsAwayInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMatchSummariesAsAwayInput, TeamUncheckedUpdateWithoutMatchSummariesAsAwayInput>
  }

  export type TeamUpdateWithoutMatchSummariesAsAwayInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMatchSummariesAsAwayInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutMatchSummariesAsManOfTheMatchInput = {
    update: XOR<UserUpdateWithoutMatchSummariesAsManOfTheMatchInput, UserUncheckedUpdateWithoutMatchSummariesAsManOfTheMatchInput>
    create: XOR<UserCreateWithoutMatchSummariesAsManOfTheMatchInput, UserUncheckedCreateWithoutMatchSummariesAsManOfTheMatchInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchSummariesAsManOfTheMatchInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchSummariesAsManOfTheMatchInput, UserUncheckedUpdateWithoutMatchSummariesAsManOfTheMatchInput>
  }

  export type UserUpdateWithoutMatchSummariesAsManOfTheMatchInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchSummariesAsManOfTheMatchInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlayerMatchHistoryUpsertWithWhereUniqueWithoutMatchSummaryInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    update: XOR<PlayerMatchHistoryUpdateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedUpdateWithoutMatchSummaryInput>
    create: XOR<PlayerMatchHistoryCreateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedCreateWithoutMatchSummaryInput>
  }

  export type PlayerMatchHistoryUpdateWithWhereUniqueWithoutMatchSummaryInput = {
    where: PlayerMatchHistoryWhereUniqueInput
    data: XOR<PlayerMatchHistoryUpdateWithoutMatchSummaryInput, PlayerMatchHistoryUncheckedUpdateWithoutMatchSummaryInput>
  }

  export type PlayerMatchHistoryUpdateManyWithWhereWithoutMatchSummaryInput = {
    where: PlayerMatchHistoryScalarWhereInput
    data: XOR<PlayerMatchHistoryUpdateManyMutationInput, PlayerMatchHistoryUncheckedUpdateManyWithoutMatchSummaryInput>
  }

  export type UserCreateWithoutPlayerMatchHistoryInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    fixtures?: FixtureCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlayerMatchHistoryInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    fixtures?: FixtureUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlayerMatchHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayerMatchHistoryInput, UserUncheckedCreateWithoutPlayerMatchHistoryInput>
  }

  export type MatchSummaryCreateWithoutPlayerHistoryInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    awayTeamName: string
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
    homeTeam?: TeamCreateNestedOneWithoutMatchSummariesAsHomeInput
    awayTeam?: TeamCreateNestedOneWithoutMatchSummariesAsAwayInput
    manOfTheMatchUser?: UserCreateNestedOneWithoutMatchSummariesAsManOfTheMatchInput
  }

  export type MatchSummaryUncheckedCreateWithoutPlayerHistoryInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    homeTeamId?: string | null
    awayTeamName: string
    awayTeamId?: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchUserId?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
  }

  export type MatchSummaryCreateOrConnectWithoutPlayerHistoryInput = {
    where: MatchSummaryWhereUniqueInput
    create: XOR<MatchSummaryCreateWithoutPlayerHistoryInput, MatchSummaryUncheckedCreateWithoutPlayerHistoryInput>
  }

  export type TeamCreateWithoutPlayerMatchHistoryInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    captain?: UserCreateNestedOneWithoutCaptainOfTeamsInput
    viceCaptain?: UserCreateNestedOneWithoutViceCaptainOfTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamUncheckedCreateWithoutPlayerMatchHistoryInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    guestPlayers?: GuestPlayerUncheckedCreateNestedManyWithoutTeamInput
    invitations?: TeamInvitationUncheckedCreateNestedManyWithoutTeamInput
    homeMatches?: TeamMatchUncheckedCreateNestedManyWithoutHomeTeamInput
    awayMatches?: TeamMatchUncheckedCreateNestedManyWithoutAwayTeamInput
    teamStats?: TeamStatisticsUncheckedCreateNestedOneWithoutTeamInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutTeamInput
    localMatchesAsMyTeam?: LocalMatchUncheckedCreateNestedManyWithoutMyTeamInput
    localMatchesAsOpponent?: LocalMatchUncheckedCreateNestedManyWithoutOpponentTeamInput
    matchSummariesAsHome?: MatchSummaryUncheckedCreateNestedManyWithoutHomeTeamInput
    matchSummariesAsAway?: MatchSummaryUncheckedCreateNestedManyWithoutAwayTeamInput
  }

  export type TeamCreateOrConnectWithoutPlayerMatchHistoryInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPlayerMatchHistoryInput, TeamUncheckedCreateWithoutPlayerMatchHistoryInput>
  }

  export type UserUpsertWithoutPlayerMatchHistoryInput = {
    update: XOR<UserUpdateWithoutPlayerMatchHistoryInput, UserUncheckedUpdateWithoutPlayerMatchHistoryInput>
    create: XOR<UserCreateWithoutPlayerMatchHistoryInput, UserUncheckedCreateWithoutPlayerMatchHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayerMatchHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayerMatchHistoryInput, UserUncheckedUpdateWithoutPlayerMatchHistoryInput>
  }

  export type UserUpdateWithoutPlayerMatchHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    fixtures?: FixtureUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayerMatchHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    fixtures?: FixtureUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatchSummaryUpsertWithoutPlayerHistoryInput = {
    update: XOR<MatchSummaryUpdateWithoutPlayerHistoryInput, MatchSummaryUncheckedUpdateWithoutPlayerHistoryInput>
    create: XOR<MatchSummaryCreateWithoutPlayerHistoryInput, MatchSummaryUncheckedCreateWithoutPlayerHistoryInput>
    where?: MatchSummaryWhereInput
  }

  export type MatchSummaryUpdateToOneWithWhereWithoutPlayerHistoryInput = {
    where?: MatchSummaryWhereInput
    data: XOR<MatchSummaryUpdateWithoutPlayerHistoryInput, MatchSummaryUncheckedUpdateWithoutPlayerHistoryInput>
  }

  export type MatchSummaryUpdateWithoutPlayerHistoryInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneWithoutMatchSummariesAsHomeNestedInput
    awayTeam?: TeamUpdateOneWithoutMatchSummariesAsAwayNestedInput
    manOfTheMatchUser?: UserUpdateOneWithoutMatchSummariesAsManOfTheMatchNestedInput
  }

  export type MatchSummaryUncheckedUpdateWithoutPlayerHistoryInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    homeTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    awayTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchUserId?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithoutPlayerMatchHistoryInput = {
    update: XOR<TeamUpdateWithoutPlayerMatchHistoryInput, TeamUncheckedUpdateWithoutPlayerMatchHistoryInput>
    create: XOR<TeamCreateWithoutPlayerMatchHistoryInput, TeamUncheckedCreateWithoutPlayerMatchHistoryInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPlayerMatchHistoryInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPlayerMatchHistoryInput, TeamUncheckedUpdateWithoutPlayerMatchHistoryInput>
  }

  export type TeamUpdateWithoutPlayerMatchHistoryInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPlayerMatchHistoryInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
  }

  export type UserCreateWithoutFixturesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsCreateNestedOneWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerCreateNestedManyWithoutLinkedUserInput
    matches?: MatchCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFixturesInput = {
    id?: string
    email: string
    password: string
    username?: string | null
    profileName?: string | null
    description?: string | null
    profilePictureUrl?: string | null
    role?: $Enums.Role | null
    battingHand?: $Enums.BattingHand | null
    bowlingStyle?: $Enums.BowlingStyle | null
    profileComplete?: boolean
    createdAt?: Date | string
    careerStats?: CareerStatsUncheckedCreateNestedOneWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    captainOfTeams?: TeamUncheckedCreateNestedManyWithoutCaptainInput
    viceCaptainOfTeams?: TeamUncheckedCreateNestedManyWithoutViceCaptainInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    sentInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInviterInput
    receivedInvitations?: TeamInvitationUncheckedCreateNestedManyWithoutInvitedInput
    guestPlayersAdded?: GuestPlayerUncheckedCreateNestedManyWithoutAddedByInput
    guestPlayersLinked?: GuestPlayerUncheckedCreateNestedManyWithoutLinkedUserInput
    matches?: MatchUncheckedCreateNestedManyWithoutUserInput
    teamMatchStats?: TeamMatchPlayerUncheckedCreateNestedManyWithoutUserInput
    topRunScorerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopRunScorerInput
    topWicketTakerFor?: TeamStatisticsUncheckedCreateNestedManyWithoutTopWicketTakerInput
    bestStrikeRateFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestStrikeRatePlayerInput
    bestEconomyFor?: TeamStatisticsUncheckedCreateNestedManyWithoutBestEconomyPlayerInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedCreateNestedManyWithoutMostManOfTheMatchPlayerInput
    createdLocalMatches?: LocalMatchUncheckedCreateNestedManyWithoutCreatorInput
    spectatorOf?: MatchSpectatorUncheckedCreateNestedManyWithoutUserInput
    addedSpectators?: MatchSpectatorUncheckedCreateNestedManyWithoutAddedByUserInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedCreateNestedManyWithoutManOfTheMatchUserInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFixturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFixturesInput, UserUncheckedCreateWithoutFixturesInput>
  }

  export type UserUpsertWithoutFixturesInput = {
    update: XOR<UserUpdateWithoutFixturesInput, UserUncheckedUpdateWithoutFixturesInput>
    create: XOR<UserCreateWithoutFixturesInput, UserUncheckedCreateWithoutFixturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFixturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFixturesInput, UserUncheckedUpdateWithoutFixturesInput>
  }

  export type UserUpdateWithoutFixturesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFixturesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    profileName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    battingHand?: NullableEnumBattingHandFieldUpdateOperationsInput | $Enums.BattingHand | null
    bowlingStyle?: NullableEnumBowlingStyleFieldUpdateOperationsInput | $Enums.BowlingStyle | null
    profileComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    careerStats?: CareerStatsUncheckedUpdateOneWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    captainOfTeams?: TeamUncheckedUpdateManyWithoutCaptainNestedInput
    viceCaptainOfTeams?: TeamUncheckedUpdateManyWithoutViceCaptainNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    sentInvitations?: TeamInvitationUncheckedUpdateManyWithoutInviterNestedInput
    receivedInvitations?: TeamInvitationUncheckedUpdateManyWithoutInvitedNestedInput
    guestPlayersAdded?: GuestPlayerUncheckedUpdateManyWithoutAddedByNestedInput
    guestPlayersLinked?: GuestPlayerUncheckedUpdateManyWithoutLinkedUserNestedInput
    matches?: MatchUncheckedUpdateManyWithoutUserNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutUserNestedInput
    topRunScorerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerNestedInput
    topWicketTakerFor?: TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerNestedInput
    bestStrikeRateFor?: TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerNestedInput
    bestEconomyFor?: TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerNestedInput
    mostManOfTheMatchFor?: TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerNestedInput
    createdLocalMatches?: LocalMatchUncheckedUpdateManyWithoutCreatorNestedInput
    spectatorOf?: MatchSpectatorUncheckedUpdateManyWithoutUserNestedInput
    addedSpectators?: MatchSpectatorUncheckedUpdateManyWithoutAddedByUserNestedInput
    matchSummariesAsManOfTheMatch?: MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeamCreateManyCreatedByInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    captainId?: string | null
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateManyCaptainInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    viceCaptainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateManyViceCaptainInput = {
    id?: string
    teamCode: string
    name: string
    description?: string | null
    logoUrl?: string | null
    createdById: string
    captainId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    teamId: string
    joinedAt?: Date | string
  }

  export type TeamInvitationCreateManyInviterInput = {
    id?: string
    teamId: string
    invitedUser: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type TeamInvitationCreateManyInvitedInput = {
    id?: string
    teamId: string
    invitedBy: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type GuestPlayerCreateManyAddedByInput = {
    id?: string
    teamId: string
    name: string
    linkedUserId?: string | null
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type GuestPlayerCreateManyLinkedUserInput = {
    id?: string
    teamId: string
    name: string
    addedByUserId: string
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type MatchCreateManyUserInput = {
    id?: string
    opponent: string
    matchDate: Date | string
    runsScored: number
    ballsFaced: number
    wasDismissed?: boolean
    oversBowled: number
    runsConceded: number
    wicketsTaken: number
    catchesTaken: number
    runOuts?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type TeamMatchPlayerCreateManyUserInput = {
    id?: string
    teamMatchId: string
    teamId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type TeamStatisticsCreateManyTopRunScorerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateManyTopWicketTakerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateManyBestStrikeRatePlayerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateManyBestEconomyPlayerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomy?: number
    mostManOfTheMatchPlayerId?: string | null
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type TeamStatisticsCreateManyMostManOfTheMatchPlayerInput = {
    id?: string
    teamId: string
    matchesPlayed?: number
    matchesWon?: number
    matchesLost?: number
    matchesDrawn?: number
    winRatio?: number
    topRunScorerId?: string | null
    topRunScorerRuns?: number
    topWicketTakerId?: string | null
    topWicketTakerWickets?: number
    bestStrikeRatePlayerId?: string | null
    bestStrikeRate?: number
    bestEconomyPlayerId?: string | null
    bestEconomy?: number
    mostManOfTheMatchAwards?: number
    updatedAt?: Date | string
  }

  export type LocalMatchCreateManyCreatorInput = {
    id?: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchSpectatorCreateManyUserInput = {
    id?: string
    localMatchId: string
    addedBy: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type MatchSpectatorCreateManyAddedByUserInput = {
    id?: string
    localMatchId: string
    userId: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type MatchSummaryCreateManyManOfTheMatchUserInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    homeTeamId?: string | null
    awayTeamName: string
    awayTeamId?: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryCreateManyUserInput = {
    id?: string
    matchSummaryId: string
    teamName: string
    teamId?: string | null
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type FixtureCreateManyUserInput = {
    id?: string
    teamAId?: string | null
    teamAName: string
    teamALogo?: string | null
    teamAPlayers: InputJsonValue
    teamBId?: string | null
    teamBName: string
    teamBLogo?: string | null
    teamBPlayers: InputJsonValue
    overs?: number
    venue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutCreatedByInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCreatedByInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutCreatedByInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutCaptainInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    viceCaptain?: UserUpdateOneWithoutViceCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCaptainInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutCaptainInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    viceCaptainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutViceCaptainInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    captain?: UserUpdateOneWithoutCaptainOfTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutViceCaptainInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    guestPlayers?: GuestPlayerUncheckedUpdateManyWithoutTeamNestedInput
    invitations?: TeamInvitationUncheckedUpdateManyWithoutTeamNestedInput
    homeMatches?: TeamMatchUncheckedUpdateManyWithoutHomeTeamNestedInput
    awayMatches?: TeamMatchUncheckedUpdateManyWithoutAwayTeamNestedInput
    teamStats?: TeamStatisticsUncheckedUpdateOneWithoutTeamNestedInput
    teamMatchStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamNestedInput
    localMatchesAsMyTeam?: LocalMatchUncheckedUpdateManyWithoutMyTeamNestedInput
    localMatchesAsOpponent?: LocalMatchUncheckedUpdateManyWithoutOpponentTeamNestedInput
    matchSummariesAsHome?: MatchSummaryUncheckedUpdateManyWithoutHomeTeamNestedInput
    matchSummariesAsAway?: MatchSummaryUncheckedUpdateManyWithoutAwayTeamNestedInput
    playerMatchHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutViceCaptainInput = {
    teamCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    captainId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationUpdateWithoutInviterInput = {
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutInvitationsNestedInput
    invited?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type TeamInvitationUncheckedUpdateWithoutInviterInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    invitedUser?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationUncheckedUpdateManyWithoutInviterInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    invitedUser?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationUpdateWithoutInvitedInput = {
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutInvitationsNestedInput
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
  }

  export type TeamInvitationUncheckedUpdateWithoutInvitedInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationUncheckedUpdateManyWithoutInvitedInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestPlayerUpdateWithoutAddedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    team?: TeamUpdateOneRequiredWithoutGuestPlayersNestedInput
    linkedUser?: UserUpdateOneWithoutGuestPlayersLinkedNestedInput
  }

  export type GuestPlayerUncheckedUpdateWithoutAddedByInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linkedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type GuestPlayerUncheckedUpdateManyWithoutAddedByInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    linkedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type GuestPlayerUpdateWithoutLinkedUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    team?: TeamUpdateOneRequiredWithoutGuestPlayersNestedInput
    addedBy?: UserUpdateOneRequiredWithoutGuestPlayersAddedNestedInput
  }

  export type GuestPlayerUncheckedUpdateWithoutLinkedUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type GuestPlayerUncheckedUpdateManyWithoutLinkedUserInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type MatchUpdateWithoutUserInput = {
    opponent?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateWithoutUserInput = {
    opponent?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyWithoutUserInput = {
    opponent?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchPlayerUpdateWithoutUserInput = {
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    teamMatch?: TeamMatchUpdateOneRequiredWithoutPlayerStatsNestedInput
    team?: TeamUpdateOneRequiredWithoutTeamMatchStatsNestedInput
  }

  export type TeamMatchPlayerUncheckedUpdateWithoutUserInput = {
    teamMatchId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMatchPlayerUncheckedUpdateManyWithoutUserInput = {
    teamMatchId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type TeamStatisticsUpdateWithoutTopRunScorerInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
    topWicketTaker?: UserUpdateOneWithoutTopWicketTakerForNestedInput
    bestStrikeRatePlayer?: UserUpdateOneWithoutBestStrikeRateForNestedInput
    bestEconomyPlayer?: UserUpdateOneWithoutBestEconomyForNestedInput
    mostManOfTheMatchPlayer?: UserUpdateOneWithoutMostManOfTheMatchForNestedInput
  }

  export type TeamStatisticsUncheckedUpdateWithoutTopRunScorerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutTopRunScorerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUpdateWithoutTopWicketTakerInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
    topRunScorer?: UserUpdateOneWithoutTopRunScorerForNestedInput
    bestStrikeRatePlayer?: UserUpdateOneWithoutBestStrikeRateForNestedInput
    bestEconomyPlayer?: UserUpdateOneWithoutBestEconomyForNestedInput
    mostManOfTheMatchPlayer?: UserUpdateOneWithoutMostManOfTheMatchForNestedInput
  }

  export type TeamStatisticsUncheckedUpdateWithoutTopWicketTakerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutTopWicketTakerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUpdateWithoutBestStrikeRatePlayerInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
    topRunScorer?: UserUpdateOneWithoutTopRunScorerForNestedInput
    topWicketTaker?: UserUpdateOneWithoutTopWicketTakerForNestedInput
    bestEconomyPlayer?: UserUpdateOneWithoutBestEconomyForNestedInput
    mostManOfTheMatchPlayer?: UserUpdateOneWithoutMostManOfTheMatchForNestedInput
  }

  export type TeamStatisticsUncheckedUpdateWithoutBestStrikeRatePlayerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutBestStrikeRatePlayerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUpdateWithoutBestEconomyPlayerInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
    topRunScorer?: UserUpdateOneWithoutTopRunScorerForNestedInput
    topWicketTaker?: UserUpdateOneWithoutTopWicketTakerForNestedInput
    bestStrikeRatePlayer?: UserUpdateOneWithoutBestStrikeRateForNestedInput
    mostManOfTheMatchPlayer?: UserUpdateOneWithoutMostManOfTheMatchForNestedInput
  }

  export type TeamStatisticsUncheckedUpdateWithoutBestEconomyPlayerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutBestEconomyPlayerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUpdateWithoutMostManOfTheMatchPlayerInput = {
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutTeamStatsNestedInput
    topRunScorer?: UserUpdateOneWithoutTopRunScorerForNestedInput
    topWicketTaker?: UserUpdateOneWithoutTopWicketTakerForNestedInput
    bestStrikeRatePlayer?: UserUpdateOneWithoutBestStrikeRateForNestedInput
    bestEconomyPlayer?: UserUpdateOneWithoutBestEconomyForNestedInput
  }

  export type TeamStatisticsUncheckedUpdateWithoutMostManOfTheMatchPlayerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamStatisticsUncheckedUpdateManyWithoutMostManOfTheMatchPlayerInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    matchesWon?: IntFieldUpdateOperationsInput | number
    matchesLost?: IntFieldUpdateOperationsInput | number
    matchesDrawn?: IntFieldUpdateOperationsInput | number
    winRatio?: FloatFieldUpdateOperationsInput | number
    topRunScorerId?: NullableStringFieldUpdateOperationsInput | string | null
    topRunScorerRuns?: IntFieldUpdateOperationsInput | number
    topWicketTakerId?: NullableStringFieldUpdateOperationsInput | string | null
    topWicketTakerWickets?: IntFieldUpdateOperationsInput | number
    bestStrikeRatePlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestStrikeRate?: FloatFieldUpdateOperationsInput | number
    bestEconomyPlayerId?: NullableStringFieldUpdateOperationsInput | string | null
    bestEconomy?: FloatFieldUpdateOperationsInput | number
    mostManOfTheMatchAwards?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalMatchUpdateWithoutCreatorInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    myTeam?: TeamUpdateOneWithoutLocalMatchesAsMyTeamNestedInput
    opponentTeam?: TeamUpdateOneWithoutLocalMatchesAsOpponentNestedInput
    spectators?: MatchSpectatorUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateWithoutCreatorInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spectators?: MatchSpectatorUncheckedUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUncheckedUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateManyWithoutCreatorInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchSpectatorUpdateWithoutUserInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
    localMatch?: LocalMatchUpdateOneRequiredWithoutSpectatorsNestedInput
    addedByUser?: UserUpdateOneRequiredWithoutAddedSpectatorsNestedInput
  }

  export type MatchSpectatorUncheckedUpdateWithoutUserInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    addedBy?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchSpectatorUncheckedUpdateManyWithoutUserInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    addedBy?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchSpectatorUpdateWithoutAddedByUserInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
    localMatch?: LocalMatchUpdateOneRequiredWithoutSpectatorsNestedInput
    user?: UserUpdateOneRequiredWithoutSpectatorOfNestedInput
  }

  export type MatchSpectatorUncheckedUpdateWithoutAddedByUserInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchSpectatorUncheckedUpdateManyWithoutAddedByUserInput = {
    localMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchSummaryUpdateWithoutManOfTheMatchUserInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneWithoutMatchSummariesAsHomeNestedInput
    awayTeam?: TeamUpdateOneWithoutMatchSummariesAsAwayNestedInput
    playerHistory?: PlayerMatchHistoryUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryUncheckedUpdateWithoutManOfTheMatchUserInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    homeTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    awayTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryUncheckedUpdateManyWithoutManOfTheMatchUserInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    homeTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    awayTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryUpdateWithoutUserInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchSummary?: MatchSummaryUpdateOneRequiredWithoutPlayerHistoryNestedInput
    team?: TeamUpdateOneWithoutPlayerMatchHistoryNestedInput
  }

  export type PlayerMatchHistoryUncheckedUpdateWithoutUserInput = {
    matchSummaryId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryUncheckedUpdateManyWithoutUserInput = {
    matchSummaryId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixtureUpdateWithoutUserInput = {
    teamAId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAName?: StringFieldUpdateOperationsInput | string
    teamALogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamAPlayers?: InputJsonValue | InputJsonValue
    teamBId?: NullableStringFieldUpdateOperationsInput | string | null
    teamBName?: StringFieldUpdateOperationsInput | string
    teamBLogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamBPlayers?: InputJsonValue | InputJsonValue
    overs?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixtureUncheckedUpdateWithoutUserInput = {
    teamAId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAName?: StringFieldUpdateOperationsInput | string
    teamALogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamAPlayers?: InputJsonValue | InputJsonValue
    teamBId?: NullableStringFieldUpdateOperationsInput | string | null
    teamBName?: StringFieldUpdateOperationsInput | string
    teamBLogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamBPlayers?: InputJsonValue | InputJsonValue
    overs?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FixtureUncheckedUpdateManyWithoutUserInput = {
    teamAId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAName?: StringFieldUpdateOperationsInput | string
    teamALogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamAPlayers?: InputJsonValue | InputJsonValue
    teamBId?: NullableStringFieldUpdateOperationsInput | string | null
    teamBName?: StringFieldUpdateOperationsInput | string
    teamBLogo?: NullableStringFieldUpdateOperationsInput | string | null
    teamBPlayers?: InputJsonValue | InputJsonValue
    overs?: IntFieldUpdateOperationsInput | number
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    userId: string
    joinedAt?: Date | string
  }

  export type GuestPlayerCreateManyTeamInput = {
    id?: string
    name: string
    addedByUserId: string
    linkedUserId?: string | null
    createdAt?: Date | string
    matchesPlayed?: number
    totalRuns?: number
    ballsFaced?: number
    fours?: number
    sixes?: number
    wicketsTaken?: number
    runsConceded?: number
    oversBowled?: number
    catchesTaken?: number
    runOuts?: number
  }

  export type TeamInvitationCreateManyTeamInput = {
    id?: string
    invitedBy: string
    invitedUser: string
    status?: $Enums.InvitationStatus
    createdAt?: Date | string
  }

  export type TeamMatchCreateManyHomeTeamInput = {
    id?: string
    awayTeamId: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
  }

  export type TeamMatchCreateManyAwayTeamInput = {
    id?: string
    homeTeamId: string
    matchDate: Date | string
    venue: string
    status?: $Enums.MatchStatus
    result?: $Enums.MatchResult | null
    homeTeamRuns?: number
    homeTeamWickets?: number
    homeTeamOvers?: number
    awayTeamRuns?: number
    awayTeamWickets?: number
    awayTeamOvers?: number
    createdAt?: Date | string
  }

  export type TeamMatchPlayerCreateManyTeamInput = {
    id?: string
    teamMatchId: string
    userId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type LocalMatchCreateManyMyTeamInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    opponentTeamName?: string | null
    opponentTeamId?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalMatchCreateManyOpponentTeamInput = {
    id?: string
    creatorId: string
    matchName: string
    venue: string
    matchDate: Date | string
    overs?: number
    myTeamName?: string | null
    myTeamId?: string | null
    opponentTeamName?: string | null
    myTeamPlayers: InputJsonValue
    opponentTeamPlayers: InputJsonValue
    allowSpectators?: boolean
    isRoomMatch?: boolean
    roomPassword?: string | null
    status?: $Enums.LocalMatchStatus
    currentInnings?: number
    currentOver?: number
    currentBall?: number
    myTeamScore?: number
    myTeamWickets?: number
    myTeamOvers?: number
    opponentTeamScore?: number
    opponentTeamWickets?: number
    opponentTeamOvers?: number
    fullState?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchSummaryCreateManyHomeTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    awayTeamName: string
    awayTeamId?: string | null
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchUserId?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
  }

  export type MatchSummaryCreateManyAwayTeamInput = {
    id?: string
    matchDate: Date | string
    venue: string
    homeTeamName: string
    homeTeamId?: string | null
    awayTeamName: string
    result: $Enums.MatchResult
    winningTeam: string
    firstInningsTeam: string
    firstInningsRuns: number
    firstInningsWickets: number
    firstInningsOvers: number
    secondInningsTeam: string
    secondInningsRuns: number
    secondInningsWickets: number
    secondInningsOvers: number
    target?: number | null
    totalOvers?: number
    manOfTheMatchPlayerName?: string | null
    manOfTheMatchUserId?: string | null
    manOfTheMatchStats?: InputJsonValue | null
    firstInningsBatsmen: InputJsonValue
    firstInningsBowlers: InputJsonValue
    secondInningsBatsmen: InputJsonValue
    secondInningsBowlers: InputJsonValue
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryCreateManyTeamInput = {
    id?: string
    userId: string
    matchSummaryId: string
    teamName: string
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestPlayerUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
    addedBy?: UserUpdateOneRequiredWithoutGuestPlayersAddedNestedInput
    linkedUser?: UserUpdateOneWithoutGuestPlayersLinkedNestedInput
  }

  export type GuestPlayerUncheckedUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    linkedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type GuestPlayerUncheckedUpdateManyWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    addedByUserId?: StringFieldUpdateOperationsInput | string
    linkedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    matchesPlayed?: IntFieldUpdateOperationsInput | number
    totalRuns?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    fours?: IntFieldUpdateOperationsInput | number
    sixes?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    runOuts?: IntFieldUpdateOperationsInput | number
  }

  export type TeamInvitationUpdateWithoutTeamInput = {
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inviter?: UserUpdateOneRequiredWithoutSentInvitationsNestedInput
    invited?: UserUpdateOneRequiredWithoutReceivedInvitationsNestedInput
  }

  export type TeamInvitationUncheckedUpdateWithoutTeamInput = {
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUser?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamInvitationUncheckedUpdateManyWithoutTeamInput = {
    invitedBy?: StringFieldUpdateOperationsInput | string
    invitedUser?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchUpdateWithoutHomeTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    awayTeam?: TeamUpdateOneRequiredWithoutAwayMatchesNestedInput
    playerStats?: TeamMatchPlayerUpdateManyWithoutTeamMatchNestedInput
  }

  export type TeamMatchUncheckedUpdateWithoutHomeTeamInput = {
    awayTeamId?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamMatchNestedInput
  }

  export type TeamMatchUncheckedUpdateManyWithoutHomeTeamInput = {
    awayTeamId?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchUpdateWithoutAwayTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneRequiredWithoutHomeMatchesNestedInput
    playerStats?: TeamMatchPlayerUpdateManyWithoutTeamMatchNestedInput
  }

  export type TeamMatchUncheckedUpdateWithoutAwayTeamInput = {
    homeTeamId?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerStats?: TeamMatchPlayerUncheckedUpdateManyWithoutTeamMatchNestedInput
  }

  export type TeamMatchUncheckedUpdateManyWithoutAwayTeamInput = {
    homeTeamId?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    result?: NullableEnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult | null
    homeTeamRuns?: IntFieldUpdateOperationsInput | number
    homeTeamWickets?: IntFieldUpdateOperationsInput | number
    homeTeamOvers?: FloatFieldUpdateOperationsInput | number
    awayTeamRuns?: IntFieldUpdateOperationsInput | number
    awayTeamWickets?: IntFieldUpdateOperationsInput | number
    awayTeamOvers?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchPlayerUpdateWithoutTeamInput = {
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    teamMatch?: TeamMatchUpdateOneRequiredWithoutPlayerStatsNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMatchStatsNestedInput
  }

  export type TeamMatchPlayerUncheckedUpdateWithoutTeamInput = {
    teamMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMatchPlayerUncheckedUpdateManyWithoutTeamInput = {
    teamMatchId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type LocalMatchUpdateWithoutMyTeamInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedLocalMatchesNestedInput
    opponentTeam?: TeamUpdateOneWithoutLocalMatchesAsOpponentNestedInput
    spectators?: MatchSpectatorUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateWithoutMyTeamInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spectators?: MatchSpectatorUncheckedUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUncheckedUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateManyWithoutMyTeamInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalMatchUpdateWithoutOpponentTeamInput = {
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedLocalMatchesNestedInput
    myTeam?: TeamUpdateOneWithoutLocalMatchesAsMyTeamNestedInput
    spectators?: MatchSpectatorUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateWithoutOpponentTeamInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    spectators?: MatchSpectatorUncheckedUpdateManyWithoutLocalMatchNestedInput
    overHistory?: OverHistoryUncheckedUpdateManyWithoutLocalMatchNestedInput
  }

  export type LocalMatchUncheckedUpdateManyWithoutOpponentTeamInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    matchName?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    overs?: IntFieldUpdateOperationsInput | number
    myTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    opponentTeamName?: NullableStringFieldUpdateOperationsInput | string | null
    myTeamPlayers?: InputJsonValue | InputJsonValue
    opponentTeamPlayers?: InputJsonValue | InputJsonValue
    allowSpectators?: BoolFieldUpdateOperationsInput | boolean
    isRoomMatch?: BoolFieldUpdateOperationsInput | boolean
    roomPassword?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLocalMatchStatusFieldUpdateOperationsInput | $Enums.LocalMatchStatus
    currentInnings?: IntFieldUpdateOperationsInput | number
    currentOver?: IntFieldUpdateOperationsInput | number
    currentBall?: IntFieldUpdateOperationsInput | number
    myTeamScore?: IntFieldUpdateOperationsInput | number
    myTeamWickets?: IntFieldUpdateOperationsInput | number
    myTeamOvers?: FloatFieldUpdateOperationsInput | number
    opponentTeamScore?: IntFieldUpdateOperationsInput | number
    opponentTeamWickets?: IntFieldUpdateOperationsInput | number
    opponentTeamOvers?: FloatFieldUpdateOperationsInput | number
    fullState?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchSummaryUpdateWithoutHomeTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    awayTeam?: TeamUpdateOneWithoutMatchSummariesAsAwayNestedInput
    manOfTheMatchUser?: UserUpdateOneWithoutMatchSummariesAsManOfTheMatchNestedInput
    playerHistory?: PlayerMatchHistoryUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryUncheckedUpdateWithoutHomeTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchUserId?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryUncheckedUpdateManyWithoutHomeTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchUserId?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchSummaryUpdateWithoutAwayTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    homeTeam?: TeamUpdateOneWithoutMatchSummariesAsHomeNestedInput
    manOfTheMatchUser?: UserUpdateOneWithoutMatchSummariesAsManOfTheMatchNestedInput
    playerHistory?: PlayerMatchHistoryUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryUncheckedUpdateWithoutAwayTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    homeTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchUserId?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerHistory?: PlayerMatchHistoryUncheckedUpdateManyWithoutMatchSummaryNestedInput
  }

  export type MatchSummaryUncheckedUpdateManyWithoutAwayTeamInput = {
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    homeTeamName?: StringFieldUpdateOperationsInput | string
    homeTeamId?: NullableStringFieldUpdateOperationsInput | string | null
    awayTeamName?: StringFieldUpdateOperationsInput | string
    result?: EnumMatchResultFieldUpdateOperationsInput | $Enums.MatchResult
    winningTeam?: StringFieldUpdateOperationsInput | string
    firstInningsTeam?: StringFieldUpdateOperationsInput | string
    firstInningsRuns?: IntFieldUpdateOperationsInput | number
    firstInningsWickets?: IntFieldUpdateOperationsInput | number
    firstInningsOvers?: FloatFieldUpdateOperationsInput | number
    secondInningsTeam?: StringFieldUpdateOperationsInput | string
    secondInningsRuns?: IntFieldUpdateOperationsInput | number
    secondInningsWickets?: IntFieldUpdateOperationsInput | number
    secondInningsOvers?: FloatFieldUpdateOperationsInput | number
    target?: NullableIntFieldUpdateOperationsInput | number | null
    totalOvers?: IntFieldUpdateOperationsInput | number
    manOfTheMatchPlayerName?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchUserId?: NullableStringFieldUpdateOperationsInput | string | null
    manOfTheMatchStats?: InputJsonValue | InputJsonValue | null
    firstInningsBatsmen?: InputJsonValue | InputJsonValue
    firstInningsBowlers?: InputJsonValue | InputJsonValue
    secondInningsBatsmen?: InputJsonValue | InputJsonValue
    secondInningsBowlers?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryUpdateWithoutTeamInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerMatchHistoryNestedInput
    matchSummary?: MatchSummaryUpdateOneRequiredWithoutPlayerHistoryNestedInput
  }

  export type PlayerMatchHistoryUncheckedUpdateWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    matchSummaryId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryUncheckedUpdateManyWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    matchSummaryId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMatchPlayerCreateManyTeamMatchInput = {
    id?: string
    userId: string
    teamId: string
    runsScored?: number
    ballsFaced?: number
    wasDismissed?: boolean
    oversBowled?: number
    runsConceded?: number
    wicketsTaken?: number
    catchesTaken?: number
  }

  export type TeamMatchPlayerUpdateWithoutTeamMatchInput = {
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutTeamMatchStatsNestedInput
    team?: TeamUpdateOneRequiredWithoutTeamMatchStatsNestedInput
  }

  export type TeamMatchPlayerUncheckedUpdateWithoutTeamMatchInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMatchPlayerUncheckedUpdateManyWithoutTeamMatchInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wasDismissed?: BoolFieldUpdateOperationsInput | boolean
    oversBowled?: FloatFieldUpdateOperationsInput | number
    runsConceded?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    catchesTaken?: IntFieldUpdateOperationsInput | number
  }

  export type MatchSpectatorCreateManyLocalMatchInput = {
    id?: string
    userId: string
    addedBy: string
    addedAt?: Date | string
    notified?: boolean
  }

  export type OverHistoryCreateManyLocalMatchInput = {
    id?: string
    overNumber: number
    innings: number
    balls: InputJsonValue
    totalRuns?: number
    wickets?: number
    createdAt?: Date | string
  }

  export type MatchSpectatorUpdateWithoutLocalMatchInput = {
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutSpectatorOfNestedInput
    addedByUser?: UserUpdateOneRequiredWithoutAddedSpectatorsNestedInput
  }

  export type MatchSpectatorUncheckedUpdateWithoutLocalMatchInput = {
    userId?: StringFieldUpdateOperationsInput | string
    addedBy?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MatchSpectatorUncheckedUpdateManyWithoutLocalMatchInput = {
    userId?: StringFieldUpdateOperationsInput | string
    addedBy?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OverHistoryUpdateWithoutLocalMatchInput = {
    overNumber?: IntFieldUpdateOperationsInput | number
    innings?: IntFieldUpdateOperationsInput | number
    balls?: InputJsonValue | InputJsonValue
    totalRuns?: IntFieldUpdateOperationsInput | number
    wickets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OverHistoryUncheckedUpdateWithoutLocalMatchInput = {
    overNumber?: IntFieldUpdateOperationsInput | number
    innings?: IntFieldUpdateOperationsInput | number
    balls?: InputJsonValue | InputJsonValue
    totalRuns?: IntFieldUpdateOperationsInput | number
    wickets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OverHistoryUncheckedUpdateManyWithoutLocalMatchInput = {
    overNumber?: IntFieldUpdateOperationsInput | number
    innings?: IntFieldUpdateOperationsInput | number
    balls?: InputJsonValue | InputJsonValue
    totalRuns?: IntFieldUpdateOperationsInput | number
    wickets?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryCreateManyMatchSummaryInput = {
    id?: string
    userId: string
    teamName: string
    teamId?: string | null
    playerName: string
    runsScored?: number
    ballsFaced?: number
    wicketsTaken?: number
    oversBowled?: number
    isManOfTheMatch?: boolean
    createdAt?: Date | string
  }

  export type PlayerMatchHistoryUpdateWithoutMatchSummaryInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlayerMatchHistoryNestedInput
    team?: TeamUpdateOneWithoutPlayerMatchHistoryNestedInput
  }

  export type PlayerMatchHistoryUncheckedUpdateWithoutMatchSummaryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMatchHistoryUncheckedUpdateManyWithoutMatchSummaryInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    playerName?: StringFieldUpdateOperationsInput | string
    runsScored?: IntFieldUpdateOperationsInput | number
    ballsFaced?: IntFieldUpdateOperationsInput | number
    wicketsTaken?: IntFieldUpdateOperationsInput | number
    oversBowled?: FloatFieldUpdateOperationsInput | number
    isManOfTheMatch?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}